73 Analyze a Tic-Tac-Toe board

[[:e :e :e]
 [:e :e :e]
 [:e :e :e]]

return nil

[[:x :e :o]
 [:x :e :e]
 [:x :e :o]]

return :x

[[:e :x :e]
 [:o :o :o]
 [:x :e :x]]
 
return :o

(fn tic-tac-toe [board] (let [same? (fn [sec] (if (apply = sec) (first sec) 
nil)) rows (map same? board) cols (map same? (apply map vector board)) 
diag1 (same? (map get board (range 3))) diag2 (same? (map get board (range 
2 -1 -1)))] (some #{:x :o} (concat rows cols [diag1] [diag2]))))


(fn [xss]
  (let [x-count (count xss)
        directions [[0 -1] [-1 -1] [-1 0] [-1 1]]
        lookup-keys #(map (fn [d] [(map + % d) d]) directions)
        fold-key #(fn [agg [l-key r-key]]
                    (if (= (get-in xss l-key) %2)
                      (assoc agg r-key (inc (or (get-in %1 [l-key r-key]) 1)))
                      agg))
        indexes (for [x (range x-count)
                      y (range x-count)
                      :when (not= :e (get-in xss [x y]))]
                  [x y])
        m-fold (fn [data key]
                 (let [l-keys (lookup-keys key)
                       c-player (get-in xss key)
                       next-data (reduce (fold-key data c-player) {} l-keys)]
                   (if (some #(= % x-count) (vals next-data))
                     [c-player nil]
                     [nil (assoc data key next-data)])))
        winner-g (fn [[winner data] key]
                   (if winner [winner] (m-fold data key)))
        [winner] (reduce winner-g [nil {}] indexes)]
    winner))

(fn [[[a00 a01 a02]
    [a10 a11 a12]
    [a20 a21 a22]]]
  (let [s [[a00 a01 a02] [a10 a11 a12] [a20 a21 a22] [a00 a10 a20] [a01 a11 a21] [a02 a12 a22] [a00 a11 a22] [a02 a11 a20]]
        xs (count (filter #(= % 3) (map count (map (fn [x] (filter #(= % :x) x)) s))))
        os (count (filter #(= % 3) (map count (map (fn [x] (filter #(= % :o) x)) s))))]
    (if (= xs 1)
      :x
      (if (= os 1)
        :o
        nil))))

(fn [board]
  (let [rows board ;get rows
        columns (apply map vector board) ;get columns
        diagonals [(map get board [0 1 2]) (map get board [2 1 0])]] ;get diagonals
    (loop [remaining (concat rows columns diagonals)] ;all potential triplets
      (if-let [item (set (first remaining))]
        (if (and (not-any? #(= :e %) item) (or (every? #(= :x %) item) (every? #(= :o %) item)));find the winner
          (first item)
          (recur (rest remaining)))
        nil))));or return nil

(let
  [check (fn [& sets] 
    (first (filter #(not (nil? %))
      (map
        (fn [ss]
          (let [r (first (filter #(or (= % #{:x}) (= % #{:o})) ss))]
            (if r (first r) nil)))
        sets))))]
  (fn ttt [board] 
    (check
      (map set board)
      (map set (apply map list board))
      (list (set (map #(nth (nth board %) %) (range 3))))
      (list (set (map #(nth (nth board %) (- 2 %)) (range 3))))
)))

aceeca1's solution:

1
(fn [x] (ffirst (filter #(and (apply = %) (not= (first %) :e)) (partition 3 (map (vec (flatten x)) '(0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6))))))
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [board]
  (let [horizontal-winner (fn [board player]
                            (some identity (map #(every? (partial = player) %) board)))
        vertical-winner (fn [board player]
                          (horizontal-winner (apply map vector board) player))
        ul-diag-winner (fn [board player]
                         (= (get-in board [0 0])
                            (get-in board [1 1])
                            (get-in board [2 2])
                            player))
        diag-winner (fn [board player]
                      (or (ul-diag-winner board player)
                          (ul-diag-winner (vec (map (comp vec reverse) board)) player)))
        winner? (fn [player]
                  (or (horizontal-winner board player)
                      (vertical-winner board player)
                      (diag-winner board player)))]
    (cond
     (winner? :x) :x
     (winner? :o) :o
     )))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
(fn ticTacToeX [m]
    (cond
        ((fn ticTacToeSymbol [m s]
    (let 
        [
        x (get m 0)
        y (get m 1)
        z (get m 2)
        ]
        
    (or
    ((fn all [x s] (every? #(= % s) x)) x s)
    ((fn all [x s] (every? #(= % s) x)) y s)
    ((fn all [x s] (every? #(= % s) x)) z s)
    ((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 0) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 1) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 2) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn diagonaLeft [x y z] [(get x 0)(get y 1)(get z 2)]) x y z) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn diagonalRight [x y z] [(get x 2)(get y 1)(get z 0)]) x y z) s)
    ))
) m :x) :x
        ((fn ticTacToeSymbol [m s]
    (let 
        [
        x (get m 0)
        y (get m 1)
        z (get m 2)
        ]
        
    (or
    ((fn all [x s] (every? #(= % s) x)) x s)
    ((fn all [x s] (every? #(= % s) x)) y s)
    ((fn all [x s] (every? #(= % s) x)) z s)
    ((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 0) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 1) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 2) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn diagonalLeft [x y z] [(get x 0)(get y 1)(get z 2)]) x y z) s)
    ((fn all [x s] (every? #(= % s) x)) ((fn diagonalRight [x y z] [(get x 2)(get y 1)(get z 0)]) x y z) s)
    ))
) m :o) :o
        :else nil
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn winner? [table]
  (let [get-table-value (fn [x y]
                          (-> table
                            (nth y)
                            (nth x)))
        collect (fn [xs]
                  (->> xs
                    (map (fn [f] (for [x (range 3)
                                       y (range 3)
                                       :when (f x y)] (get-table-value x y))))
                    (filter (partial apply =))
                    (map first)
                    (remove (partial = :e))
                    first))
        fix-x (fn [c]
                (fn [x y] (= x c)))
        fix-y  (fn [c]
                (fn [x y] (= y c)))
        fixes (fn [f] (map (fn [x] (f x)) (range 3)))
        diag1 (fn [x y] (= x y))
        diag2 (fn [x y] (= x (- 2 y)))
        filters (concat [diag1 diag2]
                       (fixes fix-x)
                       (fixes fix-y))]
    (collect filters)))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [board]
  (letfn [(columns [b] (apply map vector b))
          (lrdiag [b] (map #(nth (nth b %) %) (-> b count range)))
          (rldiag [b] (map #(nth (nth b %) (-' (count b) % 1)) (-> b count range)))
          (winner-slice [r]
            (cond
             (not (every? #(= (first r) %) r)) nil
             (= (first r) :e) nil
             :else (first r)))
          (all-slices [b] (concat b (columns b) [(lrdiag b)] [(rldiag b)]))
          (winner [b] (first (remove nil? (map winner-slice (all-slices b)))))]
    (winner board)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(fn check-ttt [b]
  (letfn [(hwin [b]
            (loop [b b]
              (if (and b)
                (let [player (first (first b))]
                  (if (and (not= player :e) (= (count (set (first b))) 1))
                    player
                    (recur (next b)))))))
 
          (vwin [b]
            (loop [i 0]
              (if (> i 2)
                nil
                (let [col (apply concat (partition 1 3 (drop i (apply concat b))))]
                  (if (and (not= (first col) :e) (= (count (set col)) 1))
                    (first col)
                    (recur (inc i)))))))
 
          (dwin [[[x1 __ x2]
                       [__ x3 __]
                       [x4 __ x5]]]
            (cond
              (and (not= :e x1) (= x1 x3 x5)) x1
              (and (not= :e x2) (= x2 x3 x4)) x2
              :else nil))
          ]
    (or (vwin b)
        (hwin b)
        (dwin b))))
andthorn's solution:

1
2
3
4
5
6
7
8
(fn [board]
  (let [board (apply concat board)
        tests [[0 3 6] [1 4 7] [2 5 8]
               [0 1 2] [3 4 5] [6 7 8]
               [0 4 8] [2 4 6]]
        lines (map #(set (map (partial nth board) %)) tests)
        equal (filter #(and (= (count %) 1) (not= (first %) :e)) lines)]
   (first (first equal))))
anjensan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [d]
  (let [n [0 1 2]
        s (set
            (concat
              d
              (apply map list d)
              [(for [a n] (get-in d [a a]))
               (for [a n] (get-in d [(- 2 a) a]))]))]
    (cond
      (s [:x :x :x]) :x
      (s [:o :o :o]) :o
      :e nil)))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn
  [board]
  (letfn [(pRow [value row]
            (every? (partial = value) (board row)))
          (pCol [value col]
            (every? (partial = value) (map #(% col) board)))
          (pDiag [value]
            (or (= value
                   (get-in board [0 0])
                   (get-in board [1 1])
                   (get-in board [2 2]))
                (= value
                   (get-in board [0 2])
                   (get-in board [1 1])
                   (get-in board [2 0]))))
          (win [value]
            (or (some (partial pRow value) (range 3))
                (some (partial pCol value) (range 3))
                (pDiag value)))]
    (cond
      (win :x) :x
      (win :o) :o
      :else    nil)))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
(fn [b]
  (let [
    goals (concat
      b
      (apply map vector b)
      [[(ffirst b) (second (second b)) (last (last b))]
      [(last (first b)) (second (second b)) (first (last b))]])
    win (fn [p] (some (partial every? (partial = p)) goals))]
  (cond (win :x) :x (win :o) :o)))
awebb's solution:

1
2
3
4
5
6
7
8
9
10
(fn [ [[a b c]
       [d e f]
       [h i j] :as board] ]
     
     (let 
       [test-line (fn [line] (reduce #(when (= %1 %2) %1) line))
        lines  (concat board (apply map vector board) [[a e j] [c e h]])
        scored-lines (map test-line lines) ]
    
       (some #{:x :o} scored-lines)  ))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
(fn [board] 
  (ffirst 
    (filter 
      #(or (= % [:x :x :x]) (= % [:o :o :o])) 
      (concat 
        board 
        (partition 3 (apply interleave board)) 
        (map 
          #(take-nth 4 (flatten %)) 
          [board (map reverse board)])))))
benhammond's solution:

1
2
3
4
5
6
7
8
9
(fn [b]
    (let [v (ffirst (filter (partial apply =)
                            (map (fn [line] (mapv (partial get-in b) line))
                                 (concat
                                   (mapv (fn [r] (mapv (fn [c] [c r]) (range 3))) (range 3))
                                   (mapv (fn [r] (mapv (fn [c] [r c]) (range 3))) (range 3))
                                   [(mapv (fn [cr] [cr cr]) (range 3))]
                                   [(mapv (fn [cr] [(- 2 cr) cr]) (range 3))]))))]
      (if (= v :e) nil v)))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
(fn [board]
  (let [[& rows] board
        cols (apply (partial map vector) rows)
        [[a1 _ b1] [_ c _] [b2 _ a2]] board
        diags [[a1 c a2] [b1 c b2]]
        ifsame (fn [args] (when (apply = args) (first args)))
        sames (map ifsame (concat rows cols diags))
        goods (filter #{:x :o} sames)
        winner (first goods)]
    winner))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn [board]
  (let [b (map
            (fn [p] (map #(cond (= % :e) 0
                                (= % :x) 1
                                (= % :o) -1)
                         p))
            board)
        naname (fn [x]
                 (loop [x x s 0 i 0]
                   (if (empty? x)
                     s
                     (recur (rest x) (+ s (nth (first x ) i)) (+ 1 i)))))
        naname2 (fn [x]
                 (loop [x x s 0 i 0]
                   (if (empty? x)
                     s
                     (recur (rest x) (+ s (nth (first x ) (- 2 i))) (+ 1 i)))))
        c (fn [x] (cond (some #(= % 3) x) :x
                        (some #(= % -3 )x) :o
                        :else nil))]
    (c (concat
         (list (naname b))
         (list (naname2 b))
         (map #(reduce + %) b)
         (map #(+ %1 %2 %3)
              (nth b 0)
              (nth b 1)
              (nth b 2))))))
burner's solution:

1
2
3
4
5
6
7
8
(fn [field]
        (letfn [(rows [] field)
                (cols [] (apply map vector field))
                (crosses [] [[(get-in field [0 0]) (get-in field [1 1]) (get-in field [2 2])]
                             [(get-in field [0 2]) (get-in field [1 1]) (get-in field [2 0])]])
                (full [sym] (some (fn [seq] (every? #(= % sym) seq)) (concat (rows) (cols) (crosses))))] 
          (cond (full :x) :x
                (full :o) :o)))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
#(letfn [(getRow [b r] (get b r))
         (getCol [b c] (for[r b] (get r c)))
         (getDia [b f s] (loop [rb b i s r []]
                           (if (seq rb) (recur (rest rb) (f i) (conj r (get (first rb) i))) 
                             r)))
         (win [v] (let [fv (first v)]
                    (if (and (apply = v) (not= fv :e)) fv false)))
         (testRowCol [b f]
                  (reduce (fn [x y] (if (not= y false) y x)) false (map win (map (partial f b) (range 0 3)))))]
   (let [rowResult (testRowCol % getRow)]
     (if (not (false? rowResult)) rowResult
       (let [colResult (testRowCol % getCol)]
         (if (not (false? colResult)) colResult
           (let [dia1Result (win (getDia % inc 0))]
             (if (not (false? dia1Result)) dia1Result
               (let [dia2Result (win (getDia % dec 2))]
                 (if (not (false? dia2Result)) dia2Result
                   nil)))))))))
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [x]
   (let [result (set
                 (concat
                  (map set x)
                  (->> x (apply map vector) (map set))
                  (list
                   (->> x ((juxt ffirst #(second (second %)) #(last (last %)))) set)
                   (->> x ((juxt #(last (first %)) #(second (second %)) #(first (last %)))) set))))]
     (first
      (or (result #{:o})
          (result #{:x})))
     ))
chunchangshao's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [t]
  (let
      [c1 (map first t)
       c2 (map second t)
       c3 (map last t)
       tra1 (map #(get-in t %) [[0 0] [1 1] [2 2]])
       tra2 (map #(get-in t %) [[0 2] [1 1] [2 0]])
       t (conj t c1 c2 c3 tra1 tra2)]
    (some #(if (or
                (= :e (first %))
                (< 1 (count (distinct %))))
             nil
             (first %)) t)))
ctzsm's solution:

1
2
3
4
5
(fn [ttt] (let [c (concat ttt (map (fn [index] (map #(% %2) ttt index)) [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]))
                t (fn [m item] (some identity (map #(apply = (conj % item)) m)))]
            (cond (t c :o) :o
                  (t c :x) :x
                  :else nil)))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
(letfn [(transpose
         [matrix]
         (apply mapv vector matrix))
        
        (diagonal'
         [matrix]
         (->> (range (count matrix))
              (mapv #(get-in matrix [% %]))))
        
        (diagonals
         [matrix]
         (mapv diagonal'
               [matrix
                (mapv (comp vec rseq)
                      matrix)]))
        
        
        (check
         [player board]
         (some (partial every? #{player})
               board))
           
        (wins?
         [player board]
         (some (partial check player)
               ((juxt identity
                      transpose
                      diagonals)
                board)))]
  
  (fn tic-tac-toe [board]
    (some #(when (wins? % board) %)
          [:x :o])))
daniels's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [b]
  (let [fb (into [] (flatten b))
        p [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]
        f #( if
             (and 
              (not= :e (fb (first %))) 
              (= (fb (first %)) (fb (second %)) (fb (last %))) ) 
             (fb (first %))
             nil
             )]
    (some f p)))
daowen's solution:

1
2
3
4
5
6
7
(fn [rows]
  (let [cols (apply map vector rows)
        diag (fn [x] (map-indexed #(nth %2 %) x))
        diags [(diag rows) (diag (map reverse rows))]
        lines (concat rows cols diags)
        line-sets (map set lines)]
    (first (some #{#{:x} #{:o}} line-sets))))
del680202's solution:

1
2
3
4
5
6
7
8
9
(fn [[r1 r2 r3]]
 (let [all-comb [r1 r2 r3 [(first r1) (first r2) (first r3)] [(second r1) (second r2) (second r3)] [(last r1) (last r2) (last r3)] 
   [(first r1) (second r2) (last r3)]  [(last r1) (second r2) (first r3)]
   ]
     won (fn [s symb](every? #(= symb %) s))
   ]
    (or (first (first (filter #(won % :x) all-comb))) (first (first (filter #(won % :o) all-comb))))
  )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [b]
  (letfn
    [(anarow  
      [a b c]
      (if (and (= a b) (= b c))
        a nil))
     (akabd 
      [b]
      (let [a1 (first b) a2 (second b) a3 (last b)
            a11 (first a1) a12 (second a1) a13 (last a1)
            a21 (first a2) a22 (second a2) a23 (last a2)
            a31 (first a3) a32 (second a3) a33 (last a3)]
        [(anarow a11 a12 a13) (anarow a21 a22 a23) (anarow a31 a32 a33)
         (anarow a11 a21 a31) (anarow a12 a22 a32) (anarow a13 a23 a33)
         (anarow a11 a22 a33) (anarow a13 a22 a31)]))
     (findnn
      [l]
      (some #(when (not= nil %) %) l)
      )
     (check 
      [x]
      (if (or (= x :x) (= x :o)) x nil)
      )]
    (-> b akabd findnn check)
    ))
devm33's solution:

1
2
3
4
5
6
7
8
9
(fn [rows]
  (let
    [checkxo (fn [pred] (if (pred :x) :x (if (pred :o) :o nil)))
     alleq (fn [c coll] (apply = c coll))
     hasgroupeq (fn [c groups] (some (partial alleq c) groups))
     cols (apply map vector rows)
     diag (map-indexed #(nth %2 %1) rows)
     bdiag (map-indexed #(nth %2 (- (dec (count (first rows))) %1)) rows)]
    (checkxo #(hasgroupeq % (concat rows cols [diag bdiag])))))
dwelte's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(let [
  lines [
    [[0 0] [0 1] [0 2]]
    [[1 0] [1 1] [1 2]]
    [[2 0] [2 1] [2 2]]
    [[0 0] [1 0] [2 0]]
    [[0 1] [1 1] [2 1]]
    [[0 2] [1 2] [2 2]]
    [[0 0] [1 1] [2 2]]
    [[0 2] [1 1] [2 0]]]
  get-line (fn [board line]
    (let [vals (map #(get-in board %) line)]
      (if (apply = vals)
        (if (= (first vals) :e)
          nil
          (first vals))
        nil)))]
  (fn [board]
    (some identity (map #(get-line board %) lines))))
dzholev's solution:

1
2
3
4
5
(fn [s]
  (let [positions (concat (map #(repeat 3 %) (range 3)) [[0 1 2] [2 1 0]])
        get-line (fn [tr] (map nth s tr))
        rcd (concat s (map get-line positions))]
    (some {[:x :x :x] :x [:o :o :o] :o} rcd)))
echevarria's solution:

1
2
3
4
5
6
7
8
(fn check-tictactoe [b]
    (let [ d1 ((juxt ffirst (comp second second) (comp last last)) b)
            d2 ((juxt (comp last first) (comp second second) (comp first last)) b)
            tr (apply (partial map (fn [& xs] (concat xs))) b)
            l (conj (reduce conj b tr) d1 d2)
            f (fn [v]  (let [[k c] (last (sort-by second (frequencies v)))]
                (if (and (= c 3) (not= k :e)) k)))]
            (reduce #(or %1 %2) (map f l))))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(letfn [                                                                                                                                                
    (rows [b] (map identity b))                                                                                                 
    (cols [b] (apply map #(vector %1 %2 %3) b))                                                                                                         
    (dias [b]                                                                                                                   
        (let [size (count b)]                                                                                                                           
            (list                                                                                                               
                (map #((b %1) %2) (range size) (range size))                                                                                            
                (map #((b %1) %2) (range size) (range (dec size) (dec 0) -1)))))                                                
    (all [b] (concat (rows b) (cols b) (dias b)))                                                                                                       
    (winner? [b]                                                                                                                
        (let [a (all b)]                                                                                                                                
            (cond                                                                                                               
                (some (partial = [:x :x :x]) a) :x                                                                                                      
                (some (partial = [:o :o :o]) a) :o                                                                              
                :else nil)))]                                                                                                                           
    winner?)
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [board]
  (let [win? (fn [k v] (and (not= :e k) (= 3 v)))
        win-f (fn [freqs]
                (reduce (fn [win f]
                          (or win
                              (reduce-kv (fn [res k v]
                                           (or res (when (win? k v) k)))
                                         win
                                         f)))
                        nil
                        freqs))
        diags (let [rng (range (count board))]
                (list
                 (map #(get-in board [% %]) rng)
                 (map (fn [m n] (get-in board [n m])) rng (reverse rng))))
        row-win (win-f (map frequencies board))
        coll-win (win-f (apply map (fn [& c] (frequencies c)) board))
        diag-win (win-f (map frequencies diags))]
    (or row-win coll-win diag-win)))
finsternis's solution:

1
2
3
4
5
(fn [b]
  (letfn [(win [ts xo] (if (some identity (map #(every? #{xo} %) ts)) xo))
          (diagonal [b] (vector (flatten (partition 1 4 (flatten b)))))]
    (let [rs (concat b (apply map list b) (diagonal b) (diagonal (map reverse b)))]
      (some identity (map #(win rs %) [:x :o])))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
(fn tictactoe
  [m]
  (letfn [(tr [m] (apply map vector m))
          (diag [[[a _ b][_ c _][d _ e]]] [[a c e] [b c d]])]
    (first (first
      (filter 
        #(and 
          (= 1 (count (distinct %)))
          (not= :e (first %)))
        (concat m (diag m) (tr m)))))))
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [board]
  (letfn [(check-horizonal [board]
            (first (flatten (filter #(every? #{:x :o } %) (filter #(= 1 (count (set %))) board)))))]
    (let [h (check-horizonal board)]
      (if
        h
        h
        (let [v (check-horizonal (apply (partial map #(vec [%1 %2 %3])) board))]
          (if
            v
            v
            (let [fd (check-horizonal [[(first (first board)) (second (second board)) (last (last board))]])]
              (if
                fd
                fd
                (check-horizonal [[(last (first board)) (second (second board)) (first (last board))]])))))))))
geekerzp's solution:

1
2
3
(fn [[[a b c :as f] [d e f :as s] [g h i :as t]]]
    (some {[:o :o :o] :o [:x :x :x] :x}
          [f s t [a d g] [b e h] [c f i] [a e i] [c e g]]))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(letfn[
  (tic-tac-toe-lines [board]
    (let [size (count board)]
        (concat board
                (for [col (range size)] (map #(get % col) board))
                [(map-indexed #(get %2 %1) board)]
                [(map-indexed #(get %2 (dec (- size %1))) board)]
        )))
  (check-line [line]
    (let [res (reduce #(if (= %1 %2) %1 nil) line)]
        (if (= res :e) nil res)
    ))]
 #(some check-line (tic-tac-toe-lines %))
)
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn tic [X]
 (let [wi [[0 1 2] [3 4 5] [6 7 8]
           [0 3 6] [1 4 7] [2 5 8]
       [0 4 8] [2 4 6]]
       xf (flatten X)]
   (first (remove #(nil? %) (for [w wi]
    (let [arn (map #(nth xf %) w)]
         (when (and (not= (nth arn 0) :e) 
             (and (= (nth arn 0) (nth arn 1)) 
         (= (nth arn 1) (nth arn 2))))
         (nth arn 0))))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
(fn [board]
  (let [all-lines
        (concat board
                (apply mapv vector board)
                [(take-nth 4 (flatten board))]
                [(take 3 (take-nth 2 (drop 2 (flatten board))))])]
    (println all-lines)
    (or (ffirst (filter (partial apply = :x) all-lines))
        (ffirst (filter (partial apply = :o) all-lines))
        nil)))
happycrisis's solution:

1
2
3
(let [grps [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]
  (fn [game] (let [game (vec (apply concat game))]
               (first (some #{#{:x} #{:o}} (map #(set (map game %)) grps))))))
hisba's solution:

1
2
3
4
5
6
(fn [tttb]
  (let [cnt (count tttb)
        diags [(for [i (range cnt)] ((tttb i) i)) (for [i (range cnt)] ((tttb (- cnt i 1)) i))]
        cols (for [x (range cnt)] (for [y (range cnt)] ((tttb y) x)))
        full-axes (remove (fn [a] (some #(= :e %) a)) (concat tttb diags cols))]
    (first (first (filter #(apply = %) full-axes)))))
icamts's solution:

1
2
3
4
5
6
7
8
9
(fn [board] (let [rfn (partial map (partial apply list)) 
                  cfn (partial apply map list) 
                  pfn (fn [r1 r2 board] (list (map (fn [[i1 i2]] (-> board (nth i1) (nth i2))) 
                                             (apply map vector (list r1 r2)))))
                  enil (fn [k] (if (= :e k) nil k))]
              (enil (ffirst (drop-while (partial apply not=) 
                          (concat (rfn board) (cfn board) 
                                  (pfn (range 3) (range 3) board) 
                                  (pfn (range 3) (range 2 -1 -1) board)))))))
immo's solution:

1
Scored 181, before 4clojure started saving solutions.
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [board]
  (let [row (fn [r] (board r))
        col (fn [c] (map #(% c) board))
        diag (fn [coord] (map #(get-in board %) coord))
        d1 (diag [[0 0] [1 1] [2 2]])
        d2 (diag [[0 2] [1 1] [2 0]])
        r3 (range 3)
        lines (concat 
                (map row r3)
                (map col r3)
                [d1 d2])
        win? (fn [[x & xs]] (if (and
                                  (not= x :e)
                                  (every? #(= x %) xs))
                              x))]
    (->> lines
         (map win?)
         (filter (complement nil?))
         first)))
jedo's solution:

1
2
3
4
5
6
7
(fn [b]
(let [pos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [6 4 2]] board (flatten b)]
((fn [res] (cond (some #{:x} res) :x (some #{:o} res) :o :else nil))
    (map (fn [v] (reduce (fn [x y] (if (= x y) x false)) 
        (map (fn [x] (nth (flatten board) x)) v))) 
        pos))
))
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [b]
  (letfn [(row [i] (nth b i))
          (col [j] (mapv #(nth % j) b))
          (dex [] (mapv #(get-in b [% %]) (range 3)))
          (sin [] (mapv #(get-in b [% (- 2 %)]) (range 3)))
          (sets []
            (concat
              (map row (range 3))
              (map col (range 3))
              [(dex) (sin)]))
          (winner [set]
            (when (and (apply = set)
                       (not= :e (first set)))
              (first set)))]
    (first (keep winner (sets)))))
johncowie's solution:

1
2
3
4
5
6
7
8
9
(fn [brd]
  (let [won? (fn [p]
    (reduce #(or %1 %2)
       (flatten
          [ (for [y (range 0 3)] (= p ((brd 0) y) ((brd 1) y) ((brd 2) y)))
            (for [x (range 0 3)] (= p ((brd x) 0) ((brd x) 1) ((brd x) 2)))
            (= p ((brd 0) 0) ((brd 1) 1) ((brd 2) 2))
            (= p ((brd 0) 2) ((brd 1) 1) ((brd 2) 0))])))]
    (cond (won? :x) :x (won? :o) :o :else nil)))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn solve [board]
  (letfn [(transpose [matrix]
                     (apply mapv vector matrix))
          (trace [matrix]
                 (mapv (fn [coll idx] (nth coll idx)) 
                       matrix (range)))
          (rotate [coll]
                  (conj (subvec coll 1) (first coll)))
          (rotate-n [coll n]
                    ((apply comp (repeat n rotate)) coll))
          (symmetric-trace [matrix]
                           (->>
                            (trace
                             [(rotate-n (first matrix) 2)
                              (second matrix)
                              (rotate-n (last matrix) 1)])
                            (conj [] (trace matrix))))]
    (let [x-win [:x :x :x]
          o-win [:o :o :o]]
      (if (or (contains? (set board) x-win)
              (contains? (set (transpose board)) x-win)
              (contains? (set (symmetric-trace board)) x-win))
        :x
        (if (or (contains? (set board) o-win)
                (contains? (set (transpose board)) o-win)
                (contains? (set (symmetric-trace board)) o-win))
          :o
          nil)))))
jorendorff's solution:

1
2
3
4
#(let [win (fn [a b c] (when (and (= a b c) (not= a :e)) a))
       [[a b c] [d e f] [g h i]] %]
   (or (win a b c) (win d e f) (win g h i) (win a e i)
       (win a d g) (win b e h) (win c f i) (win c e g)))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn tictac [board]
  (let [vertical [(vec (map first board)) (vec (map second board)) (vec (map #(nth % 2) board))]
        diag [[(first (first board)) (second (second board)) (nth (nth board 2) 2)]
              [(nth (first board) 2) (second (second board)) (first (nth board 2))]]
        all  (concat board vertical diag)
        fe  (filter #(not (some (fn [v] (= :e v)) %)) all)
        xs  (filter #(every? (fn [v] (= :x v)) %) fe)
        os  (filter #(every? (fn [v] (= :o v)) %) fe)]
    (cond (> (count xs) 0) :x
          (> (count os) 0) :o
          :otherwise nil)
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
; This works with a N x N board for arbitrary N.
(fn [b]
  (let [rows #(apply (partial map vector) %)
        nn   #(nthnext % %2)
        won? (fn [p]
               (some #(apply = (conj % p))
                 (concat
                   b (rows b)
                   (rows (map nn b (range)))
                   (rows (map nn (reverse b) (range))))))]
    (cond (won? :x) :x
          (won? :o) :o
          :else     nil)))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [v]
  (->> (-> (apply map (fn [x1 x2 x3] [x1 x2 x3]) v)
           (#(into % v))
           vec
           (conj (first (reduce (fn [[a i] x] [(conj a (nth x i)) (inc i) ]) [[] 0] v)))
           (conj (first (reduce (fn [[a i] x] [(conj a (nth x i)) (dec i) ]) [[] 2] v)))
           )
 
       (filter #(apply = %))
       first
       first
       (#(if (= % :e) nil %))
       ))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn prob73 [m]
  ;; return first path that contains all :x or :o
  ;; if none return nil
  (letfn [(triples [m]
            (concat (rows m) (cols m) (diags m)))
          (rows [m]
            (map #(row m %) (range 3)))
          (row [m n] (nth m n))
          (cols [m]
            (map #(col m %) (range 3)))
          (col [m n] (vec (map #(nth % n) m)))
          (diags [m] 
            (list [(last (col m 0)) (second (col m 1)) (first (col m 2))]
                  [(first (col m 0)) (second (col m 1)) (last (col m 2))]))]
  (let [tups (triples m)]
    (print tups)
    (print (count (filter #(= [:x :x :x] %) tups)))
    (if (> (count (filter #(= [:x :x :x] %) tups)) 0)
      :x
      (if (> (count (filter #(= [:o :o :o] %) tups)) 0)
        :o
        nil
        )))))
brendan's solution:

1
2
3
4
5
6
7
(fn [R A M b]
  (some #(and (A = %) (#{:x :o} (first %)))
        ` (~@ b 
          ~@ (A M list b) 
          ~ (M #(%2 %) R b) 
          ~(M #(%2 (- 2 %)) R b)))) 
[0 1 2] apply map
kuze's solution:

1
2
3
4
5
6
7
8
9
(fn myAnalizeTTT
  [ttt]
  (let [getCrossElementIds (fn [tictactoe] (map vector (take (count tictactoe) (range)) tictactoe))
        getCrossElements (fn [result tttCrosCount] (conj result (nth (second tttCrosCount) (first tttCrosCount))))
        tttv (map set ttt)
        ttth (map set (apply map list ttt))
        ttts1 (set (reduce getCrossElements [] (getCrossElementIds ttt)))
        ttts2 (set (reduce getCrossElements [] (getCrossElementIds (reverse ttt))))]
    (first (flatten (filter #(and (= 1 (count %)) (not (= % [:e]))) (map vec (flatten (list tttv ttth ttts1 ttts2))))))))
lackita's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [b]
  (letfn [(winner [s] 
            (if (= (count (distinct s)) 1)
              (first (distinct s))
              nil))
          (check-winner [w] 
            (if (and w (not (= w :e)))
              w
              nil))]
    (check-winner (or (winner (map first b))
                      (winner (map second b))
                      (winner (map last b))
                      (winner (first b))
                      (winner (second b))
                      (winner (last b))
                      (winner (map nth b (range 3)))
                      (winner (map nth b (reverse (range 3))))
                      )
                  )
    )
  )
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [rows]
  (let [columns (apply map vector rows)
        diagonals [[(get-in rows [0 0])
                    (get-in rows [1 1])
                    (get-in rows [2 2])]
                   [(get-in rows [0 2])
                    (get-in rows [1 1])
                    (get-in rows [2 0])]]]
    (some #(if (and
                (not= :e (first %))
                (apply = %))
             (first %))
          (concat rows columns diagonals))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
(fn [board]
 (let [row-win (fn [board]
                (let [rows (map distinct board)]
                  (reduce
                   (fn [winner row]
                     (if-not (nil? winner)
                       winner
                       (if (and (= (count row) 1) (not= (first row) :e))
                         (first row)
                         nil
                         )
                       )
                     )
                   nil
                   rows
                   )
                  )
                )
      col-win (fn [board]
                (let [board-90 [(map first board)
                                (map second board)
                                (map last board)]]
                  (row-win board-90)
                  )
                )
      diag-win (fn [board]
                 (if (= (second (second board)) :e)
                   nil
                   (if (= (first (first board))
                          (second (second board))
                          (last (last board)))
                     (first (first board))
                     (if (= (last (first board))
                            (second (second board))
                            (first (last board)))
                       (last (first board))
                       nil
                       )
                     )
                   )
                 )
      ]
  (if-let [row (row-win board)]
    row
    (if-let [col (col-win board)]
      col
      (if-let [diag (diag-win board)]
        diag
        nil
        )
      )
    )
   )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
(letfn [(diags [b]
               [(map #(get-in b [% %]) [0 1 2])
                (map #(get-in b [% (- 2 %)]) [0 1 2])])
        (cols [b]
              (apply map vector b))
        (rows [b] b)
        (winner [r] (cond
                     (apply = :o r) :o
                     (apply = :x r) :x))]
  (fn win? [board]
   (some identity (map winner (concat (diags board) (cols board) (rows board))))))
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [ls]
  (let [winner? (fn [ls] (or (every? #(= % :x) ls) (every? #(= % :o) ls)))
        t-w (fn [l] (when (winner? l) (first l)))]
    (some t-w
    (lazy-cat 
      ls 
      (map #(map (fn [l] (get l %)) ls) [0 1 2])
      ((juxt #(map first %) #(map second %)) 
          (map 
            #(vector (get %1 %2)
               (get %1 (- 2 %2)))
            ls [0 1 2]))))))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [[l1 l2 l3]]
  (first
    (filter 
      (partial contains? #{:o :x})
      (map 
        (partial reduce #(if (and (= %1 %2) (not= %1 :e)) %1 nil))
        (concat 
          [l1 l2 l3] 
          [[(first l1) (second l2) (last l3)]
          [(last l1) (second l2) (first l3)]]
          (apply map list [l1 l2 l3]))))))
malvert's solution:

1
2
3
4
5
6
(fn [b] 
  (some
      (comp first #{#{:o} #{:x}} set)
      (concat b 
        (map #(map nth b [% % %]) [0 1 2])
        (map #(map nth b %) [[0 1 2] [2 1 0]]))))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [board]
(let [x-row (repeat 3 :x)
      o-row (repeat 3 :o)
      straight #(or (some #{x-row} %)
                    (some #{o-row} %)
                    nil)]
  (or (first (straight board)) ; win by row
      (let [transposed (apply map list board)]
        (first (straight transposed))) ; win by column
      (let [diagonals [(map #(get-in board [% %])
                            [0 1 2])
                       (map #(get-in board [%1 %2])
                            [0 1 2] [2 1 0])]]
        (first (straight diagonals))) ; win by diagonal
      nil))) ; no win
maximental's solution:

1
2
3
4
5
6
7
(fn [R A M b]
  (some #(and (A = %) (#{:x :o} (first %)))
        `(~@b 
          ~@(A M list b) 
          ~(M #(%2 %) R b) 
          ~(M #(%2 (- 2 %)) R b)))) 
[0 1 2] apply map
mbakhterev's solution:

1
2
3
4
5
6
(fn [B]
  (let [T (partial repeat 3)
        R (range 3)
        V (concat [R (reverse R)] (map #(T %) R))
        L (concat B (map #(map nth B %) V))]
    (some {(T :x) :x (T :o) :o} L)))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
(fn tic-tac-toe [board]
  ;; Validating the board by pre-condition:
  {:pre [(= 3 (count board)),                 ; The board has 3 rows.
         (every? #(= 3 (count %)) board),     ; Each row has 3 entries.
         (every? (partial every? #{:x :o :e})
                 board),                      ; Each entry is :x, :o, or :e.
         ;; And the number of :x's is either equal to the number of :o's,
         ;; or exactly one greater:
         (let [count-piece
               (fn [sym] (sym (frequencies (flatten board))))]
           (or (= (count-piece :x) (count-piece :o))
               (= (count-piece :x) (inc (count-piece :o)))))]}
 
  ;; Now that we know the board is structurally correct, we create some tools to
  ;; analyze it:
 
  (let [;; It will be convenient to work with the board in the form of a single
        ;; vector, so that we can address positions by index as in the diagram:
        ;;   [[0 1 2]
        ;;    [3 4 5]
        ;;    [6 7 8]]
        flat-board (->> board flatten vec),
 
        ;; There are only eight winning positions in tic-tac-toe; if a player
        ;; occupies all three entries in a given position, that player has
        ;; won. This set enumerates them all.
        wins #{[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]},
 
        ;; The check-pos function wraps one of these winning positions in a
        ;; predicate that returns :x or :o in the case of a win by that
        ;; position, and nil otherwise.
        check-pos (fn [[a b c :as pos]]
                    (cond
                      (apply not= (map flat-board pos))  nil
                      (= (flat-board a) :e)              nil
                      :else                              (flat-board a)))]
 
    ;; And now it's just a matter of checking all positions.
    (some check-pos wins)))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
(fn [board]
  (let [winning-positions
        [(fn [[[a _ _]
               [b _ _]
               [c _ _]]]
           [a b c])
         (fn [[[_ a _]
               [_ b _]
               [_ c _]]]
           [a b c])
         (fn [[[_ _ a]
               [_ _ b]
               [_ _ c]]]
           [a b c])
         (fn [[[a b c]
               [_ _ _]
               [_ _ _]]]
           [a b c])
         (fn [[[_ _ _]
               [a b c]
               [_ _ _]]]
           [a b c])
         (fn [[[_ _ _]
               [_ _ _]
               [a b c]]]
           [a b c])
         (fn [[[a _ _]
               [_ b _]
               [_ _ c]]]
           [a b c])
         (fn [[[_ _ a]
               [_ b _]
               [c _ _]]]
           [a b c])]
        won? (fn [mark]
               (some #(if (apply = mark (% board))
                       mark)
                     winning-positions))]
    (some won? [:x :o])))
minitrue's solution:

1
2
3
4
5
6
7
8
(fn [[top mid bottom :as board]]
  (let [xss
        (concat board (map vector top mid bottom)
          [[(top 0) (mid 1) (bottom 2)]
          [(top 2) (mid 1) (bottom 0)]])]
    (cond (some true? (map #(every? #{:x} %) xss)) :x
          (some true? (map #(every? #{:o} %) xss)) :o
          :else nil)))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn tictactoe [x]
     (let [y (vec (flatten x))]
       (if (or (and (= (get y 0) :x) (= (get y 1) :x) (= (get y 2) :x))
               (and (= (get y 3) :x) (= (get y 4) :x) (= (get y 5) :x))
               (and (= (get y 6) :x) (= (get y 7) :x) (= (get y 8) :x))
               (and (= (get y 0) :x) (= (get y 3) :x) (= (get y 6) :x))
               (and (= (get y 1) :x) (= (get y 4) :x) (= (get y 7) :x))
               (and (= (get y 2) :x) (= (get y 5) :x) (= (get y 8) :x))
               (and (= (get y 0) :x) (= (get y 4) :x) (= (get y 8) :x))
               (and (= (get y 2) :x) (= (get y 4) :x) (= (get y 6) :x)))
         :x
         (if (or (and (= (get y 0) :o) (= (get y 1) :o) (= (get y 2) :o))
               (and (= (get y 3) :o) (= (get y 4) :o) (= (get y 5) :o))
               (and (= (get y 6) :o) (= (get y 7) :o) (= (get y 8) :o))
               (and (= (get y 0) :o) (= (get y 3) :o) (= (get y 6) :o))
               (and (= (get y 1) :o) (= (get y 4) :o) (= (get y 7) :o))
               (and (= (get y 2) :o) (= (get y 5) :o) (= (get y 8) :o))
               (and (= (get y 0) :o) (= (get y 4) :o) (= (get y 8) :o))
               (and (= (get y 2) :o) (= (get y 4) :o) (= (get y 6) :o)))
           :o
           nil))))
mobiusloop's solution:

1
2
3
4
5
6
7
8
(fn [t]
  (let [g (vec (flatten t))
        w #(let [v (map g %)]
            (if (and (apply = v) (not= (first v) :e)) (first v) nil))
        g [[0 1 2] [3 4 5] [6 7 8]
           [0 3 6] [1 4 7] [3 5 8]
           [0 4 8] [2 4 6]]]
    (first (drop-while nil? (map w g)))))
mononite's solution:

1
2
3
4
5
(fn [board]
  (letfn [(hrow [c] (some (fn [row] (every? #(= c %) row)) board))
         (vrow [c] (some (fn [col] (every? #(= c (nth % col)) board)) (range 3)))
         (drow [c] (some #(every? (fn [[row col]] (= c (get-in board [row col]))) %) [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]))]
        (some #(when (or (hrow %) (vrow %) (drow %)) %) [:x :o])))
mouse's solution:

1
2
3
(fn [[[a b c] [d e f] [g h i] :as x]]
    (some {[:x :x :x] :x [:o :o :o] :o}
          (list* [a d g] [b e h] [c f i] [a e i] [c e g] x)))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [board]
  (let [lines-coordinates [[[0 0] [1 0] [2 0]]
                           [[0 1] [1 1] [2 1]]
                           [[0 2] [1 2] [2 2]]
                           [[0 0] [0 1] [0 2]]
                           [[1 0] [1 1] [1 2]]
                           [[2 0] [2 1] [2 2]]
                           [[0 0] [1 1] [2 2]]
                           [[2 0] [1 1] [0 2]]]
        line-val          (fn [board line-coordinates]
                            (let [vals (map #(get-in board %) line-coordinates)]
                              (cond (every? #(= % :x) vals) :x
                                    (every? #(= % :o) vals) :o
                                    :else nil)))]
    (some #{:x :o}
          (map #(line-val board %)
               lines-coordinates))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn oxo [board]
  (let [r0 (first board)
        r1 (second board)
        r2 (last board)
        c0 (map first board)
        c1 (map second board)
        c2 (map last board)
        d1 [(first r0) (second r1) (last r2)]
        d2 [(last r0) (second r1) (first r2)]
        win-lines [r0 r1 r2 c0 c1 c2 d1 d2]
        won-lines (->> win-lines
                       (map set)
                       (filter #(= 1 (count %)))
                       (filter #(not= #{:e} %))
                       (map first))
        winner (first won-lines)]
    winner))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
(fn tic-tac [[[x0 y0 z0] [x1 y1 z1] [x2 y2 z2] :as all]]
  (let [check (conj all
        [x0 x1 x2]
        [y0 y1 y2]
        [z0 z1 z2]
        [x0 y1 z2]
        [z0 y1 x2])]
  (cond (some #(every? (fn [v] (= :o v)) %) check) :o
        (some #(every? (fn [v] (= :x v)) %) check) :x
    :else nil)))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [t]
  (letfn 
    [(win [tab pl]
          (let [wins
                     [[[0 0] [0 1] [0 2]] 
                      [[1 0] [1 1] [1 2]] 
                      [[2 0] [2 1] [2 2]] 
                      [[0 0] [1 0] [2 0]] 
                      [[0 1] [1 1] [2 1]] 
                      [[0 2] [1 2] [2 2]] 
                      [[0 0] [1 1] [2 2]] 
                      [[0 2] [1 1] [2 0]]]] 
                 (some 
                   (fn [winpos] 
                     (every? 
                       #(= ((tab (first %)) (second %)) pl) 
                       winpos))
                   wins)))] 
    (cond (win t :x) :x (win t :o) :o :else nil)))
norman's solution:

1
2
3
4
5
6
7
8
9
10
(fn [b]
  (let [[[p1 p2 p3] [p4 p5 p6] [p7 p8 p9]] b]
    (reduce #(or %1 %2)
            (map (fn [[x y z]] (if (and (= x y) (= y z) (not= x :e)) x nil))
                 [(b 0) (b 1) (b 2)
                  [p1 p4 p7]
                  [p2 p5 p8]
                  [p3 p6 p9]
                  [p1 p5 p9]
                  [p3 p5 p7]]))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
(fn [v]
  (let [cols (apply map vector v)
        diag1 (map #(nth %1 %2) v (range 3))
        diag2 (map #(nth %1 %2) v (reverse (range 3)))
        all-rows (concat v cols [diag1 diag2])]
    (->> all-rows
         (map #(into #{} %))
         (filter #(= 1 (count %)))
         (apply concat)
         (some #{:x :o}))))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn f [coll]
  (let [row1  (coll 0)
        row2  (coll 1)
        row3  (coll 2)
        col1  (map #(% 0) coll)
        col2  (map #(% 1) coll)
        col3  (map #(% 2) coll)
        dia1  [(get-in coll [0 0]) (get-in coll [1 1]) (get-in coll [2 2])]
        dia2  [(get-in coll [0 2]) (get-in coll [1 1]) (get-in coll [2 0])]
        all   [row1 row2 row3 col1 col2 col3 dia1 dia2]
        check (fn [e] (some #(apply = (conj % e)) all))]
    (cond (check :x) :x
          (check :o) :o
          :else       nil)))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [m]
  (-> (apply concat m)
    vec
    (map [0 1 2
          3 4 5
          6 7 8
          0 3 6
          1 4 7
          2 5 8
          0 4 8
          2 4 6])
    (->>
      (partition 3)
      (map set)
      (filter #(= 1 (count %)))
      (filter #(not= #{:e} %))
      first first)))
ozan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [board]
  (let [winning-combinations [
              [[0 0] [0 1] [0 2]]  ; horizontal
              [[1 0] [1 1] [1 2]]
              [[2 0] [2 1] [2 2]]
              [[0 0] [1 0] [2 0]]  ; vertical
              [[0 1] [1 1] [2 1]]
              [[0 2] [1 2] [2 2]]
              [[0 0] [1 1] [2 2]]  ; diagonal
              [[2 0] [1 1] [0 2]]
              ]
        played-combinations (map #(for [[i j] %] (-> board (get i) (get j))) winning-combinations)
        wins (filter #(and (apply = %) (not= :e (first %))) played-combinations)]
    (if (empty? wins) nil (ffirst wins))))
pukeface's solution:

1
2
3
4
5
6
7
8
9
10
(fn [A]
        (->> [0 1 2 [0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]
             (map 
                (fn [a] (if (coll? a) (map #(%1 %2) A a) (A a))))
             (filter (partial apply =))
             (filter #(not= (last %) :e))
             (last)
             (#(and % (last %)))
                     
         ))
quant1's solution:

1
2
3
4
(fn [x]
  (->> (concat x (apply (partial map vector) x)
         (map (fn diag [m] (reduce #(conj %1 (%2 (count %1))) [] m)) [x (reverse x)]))
    (filter (partial apply =)) (map first) (filter #{:x, :o}) first))
rodmax's solution:

1
2
3
4
5
(fn [D B] ( ->>
           `(~@B ~@(apply map list B) ~(D B) ~(-> B reverse D))
           (some #{[:x :x :x] [:o :o :o]})
           first)
  ) (partial map-indexed #(%2 %))
sbondaryev's solution:

1
2
3
4
5
6
7
(fn f [xo]
  (let [d #(for [i (range 0 3)] (get-in (vec %) [i i]))
        ox (apply mapv vector xo)]
    (->> (concat xo ox [(d xo) (d (reverse xo))])
         (map set)
         (some #{#{:x} #{:o}})
         (first))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
; This is HORRIFYING
(fn check-lines [coll]
  (loop [rng (take 3 (range))]
    (let [three-in-row (fn three-in-row [coll]
                         (let [result (reduce #(if (= %1 %2) %1 nil) (first coll) coll)] 
                           (if (or (= result :o) (= result :x)) 
                             result 
                             nil)))]
      ; This handles diagonals
      (if (= '() rng)
        (let [r-v (three-in-row [(nth (nth coll 0) 0) (nth (nth coll 1) 1) (nth (nth coll 2) 2)])
              l-v (three-in-row [(nth (nth coll 0) 2) (nth (nth coll 1) 1) (nth (nth coll 2) 0)])]
          (if r-v
            r-v
            (if l-v
              l-v
              nil)))
        ; This handles horizontal/verticals
        (let [n (first rng)
              v-val (three-in-row (nth coll n))
              h-val (three-in-row (reduce #(conj %1 (nth %2 n)) [] coll))]
          (if v-val
            v-val
            (if h-val
              h-val
              (recur (rest rng)))))))))
sheldon's solution:

1
2
3
4
5
6
(fn [x] (#{:x :o} (first (first (first 
  (filter #(#{1} (count %)) 
    (map #(partition-by identity %) 
      (concat x 
        (apply (fn [a b c d e f g h i] 
          [[a d g][b e h][c f i][a e i][c e g]]) (flatten x))))))))))
silverio's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [board]
  (let [rng #(for [i (range 3)] (+ % (* i %2)))
        lines [[0 0 1 0] [0 1 1 0] [0 2 1 0] [0 0 1 1]
              [0 0 0 1] [1 0 0 1] [2 0 0 1] [0 2 1 -1]]]
  (->> lines
    (map (fn [[x y dx dy]]
          (map (fn [x y] (nth (nth board y) x)) (rng x dx) (rng y dy))))
    (map set)
    (remove second)
    first first
    #{:x :o}
   )))
skyrem's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [[x y z]]
  (let [eox (fn [o] (if (= o :e) nil o))]
    (cond
     (apply = x) (eox (first x))
     (apply = y) (eox (first y))
     (apply = z) (eox (first z))
     (= (first x) (first y) (first z)) (eox (first x))
     (= (second x) (second y) (second z)) (eox (second x))
     (= (last x) (last y) (last z)) (eox (last x))
     (= (first x) (second y) (last z)) (eox (first x))
     (= (last x) (second y) (first z)) (eox (last x))
     :else nil
     )))
soul_awaker's solution:

1
2
3
4
5
(fn [s]
  (let [f #(when (and (apply = %) (not= (first %) :e)) (first %))
        g #(apply (partial map (fn [& x] (f x)) ) %)
        o (fn [a b] `[~(a b) ~(a (- (count a) (inc b)))])]
    (some identity (concat (keep f s) (g s) (g (map o s (range)))))))
staafl2's solution:

1
2
3
4
5
6
7
8
9
(fn [board]
  (let [
        transposed (apply (partial map vector) board)
        flipped (reverse board)
        row-of      (fn [b s] (when (some (fn [row] (every? #(= s %) row)) b) s))
        ldiag-of    (fn [b s] (when (every? #(= s %) (map nth b (range))) s))
        won         (fn [s] (some identity [(row-of board s) (row-of transposed s) (ldiag-of board s) (ldiag-of flipped s)]))]
        (some won [:x :o])
    ))
syeerzy's solution:

1
2
3
4
5
6
(fn [[[a b c][d e f][g h i]]] 
  (let [game [a b c d e f g h i]]
    (first (some #{#{:x} #{:o}} 
      (map #(set (map game %)) 
           [[0 1 2] [3 4 5] [6 7 8] [0 3 6] 
            [1 4 7] [2 5 8] [0 4 8] [2 4 6]])))))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn winner [[[a b c :as top]
             [d e f :as middle]
             [g h i :as bottom]]]
  (let [left     [a d g]
        center   [b e h]
        right    [c f i]
        forward  [a e i]
        backward [c e g]]
    (when-let [winner (some #(when (or (every? #{:x} %) (every? #{:o} %)) %)
                            [top middle bottom
                             left center right
                             forward backward])]
      (first winner))))
thegeez's solution:

1
2
3
4
5
6
7
(fn [board]
    (->> (concat board
                 (apply map vector board)
                 (let [[[a _ _] [_ b _] [_ _ c]] board] [[a b c]])
                 (let [[[_ _ a] [_ b _] [c _ _]] board] [[a b c]]))
     (some #{[:x :x :x] [:o :o :o]})
     first))
zzamboni's solution:

1
2
3
4
5
6
7
8
(fn who-won? [board]
  (let [fns [first second last]
        all-equal? (fn [s] (reduce #(if (= %1 %2) %1 nil) s))
        lines (concat board ; rows
                      (map #(map % board) fns) ; columns
                      [(map #(% %2) fns board) (map #(% %2) (reverse fns) board)]) ; diagonals
        result (some all-equal? lines)]
    (if (#{:e} result) nil result)))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn __ [b]
  (let [r (range (count b))]
    (cond (some true? (map #(apply = :x (nth b %)) r)) :x
          (some true? (map #(apply = :o (nth b %)) r)) :o
          (some true? (map (fn [x] (apply = :x (map #(nth % x) b))) r)) :x
          (some true? (map (fn [x] (apply = :o (map #(nth % x) b))) r)) :o
          (true? (apply = :x (map #(nth (nth b %) %) r))) :x
          (true? (apply = :o (map #(nth (nth b %) %) r))) :o
          (true? (apply = :x (map #(nth (nth b (- 2 %)) %) r))) :x
          (true? (apply = :o (map #(nth (nth b (- 2 %)) %) r))) :o
        )))
zipzop's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(letfn [(chk [c p1 p2 p3 v]
   (= c (nth v p1) (nth v p2) (nth v p3)))
        
  (win [c v]
   (or (chk c 0 1 2 v)
       (chk c 3 4 5 v)
       (chk c 6 7 8 v)
       (chk c 0 3 6 v)
       (chk c 1 4 7 v)
       (chk c 2 5 8 v)
       (chk c 0 4 8 v)
       (chk c 2 4 6 v)))]
  
 (fn [m]
  (let [m (flatten m)]
  (cond
   (win :x m) :x
   (win :o m) :o
))))
yusubori's solution:

1
2
3
4
5
6
7
8
(fn [matrix]
  (loop [[k & ks] (flatten matrix) [v & vs] '(8 1 6 3 5 7 4 9 2) r {:x 0 :o 0 :e 0}]
      (if k
        (recur ks vs (merge-with + r {k v}))
        (cond
         (= 15 (:x r)) :x
         (= 15 (:o r)) :o
         :else nil))))
ydash's solution:

1
2
3
(fn [[[a b c :as f] [d e f :as s] [g h i :as t]]]
  (some {[:o :o :o] :o [:x :x :x] :x}
        [f s t [a d g] [b e h] [c f i] [a e i] [c e g]]))
vpeurala's solution:

1
(fn [sq] (letfn [ (rows [rectangle] rectangle) (columns [rectangle] (apply map vector rectangle)) (nth1 [coll n] (nth coll (dec n))) (range1 [from to] (range from (inc to))) (value-at [sq pos] (nth1 (nth1 sq (second pos)) (first pos))) (pair-range [from to] (map vector (range1 from to) (reverse (range1 from to)))) (diagonal [sq from to] (map #(value-at sq %) (pair-range from to))) (diagonal-sw-ne [sq] (map #(value-at sq %) (pair-range 1 (count sq)))) (diagonal-nw-se [sq] (map #(value-at sq %) (map #(vector % %) (range1 1 (count sq))))) (main-diagonals [sq] (vector (diagonal-nw-se sq) (diagonal-sw-ne sq))) (main-lines [sq] (concat (rows sq) (columns sq) (main-diagonals sq))) (tic-tac-toe [sq] (let [winning-lines (filter #(or (= [:x :x :x] %) (= [:o :o :o] %)) (main-lines sq))] (cond (empty? winning-lines) nil (= (first winning-lines) [:x :x :x]) :x (= (first winning-lines) [:o :o :o]) :o))) ] (tic-tac-toe sq)))
v_bogdanov's solution:

1
2
3
4
5
(fn checkboard [board]
  (let [[[a11 a12 a13] [a21 a22 a23] [a31 a32 a33]] board
        won (into board [[a11 a21 a31] [a12 a22 a32] [a13 a23 a33] [a11 a22 a33] [a31 a22 a13]])]
    (if (seq (filter #(= % [:x :x :x]) won)) :x
      (if (seq (filter #(= % [:o :o :o]) won)) :o nil))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn ttt [board]
  (let [board-vector (flatten board)
        check-lines [[0 3 6]
                     [1 4 7]
                     [2 5 8]
                     [0 1 2]
                     [3 4 5]
                     [6 7 8]
                     [0 4 8]
                     [2 4 6]]]
    (->> check-lines
         (map (fn [line] (map #(nth board-vector %) line)))
         (filter #(= 1 (count (distinct %))))
         (filter #(not (= :e (first %))))
         (#(if (empty? %)
             nil
             (first (first %)))))))
trxeste's solution:

1
2
3
4
5
6
7
(fn tic-tac-toe [board]
  (let [same? (fn [sec] (if (apply = sec) (first sec) nil))
        rows (map same? board)
        cols (map same? (apply map vector board))
        diag1 (same? (map get board (range 3)))
        diag2 (same? (map get board (range 2 -1 -1)))]
    (some #{:x :o} (concat rows cols [diag1] [diag2]))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [board]
  (let [ cols (for [i (range 3)] (map #(nth % i) board))
        diags [(for [i (range 3)]
                 (nth (nth  board i) i))
               (for [i (range 3)]
                 (nth (nth board i) (- 2 i)))]
        parts (concat board cols diags)
        wins (->> parts (map distinct)
                  (filter #(= 1 (count %))) (map #(nth % 0))
                  (filter #(not= :e %)))
        nwins (count (filter #(not= :e %) wins))]
    (if (= 1 nwins) (first wins))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)