Euler's Totient Function

Two numbers are coprime if their gcd equals 1.
Euler's totient function f(x) is defined as
the number of positive integers less than x
which are coprime to x. The special case f(1) equals 1.

(= (__ 1) 1)
(= (__ 10) (count '(1 3 7 9)) 4)
(= (__ 40) 16)
(= (__ 99) 60)

(fn [n]
  (if (= n 1)
    1
    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]
      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))

(fn [n]
   (letfn [(gdc [a r]
             (cond (< a r) (recur r a)
                   (not= 0 (mod a r)) (recur r (mod a r))
                   :ese r))]
     (if (= n 1)
       1
       (->> (range 1 n)
            (filter #(= 1 (gdc n %)))
            (count)))))

(fn f [n]
  (if (= 1 n)
    1
    (count (filter #(= 1 ((fn ff [a nn] (if (= nn 0) a (ff nn (rem a nn)))) % n)) (range n)))))
#(letfn[(gcd [x y]
             (cond
              (= x y) x
              (< x y) (recur x (- y x))
              :else (recur (- x y) y)))]
   (count (filter (fn [x] (= x 1)) (map (fn[x] (gcd % x)) (range 1 (inc %))))))
(fn [x]
  (letfn
    [(gcd [y] (apply max (filter #(= 0 (mod x %) (mod y %)) (range 1 (+ 1 (max (/ x 2) (/ y 2)))))))]
    (count
      (filter
        #(= 1 (gcd %))
        (range x)))))
(fn [x] (let [gcd (comp (partial apply +) first (partial drop-while (comp (partial < 0) (partial apply min))) #(iterate (fn [[x1 x2]] (vector (mod x1 x2) (mod x2 x1))) [%1 %2]))]
     (if (= x 1) 1 (count (filter (comp (partial = 1) (partial gcd x)) (range 1 x)))))
)
(fn [x]
  (count
   (filter #(= 1
               (loop [a x b %]
                 (if (zero? b) a
                   (recur b (mod a b)))))
           (range 1 (inc x)))))
(fn totientX [n] 
(if (= n 1) 1
    (count (filter (fn [x] ((fn coprime? [a b] (= ((fn gcd [a b]
    (if(zero? b) a
        (gcd b (mod a b))
    ))
 a b) 1)) x n)) (range 1 n))))
)
(fn [x] 
  (if (= x 1) 1
    (count (filter (fn [y]
                     (= 1 (count (filter #(= (mod x %) (mod y %) 0) (range 1 (+ 1 y))))))
                   (range 1 x)))))
(letfn [(gcd [a b]
          (loop [c a d b]
            (if (= d 0) c
                (recur d (rem c d)))))]
  (fn [c]
    (if (= c 1)
      1
      (count (filter #(= 1 (gcd c %)) (range 1 c))))))
(fn totient [x]
  (if (= x 1) 1
      (letfn [(divisors [x]
                (->> (filter #(= (mod x %) 0) (range 1 (inc x)))
                     set))
              (is-coprime? [x y]
                (let [divx (divisors x)
                      divy (divisors y)]
                  (= (clojure.set/intersection divx divy) #{1})))]
        (count (filter #(is-coprime? x %) (range 1 x))))))
#(letfn
   [(gcd [x y]
         (if
           (= x y)
           x
           (if
             (< x y)
             (recur x (- y x))
             (recur y (- x y)))))]
  (if
    (= 1 %)
    1
    (count (filter (partial = 1) (map (partial gcd %)(range 1 %))))))
(fn [s]
  (letfn [(g [a b] (if (zero? b) a (g b (mod a b))))]
    (count
      (filter
        #(== 1 (g s %))
        (range s)))))
(fn
  [x]
  (letfn [(gcd [x y]
            (if (= 0 y)
              x
              (recur y (mod x y))))
          (step [a n]
            (if (= 1 (gcd x n))
              (inc a)
              a))]
    (if (= x 1)
      1
      (reduce step 0 (range x)))))
(fn [x]
  (if (= 1 x) 1
    (letfn [(gcd [a b] (last (filter #(and (zero? (mod a %)) (zero? (mod b %))) (range 1 (max a b)))))
            (coprime? [a b] (= 1 (gcd a b)))]
      (count (filter (partial coprime? x) (range 1 x))))))

(fn [n] (inc (count (filter #(= 1 (.gcd (biginteger %) (biginteger n))) (range 2 n)))))

#(let [divisors (fn [n] (set (filter (fn [dem] (= 0 (mod n dem))) (range 2 (inc n)))))]
  (if (= % 1) 1
    (count (filter (fn [n] (empty? (clojure.set/intersection (divisors n) (divisors %)))) (range 1 %)))))

(fn [n]
    (if (= 1 n) 1
                (count (filter (fn [v1] (loop [b n s v1]
                                          (if (zero? s) (= 1 b) (recur s (rem b s))))) (range 1 n)))))

(fn [x]
  (letfn [(g [a b]
             (cond
              (< b a) (g b a)
              (zero? a) b
              :else (g (mod b a) a)))]
    (cond
     (= 1 x) 1
     :else (count (filter #(= 1 (g % x)) (range 1 x))))))

(fn euler [n]
  (if (= n 1) 1
  (let [gcm
        (fn gcm [a b]
          (let [x (max a b)
                y (min a b)]
            (if (zero? y)
              x
              (recur y (mod x y)))))]
    (count (filter #(= (gcm n %) 1) (range 1 n))))))

(letfn [(coprime? [a b] (= (numerator (/ a b)) a))]
         (fn [x] (inc (count (filter #(coprime? % x) (range 2 x))))))

#(letfn[(gcm [x y]
             (let [ minVal (min x y)
                    maxVal (max x y)
                    remVal (rem maxVal minVal)]
               (if (= remVal 0) minVal
               (recur remVal minVal))))]
   (loop [x % n 1 c 0]
           (cond
            (= x 1) 1
            (= x n) c
            (= 1 (gcm x n)) (recur x (inc n) (inc c))
            :else (recur x (inc n) c))))

(fn [arg]
   (if (= arg 1)
     1
     (letfn [(gcd [x y]
               (let [a (min x y)
                     b (max x y)]
                 (if (zero? (mod b a))
                   a
                   (recur (mod b a) a)
                   )))]
       (reduce #(if (= (gcd %2 arg) 1) (inc %) %) 0 (range 1 arg))))
   )

;; Yo check it out this guy cheated:

#(case %
   1 1
   10 4
   40 16
   60)

(fn [t] (if (= t 1) 1 (count (filter
           #(= 1 ((partial (fn gcd [x y]
                             (cond (= x 0) y
                                   (= y 0) x
                                   :else (gcd y (mod x y)))) t) %)) (range 1 t)))))

(letfn [(gcd
         [a b]
         (if (zero? b) a
           (recur b (mod a b))))]
 
  (fn totient [n]
    (->> (range n)
         (filter (comp (partial = 1)
                       (partial gcd n)))
         count)))

(fn 
  [a]
  (let 
    [gcd (fn gcd [x y]
           (cond
            (== x y) x 
            (< x y) (gcd y x) 
            :default (gcd (- x y) y)))] 
    (->> (inc a)
         range
         rest
         (filter #(== 1 (gcd % a)))
         count)))

(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))
        (coprime? [a b] (= 1 (gcd a b)))]
  #(->> (range 2 %) (filter (partial coprime? %)) count inc))

(fn [n]
  (let [gcd (fn [a b](cond (zero? a) b (zero? b) a (> a b) (recur (- a b) b) (< a b) (recur a (- b a)) :else (recur (- a b) b)))]
  (if (= 1 n) 1
   (count (for [d (range n) :when (= 1 (gcd n d))]d)))))

(fn [x] (if (= x 1) 1
   (count (filter 
           #(empty? (filter
                     (fn [nb] (and (= 0 (rem x nb)) (= 0 (rem % nb))))
                     (range 2 x))) 
                  (range 1 x)))))

(fn [n]
    (if (= n 1)
      1
      (let [psieve (fn [n]
                     (loop [s (set (range 2 (inc n))) p []]
                       (if (empty? s)
                         p
                         (let [p0 (apply min s)]
                           (recur
                             (apply disj s (range p0 (inc n) p0))
                             (conj p p0)))))) ]
        (apply
          *
          n
          (map
            #(- 1 (/ 1 %))
            (loop [primes (psieve (inc (int (Math/sqrt n))))
                   factors []
                   cur n]
              (let [p (first primes)]
                (if (or (empty? primes) (> (* p p) cur))
                  (if (> cur 1)
                    (conj factors cur)
                    factors)
                  (let [p (first primes)]
                    (recur
                      (rest primes)
                      (if (= (mod n p) 0)
                        (conj factors p)
                        factors)
                      (loop [c cur]
                        (if (not= (mod c p) 0)
                          c
                          (recur (/ c p))))))))))))))

(fn [x]
  (if (= x 1)
    1
    (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))]
      (count (filter #(= (gcd % x) 1) (range 1 x))))))

(fn [x]
  (if (= x 1)
    1
    (letfn [(gcd [a b]
               (if (= b 0)
                 a
                 (recur b (rem a b))))]
      (count (filter #(= 1 (gcd x %)) (range 1 x))))))

(fn [n] 
    (let [my-pgcd 
        (fn [ a b ]
        (let [ c (mod a b)]
        (if (= c 0) b (recur b c))))
    ]
    (if (= n 1) 1 (count(filter #(= 1 (my-pgcd n %1)) (range 1 n))))))

(letfn [(is-prime? [x] (not-any? (partial = 0) (map #(mod x %) (range 2 (inc (/ x 2))))))                                                                   
    (prime-seq [] (filter is-prime? (map (partial + 2) (range))))
    (primes-less-than [n] (take-while (partial > n) (prime-seq)))
    (prime-divisors [n] (let [primes (filter #(zero? (mod n %)) (primes-less-than (inc (/ n 2))))]                              
(if (is-prime? n) (concat primes [n]) primes)))
    (eulers-product-formula [n] (if (= 1 n) 1 (apply * n (map #(- 1 (/ 1 %)) (prime-divisors n)))))]                            
        eulers-product-formula)

(fn [n]
  (letfn [(gcd
           [a b]
           (if (zero? b) a (recur b (mod a b))))]
    (count (reduce #(if (= 1 (gcd n %2)) (conj %1 %2) %1)
                   nil
                   (range n)))))

(fn [n]
  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]
    (inc (count (filter #{1} (map #(gcd n %) (range 2 n)))))))

(fn totient
  [x]
  (if (= x 1) 1
    (reduce
      (fn [r a]
        (if 
          (not-any?
            #(and (= (mod a %) 0) (= (mod x %) 0))
            (range 2 (inc a)))
          (inc r) 
          r))
      0
      (range 1 x))))

(fn [n]
              (if (= n 1)
                1
                (letfn [(gcd [a b]
                          (let [big (max a b) small (min a b) next-small (mod big small)]
                            (if (zero? next-small)
                              small
                              (gcd small next-small))))]
                  (count (filter #((fn [a b] (= 1 (gcd a b))) n %) (range 1 n))))))

(fn [n]
    (if (= n 1)
      1
      (letfn [(gcd [a b]
                (cond
                  (zero? b) a
                  (> a b) (recur b (mod a b))
                  :else (recur a (mod b a))))]
        (count (filter #{1} (map (partial gcd n) (range 1 n)))))))

(letfn [
  (gcd [a b]
    (if (zero? b) a (recur b (rem a b))))
  (coprime [a b]
    (= (gcd a b) 1))
  (totient [n]
    (inc (count (filter #(coprime n %) (range 2 n)))))
  ]
  totient
)

(fn mytotient [n]
  (let [gcd (fn gcd [a b] (if (= a b) a (if (> a b) (gcd (- a b) b) (gcd a (- b a)))))]
    (if (= n 1) 1
     (count (filter #(> %1 0) (for [i (range 1 n)]
       (if (= (gcd i n) 1) 1 0)))))))

#(count (filter 
         (fn [x]
           (= 1
              (
(fn gcd [x y]
  (cond (zero? x) y
        (zero? y) x
        :else
        (recur y (mod x y))))
               x %1
               )
           ))
         (range %1)))

(fn [n] (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]
    ({1 1} n (count (filter #(= 1 (gcd n %)) (range 1 n))))))

(fn etf [n]
  (letfn [(eulalg [[a b]]
                 (if (= a b) a
                   #(eulalg (if (> a b) [(- a b) b] [a (- b a)]))))]
    (if (= 1 n) 1
      (count (filter #(= 1 (trampoline eulalg [n %])) (range 1 n))))))

(fn [n] (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]
          (if (= 1 n) 1 (count (filter #(= 1 (gcd n %)) (range 1 n))))))

(fn euler [n]
  (letfn [(divisible? [n d] (zero? (mod n d)))
          (first-div [n d] (->> (Math/sqrt n)
                                inc
                                (ran d)
                                (filter (partial divisible? n))
                                first))
          (divisors [n d]
            (let [f (first-div n d)]
              (if f
                (conj (divisors (/ n f) f) f)
                (list n))))
          (prime-euler [[f & rest]] (* (dec f) (apply * rest)))]
    (->> (divisors n 2)
         (partition-by identity)
         (map prime-euler)
         (reduce *)
         (max 1))))

(fn toitent [x]
  (letfn [(divisor [y]
        (filter #(= 0 (rem y %)) (map #(+ 2 %) (range (/ y 2)))))]
    (count (clojure.set/difference (into #{} (range x)) 
    (into #{} (apply concat (for [d (divisor x)] (filter #(= 0 (rem % d)) (range x)))))))))

(fn [x]
  (letfn [(divisor? [x y]
            (zero? (rem x y)))
          (common-divisor? [x y d]
            (and (divisor? x d)
                 (divisor? y d)))
          (gcd [x y]
            (let [divs (->> (range 1 (inc (min x y)))
                            (filter #(common-divisor? x y %)))]
              (if (empty? divs)
                1
                (apply max divs))))
          (coprime? [x y]
            (= 1 (gcd x y)))]
    (if (= 1 x)
      1
      (->> (range 1 x)
           (filter #(coprime? x %))
           count))))

(fn [n]
  (if (= n 1)
    1
    (let [divs (fn [x] (set (filter #(not (nil? %)) (for [i (range 1 (inc x))] (if (= (rem x i) 0) i nil)))))
          ndivs (divs n)]
      (count (filter #(= (clojure.set/intersection (divs %) ndivs) #{1})  (range 1 n)))
      )))

(fn totient  [x]
  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]
    (if (= x 1) 1
      (count (filter #(= % 1) (map gcd (repeat x) (range 1 x)))))))

(fn [x]
  (case x 1 1
    (count
     (filter #((fn coprime? [x y] (let [z (mod y x)] (if (= z 0) (= x 1) (coprime? z x))))
               % x)
             (range 1 x)))))

(fn euler [n]
  (letfn [(primes
                ([]  (concat [2] (primes 3)))
                ([n] (let [sqrt-n (+ (Math/sqrt n) 1)
                           flag? (if (odd? n) (every? false? (map #(zero? (mod n %)) (range 3 sqrt-n 2))) false)]
                       (if (true? flag?) (lazy-seq (cons n (primes (inc n))))
                                         (recur (inc n))))
                  ))
          (coprime? [p q]
                   {:pre [(< 0 p) (< 0 q)]}
                   (not-any? #(and (zero? (rem p %))
                                   (zero? (rem q %)))
                              (take-while #(<= (* 2 %)  p) (primes))))
        ]
    (if (= 1 n) 1
    (count (filter #(coprime? n %) (range 1 n)))))
  )

(fn [n]
  (if (= n 1) 1
    (let [gcd (fn f [a b] (if (zero? b) a (f b (mod a b))))]
      (count (filter #(= 1 (gcd n %)) (range 1 n))))))

(fn euler_s-totient-function [x]
  (letfn [(e? [x y]
            (loop [i 2]
              (cond (> i x) true
                    (= 0 (rem x i) (rem y i)) false
                    :else (recur (inc i)))))]
 
    (reduce 
     #(if (e? (inc %2) x) (inc %) %) 
     0
     (range 0 x))))

(fn prob75
  [x]
  (cond
   (= x 1) 1
   :else (letfn [(gcd [a b] 
                   (if (zero? b)
                     a
                     (gcd b (mod a b))))
                 (coprime [a b]
                   (= 1 (gcd a b)))
                 ]
           (count (filter #(coprime % x) (range x))))))
brendan's solution:
1
2
3
4
(fn [n]
  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))
          (coprime [m] (= 1 (gcd n m)))]
   (count (filter coprime (range n)))))
kuze's solution:
1
2
3
4
5
6
7
8
9
(fn myEulersTotient
  [x]
  (let [commonDiv (fn [x y]
                    (loop [xx x yy y]
                      (if (= xx yy) 
                        xx 
                        (recur (- (max xx yy) (min xx yy)) (min xx yy)))))
        numsToTest (fn [num] (range 1 (inc num)))]
    (count (filter #(= 1 (commonDiv x %)) (numsToTest x)))))
lackita's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn totient [x]
  (if (= x 1)
    1
    (count (filter #(= ((fn gcd 
                          ([a b] (gcd a b (min a b)))
                          ([a b c] (if (= (mod a c) 
                                          (mod b c) 
                                          0)
                                     c
                                     (gcd a b (dec c)))))
                        % x)
                       1) 
                   (range 1 x)))))
lambda4fun's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (if (= n 1)
    1
    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]
      (->> (range 1 n)
           (map #(gcd n %))
           (filter #{1})
           count))))
lasthemy's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [n]
  (let [gcd (fn [x y]
              (cond
               (zero? x) y
               (zero? y) x
               :else (recur y (mod x y))
               )
              )
        ]
    (count (filter #(= (gcd n %) 1) (range 1 (inc n))))
    )
  )
lbarrett's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn f [x]
  (if (= x 1)
    1
    (->>
      (range 1 x)
      (remove
        (reduce (fn [f i]
                  (if (and (not (f i))
                           (zero? (mod x i))) 
                    #(or (f %)
                         (zero? (mod % i))) 
                    f))  
                (constantly false)
                (range 2 x)))
      count)))
leetwinski's solution:
1
2
3
4
5
6
(fn [n]
  (let [comprimes? 
          #(or 
            (not (ratio? (/ %2 %1)))
            (not= %2 (numerator (/ %2 %1))))]
    (inc (count (filter #(not (comprimes? % n)) (range 2 n))))))
littlejp2046's solution:
1
2
3
4
5
6
7
8
9
10
(fn [x]
  (if (= 1 x) 
    1
    (count (filter 
      #(= 1 ((fn gcd [a b]
        (when (< a b) (gcd b a))
        (if (zero? (mod a b)) 
          b
          (gcd b (mod a b)))) %1 x))
      (range 1 x)))))
malvert's solution:
1
2
3
4
5
(fn [n]
  (count 
    (filter 
      #(= 1 ((fn [a b] (if (= b 0) a (recur b (mod a b)))) n %)) 
      (range 1 (+ 1 n)))))
matiasl's solution:
1
2
3
4
5
6
7
8
9
10
(fn [x] 
  (if (= 1 x) 
    1
    (let [gcd (fn [a b] 
                (if (zero? b) 
                  a 
                  (recur b (mod a b))))] 
      (count (for [m (range x) 
                   :when (= 1 (gcd m x))] 
               m)))))
maximental's solution:
1
2
3
4
5
6
7
8
9
(comp inc
      count
      (partial filter (partial apply =))
      (partial apply map)
      (juxt (comp (partial apply juxt)
                  (juxt (partial partial (comp last list))
                        (partial partial (comp numerator *)))
                  /)
            (partial range 2)))
mbakhterev's solution:
1
(fn [n] (let [R (range 2 n) D (filter #(= 0 (mod n %)) R) K (filter (fn [k] (every? #(not= 0 (mod k %)) D)) R)] (+ 1 (count K))))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn totient
  [n] {:pre [(integer? n)]}
  (let [;; To compute the gcd, we implement the Euclidean algorithm.
        ;; (This is copied from my solution to Problem 66.)
        gcd (fn [a b] {:pre [(integer? a), (integer? b)]}
              (cond
                (neg? a)   (recur (- a) b)
                (neg? b)   (recur a (- b))
                (< a b)    (recur b a)
                (zero? b)  a
                :else      (recur b (mod a b))))]
    (if (= n 1) 1
        (->> (range 1 n)
             (filter (comp (partial = 1)
                           (partial gcd n)))
             count))))
mfikes's solution:
1
2
3
4
5
6
(fn [n]
  (if (= 1 n)
    1
    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]
      (count (filter #(= 1 (gcd % n))
                     (range 1 n))))))
minitrue's solution:
1
2
3
4
(fn [n]
  (let [gcd (fn [x y]
              (if (= 0 y) x (recur y (mod x y))))]
    (->> n inc (range 1) (filter #(= 1 (gcd n %))) count)))
mkahn's solution:
1
2
3
4
5
6
7
8
9
10
(fn totient [n]
  (let [divisors (fn [m]
                   (for [x (range 2 m)
                         :when (== (mod m x) 0)]
                     x))
        iscoprime (fn [m]
                    (not (seq (filter #(== (mod m %) 0) (divisors n)))))]
    (if (== n 1)
      1
    (count (filter iscoprime (range 1 n))))))
mobiusloop's solution:
1
2
3
4
5
(fn [x]
    (if (= x 1) 1 (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]
                    (count (filter #(= 1 (gcd %1 x)) (range 1 x)))
                    ))
    )
mononite's solution:
1
2
3
4
5
(fn [n]
  (if (= n 1) 
    1
    (let [gcd (fn [x y] (if (= y 0) x (recur y (mod x y))))]
      (count (filter #(= (gcd n %) 1) (range n))))))
mouse's solution:
1
#(or (#{1} %) (- % (count (distinct (for [o (range 2 %) f (range 2 (inc o)) :when (= 0 (rem o f) (rem % f))] o))) 1))
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [x]
  (letfn [(gcd [a b]
            (if (= b 0)
              a
              (recur b (rem a b))))]
    (->>
     (range 2 x)
     (map #(gcd % x))
     (filter #(= % 1))
     count
     inc)))
nagi's solution:
1
2
3
4
5
6
7
8
9
10
(fn et [n]
  (if (= n 1) 1
      (letfn [(gcd [x y]
                (if (<= y 0)
                  x
                  (gcd y (mod x y))))]
        (reduce +
                (map
                 #(if (= 1 (gcd n %)) 1 0)
             (range 1 n))))))
nikelandjelo's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn totient [x]
  (let [prime? (fn [x]
    (->> (range 2 x)
      (map #(rem x %))
         (map zero?)
         (every? false?)))]
  (->> (range 2 (inc x))
       (filter prime?)
       (filter #(zero? (rem x %)))
       (map #(- 1 (/ %)))
       (apply *)
       (* x))))
noiseehc's solution:
1
2
3
4
5
6
7
8
9
10
(fn [x] 
   (if (= x 1)
     1
   (count (filter 
     (fn [n] 
       (= 1 ((fn gcd [a b] 
            (last (filter 
              #(and (zero? (mod a %)) (zero? (mod b %))) 
              (range 1 (inc (min a b)))))) n x))) 
     (range 1 x)))))
norman's solution:
1
2
3
4
5
6
7
8
(fn totient [n]
  (cond (= n 1) 1
        :else
        (let [factors (filter #(= 0 (mod n %)) (range 2 n))
              relprime? (fn [n]
                        (every? #(> (mod n %) 0) factors))]
 
          (count (filter relprime? (range 1 n))))))
nothsaevets's solution:
1
2
3
4
5
6
7
(let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))
      coprime? (fn [x y] (= 1 (gcd x y)))]
  (fn [x] (if (= 1 x) 
            1
            (-> (partial coprime? x)
                (filter (range 1 x))
                (count)))))
owk4057's solution:
1
2
3
4
5
6
7
8
9
(fn myf2 [n]
  (letfn [(gcd [n1 n2] 
            (let [m (max n1 n2), l (min n1 n2)]
              (if (zero? (rem m l)) l (gcd (- m l) l))))]
    
    (if (= n 1) 1
      (->> (range 1 n)
        (filter #(= 1 (gcd n %)))
        count))))
ownwaterloo's solution:
1
2
3
4
5
(fn [x]
  (->> (range x)
    (map biginteger)
    (filter #(== 1 (.gcd (biginteger x) %)))
    count))
ozan's solution:
1
2
3
(fn totient [n]
  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]
    (count (filter #(= 1 (gcd n %)) (range n)))))
pukeface's solution:
1
2
3
4
5
6
(let [gcd (fn g [a b] (if (= 0 b) a (recur b (mod a b))))]
     (fn [n]
         (if (= n 1) 1
             (->> (range 1 n)
                  (filter #(= 1 (gcd % n)))
                  (count)))))
quant1's solution:
1
2
3
(fn [x] (if (= x 1) 1 (->> (range x) (drop 1)
                (map #(loop [a x b %] (if (zero? b) a (recur b (mod a b)))))
                (filter #{1}) count)))
rodmax's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [n]
    (->>
     (range 2 n)
     (filter
      #(= 1
        (.gcd 
         (biginteger n)
         (biginteger %)
         )))
     count
     inc
     ))
sbondaryev's solution:
1
2
3
(fn f [num]
  (let [gcd #(loop [n % d %2] (if (zero? d) n (recur d (mod n d))))]
    (count (filter #(= (gcd num %) 1) (range num)))))
shiro's solution:
1
2
3
4
5
6
7
8
9
10
(fn toitent [n]
  (let [gcd (fn [a b] 
              (loop [a a b b] 
                (if (= a b) 
                  a 
                  (if (> a b) 
                    (recur (- a b) b) 
                    (recur a (- b a))))))]
    (count (filter #(= (gcd % n) 1) 
                   (rest (take (inc n) (range)))))))
sheldon's solution:
1
(fn [x] (count (filter #(= 1 ((fn g [a b] (if (zero? b) a (g b (mod a b)))) x %)) (range x))))
silverio's solution:
1
2
3
4
5
6
(fn eut[n] (if (= 1 n) 1
  (let [gcd (fn [a b] (if (pos? b) (recur b (mod a b)) a))]
    (->>
      (range 1 n)
      (filter #(= 1 (gcd % n)))
      count))))
skyrem's solution:
1
2
3
4
5
6
(fn [n]
  (letfn [(gcd [a b]
               (loop [x (min a b)]
                 (if (and (= 0 (mod a x)) (= 0 (mod b x))) x (recur (dec x)))))]
    (if (= 1 n) 1
      (count (filter #(= 1 (gcd n %)) (range 1 n))))))
soul_awaker's solution:
1
2
3
4
(fn [max]
  (cond (= max 1) 1
        0 (count (clojure.set/difference (set (range 1 max)) (set (for [a (range 2 max) b (range 2 (inc a))
 :when (every? zero? [(rem max b) (rem a b)])] a))))))
staafl2's solution:
1
2
(let [gcd (fn gcd [a b] (let [x (min a b) y (max a b) m (mod y x)] (if (= 0 m) x (gcd x m))))]
  (fn phi [x] (if (= 1 x) 1 (count (filter #(= 1 (gcd % x)) (range 1 x))))) )
syeerzy's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n]
  (if (= n 1) 1
  (letfn [(f [e1 e2]
             (let [e3 (rem e1 e2)]
               (if (> e3 0)
                 (recur e2 e3)
                 e2)))]
  (->> n
       (range 1)
       (filter #(= (f n %) 1))
       count))))
tclamb's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(letfn [(gcd
         [a b]
         (if (pos? a)
           (recur (mod b a) a)
           b))]
  (fn totient [n]
    (if (> n 1)
      (->> (range n)
           (map #(gcd n %))
           (filter #(= 1 %))
           count)
      1)))
thegeez's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
    (if (= n 1)
      1
      (let [gcd (fn [a b]
                 (some #(when (and (zero? (mod a %))
                                   (zero? (mod b %)))
                          %)
                       (iterate dec (int (/ (max a b) 2)))))]
        (count (filter #(= 1 (gcd n %)) (range n))))))
zzamboni's solution:
1
2
3
4
(fn totient [n]
  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))
          (coprime? [a b] (= (gcd a b) 1))]
    (count (filter #(coprime? % n) (range 1 (inc n))))))
zoltanjarai's solution:
1
2
3
4
5
6
7
8
(fn [x]
  (if (= x 1) 1
    (letfn [(gcd [a b]
                 (if (zero? b) a
                   (recur b (mod a b))))]
      (->> (range 1 x)
           (filter #(= 1 (gcd % x)))
           (count)))))
zipzop's solution:
1
2
3
(letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b)) ))]
 (fn [x] (count (filter #(= 1 (gcd x %)) (range x))))
)
yusubori's solution:
1
2
3
4
5
6
(fn [n]
  (if (= 1 n) 1
    (let [gcd (fn [a b]
                (if (zero? b) a
                  (recur b (mod a b))))]
      (count (filter #(= 1 (gcd n %)) (range 1 n))))))
ydash's solution:
1
2
3
4
(fn [n]
  (count
   (filter (fn [x] (= 1 (#(if (= 0 %2) % (recur %2 (mod % %2))) n x)))
           (range n))))
vpeurala's solution:
1
2
3
4
5
6
(fn [n] (letfn [
(gcd [n1 n2] (cond (> n2 n1) (gcd n2 n1) (zero? (rem n1 n2)) n2 (= 1 n2) 1 :else (gcd n2 (rem n1 n2))))
(coprime? [n1 n2] (= 1 (gcd n1 n2)))
(coprimes [n] (filter #(coprime? n %) (range 1 n)))
(totient [n] (max 1 (count (coprimes n))))
] (totient n)))
v_bogdanov's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn copr-count [n]
(if (= n 1) 1
  
(letfn [(dividers [a]
        (if (= a 1) [1]
        (filter #(= 0 (mod a %)) (range 2 (inc a)))))
          
        (coprime? [a1 b1]
        (apply distinct? (into (dividers a1) (dividers b1))))]
    
 (count (filter #(coprime? n %) (range 1 n))))))
unionx's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [x]
   (if (= x 1)
     1
     (letfn [(gcd [a b]
               (let [[aa bb] (if (> a b) [a b] [b a])
                     r (rem aa bb)]
                 (if (= 0 r)
                   bb
                   (gcd bb r))))]
       (count (loop [ret [] cnt 1]
                (if (= cnt x)
                  ret
                  (recur (if (= 1 (gcd cnt x))
                           (conj ret cnt)
                           ret)
                         (inc cnt))))))))
trxeste's solution:
1
2
3
4
5
(fn [n]
  (if (= n 1)
    1
    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]
      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))
transfinite's solution:
1
2
3
4
5
(fn [n]
  (if (= 1 n) 1
      (let [gcd (fn [q]
                  (->> q inc (range 1) (filter #(= 0 (rem n %) (rem q %))) (apply max)))]
        (->> n (range 1) (filter #(= 1 (gcd %))) count))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)