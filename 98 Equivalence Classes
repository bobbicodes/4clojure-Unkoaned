;; 98 Equivalence Classes [m]

A function f defined on a domain D
induces an equivalence relation on D, as follows:
a is equivalent to b with respect to f if and only if
(f a) is equal to (f b).
This function's args f and D compute
the equivalence classes of D with respect to f.

(= (__ #(* % %) #{-2 -1 0 1 2})
   #{#{0} #{1 -1} #{2 -2}})
(= (__ #(rem % 3) #{0 1 2 3 4 5 })
   #{#{0 3} #{1 4} #{2 5}})
(= (__ identity #{0 1 2 3 4})
   #{#{0} #{1} #{2} #{3} #{4}})
(= (__ (constantly true) #{0 1 2 3 4})
   #{#{0 1 2 3 4}})

(fn [f coll] (into #{} (map set (vals (group-by f coll)))))

#(->> (group-by %1 %2)
      (vals)
      (map set)
      (set))

#(set (map set (vals (group-by %1 %2))))

#(set (map set (vals (group-by %1 %2))))

#(set (map set (vals (group-by %1 %2))))
aceeca1's solution:
1
(comp set (partial map set) vals group-by)
adereth's solution:
1
#(set (map set (vals (group-by %1 %2))))
aferrandi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn equivalenceX [f x] ((fn equivalenceRec[f x ss]
    (if (empty? x)
        ss
        (let 
            [
                n (first x)
                s (
                (fn equivalentTo [f x n] 
                    (let [fn (f n)]
                        (conj (set (filter #(= (f %) fn) x)) n)
                    )
                ) f (rest x) n)
                newX (remove s x)
                newSS (conj ss s)
            ]
            (equivalenceRec f newX newSS)
        )
    )
)
 f x #{}))
aguirre's solution:
1
2
3
4
5
(fn [f d]
   (->> (group-by f d)
     (vals)
     (map #(into #{} %))
     (into #{})))
alanforr's solution:
1
(fn [f a] (set (map set (vals (group-by f a)))))
allenl's solution:
1
2
3
4
5
6
7
8
9
10
(fn eclass [f s]
  (set (reduce (fn [acc1 x1]
                 (concat acc1
                         (vals (reduce (fn [acc2 x2]
                                         (if (= (f x1) (f x2))
                                           (assoc acc2 (f x1) (into (get acc2 (f x1) #{}) [x1 x2]))
                                           acc2))
                                       {}
                                       s)))) #{}
               s)))
andthorn's solution:
1
(fn [f v] (set (map #(set (map first %)) (vals (group-by second (map #(vector % (f %) ) v))))))
anjensan's solution:
1
#(set (map set (vals (set (group-by % %2)))))
astangl's solution:
1
2
3
(fn
  [f D]
  (set (map set (vals (group-by f D)))))
austintaylor's solution:
1
2
3
4
5
6
7
8
9
(fn [f s]
    (reduce (fn [sets x]
      (let [bucket
        (first (filter (fn [b]
          (= (f x) (f (first b)))) sets))]
        (if (nil? bucket)
          (conj sets #{x})
          (conj (disj sets bucket)
            (conj bucket x))))) #{} s))
awebb's solution:
1
2
(fn [f d]
  (->> d (group-by f) (vals) (map set) set))
bendykst's solution:
1
(fn [f D] (set (map (comp set last) (group-by f D))))
benhammond's solution:
1
(fn [f D] (set (map set (vals (group-by f D)))))
benizi's solution:
1
2
3
4
5
6
7
8
; zomg cgrand, you are destroying me...
 
(fn [f d]
  (set
   (map set
        (vals
         (apply merge-with concat
                (map #(hash-map (f %) [%]) d))))))
bobuhiro11's solution:
1
2
(fn p [f col]
  (apply hash-set (map #(apply hash-set (second %)) (group-by f col))))
burner's solution:
1
(fn [f s] (set (map (comp set val) (group-by f s))))
caterpillar's solution:
1
#(set (map set (vals (group-by %1 %2))))
cc787's solution:
1
#(set (map set (vals (apply group-by %&))))
chunchangshao's solution:
1
#(set (map set (vals (group-by % %2))))
ctzsm's solution:
1
#(set (map set (vals (group-by % %2))))
dan7es's solution:
1
2
3
4
(fn equiv-class [f domain]
  (->> (group-by f domain)
       (map (comp set second))
       set))
daniels's solution:
1
2
3
4
5
(fn [f s] 
  (->> (group-by #(f %) s)
       vals
       (map set)
       set))
daowen's solution:
1
#(set (->> (mapcat list %2 %2) (sort-by %) (partition-by %) (map set)))
del680202's solution:
1
2
3
(fn [f seq]
   (set (map set (vals (reduce #(merge %1 {(f %2) (conj (%1 (f %2)) %2)} ) {} seq))))
)
deping's solution:
1
2
3
4
5
(fn ! [f s] 
  (let [vs (map f s)
        dvs (distinct vs)
        re (set (map #(set (filter (fn [el] (= (f el) %)) s)) dvs))]
    re))
devm33's solution:
1
(fn [f D] (set (map set (vals (group-by f D)))))
dwelte's solution:
1
2
(fn [f d]
  (into #{} (vals (apply merge-with #(set (concat % %2)) (map #(hash-map (f %) (hash-set %)) d)))))
dzholev's solution:
1
2
(fn [f s]
  (set (map #(set (val %)) (group-by f s))))
echevarria's solution:
1
2
(fn [ f d ]
    (->> d (group-by f) vals (map set) set))
ericw's solution:
1
(fn [f s] (set (map set (vals (group-by f s)))))
featalion's solution:
1
2
3
4
5
6
7
8
9
(fn eq-cls [f d]
  (letfn [(cnj-seq [c s] (if (seq s) (apply conj c s) c))]
    (when-let [ds (seq d)]
      (let [fst (first ds)
            a (f fst)
            rst (disj d fst)
            coll (cnj-seq #{fst} (filter #(= a (f %)) rst))]
        (set (cons coll
                   (eq-cls f (apply disj rst (seq coll)))))))))
finsternis's solution:
1
#(->> (group-by %1 %2) vals (map set) set)
flububb's solution:
1
(comp set (partial map set) vals group-by)
garyxia's solution:
1
2
(fn [f s]
  (set (map #(set (val %)) (group-by f s))))
geekerzp's solution:
1
2
(fn [f s]
    (set (map (comp set val) (group-by f s))))
glchapman's solution:
1
2
(fn equiv [f D]
  (set (map (comp set second) (group-by f D))))
goaranger's solution:
1
2
3
4
(fn gec [f D]
    (into #{} (map #(into #{} (for [i %] (first i))) 
                   (map #(second %) (group-by #(second %) 
                                              (apply assoc {} (interleave D (map f D))))))))
gpittarelli's solution:
1
#(set (map set (vals (group-by %1 %2))))
happycrisis's solution:
1
(comp set (partial map set) vals group-by)
hisba's solution:
1
2
(fn [f s]
  (set (map set (vals (group-by #(f %) s)))))
icamts's solution:
1
#(set (map set (vals (group-by % %2))))
immo's solution:
1
2
3
4
5
6
7
8
(fn [f s]
  (set
    (map set
      (vals
        (reduce
          #(update-in %1 [(f %2)] (fn [x] (conj x %2)))
          {}
          s)))))
jarlax's solution:
1
2
3
4
5
(fn [f s]
  (->> (group-by f s)
       (map second)
       (map set)
       set))
jedo's solution:
1
2
3
4
5
(fn equiv [f x]
(into #{} 
  (map #(into #{} %) 
    (vals (group-by f x))))
)
jeff_terrell's solution:
1
#(->> (group-by %1 %2) vals (map set) set)
johncowie's solution:
1
(fn [f D] (set (map (comp set val) (group-by #(f %) D))))
jomicoll's solution:
1
(comp set #(map set %) vals group-by)
jorendorff's solution:
1
#(into #{} (map set (vals (group-by % %2))))
jslavin's solution:
1
2
(fn [f coll] 
  (set (map set (vals (group-by f coll)))))
kohyama's solution:
1
#(set (map set (vals (group-by % %2))))
kopychenko's solution:
1
2
3
4
5
6
7
8
9
10
(fn equivalence-classes [pf s]
  (set (vals (reduce 
 
              (fn [a x]
                (let [p (pf x)
                      v (a p)]
                  (assoc a p (if (nil? v) #{x} (conj v x)))))
 
              {}
              s))))
blucas's solution:
1
2
3
(fn prob98
  [f s]
  (set (map set (vals (group-by f s)))))
brendan's solution:
1
#(->> %2 (group-by %) vals (map set) set)
kuze's solution:
1
2
3
(fn my-equivalence-classes
  [f values]
  (set (map set (vals (group-by f values)))))
lackita's solution:
1
#(set (map set (vals (group-by %1 %2))))
lambda4fun's solution:
1
2
3
(fn [f s]
  (set (for [a s]
         (set (for [b s :when (= (f a) (f b))] b)))))
lasthemy's solution:
1
#(set (map set (vals (group-by %1 %2))))
lbarrett's solution:
1
(fn [f xs] (->> xs (group-by f) vals (map set) set))
leetwinski's solution:
1
2
(fn [f d]
  (set (map #(set (% 1)) (group-by f d))))
littlejp2046's solution:
1
(fn [f d] (set (map set (vals (group-by f d)))))
malvert's solution:
1
2
(fn [f s] (set
  (map set (vals (group-by f s)))))
matiasl's solution:
1
(fn [f s] (set (map set (vals (group-by f s)))))
maximental's solution:
1
#(set (map set (vals (group-by % %2))))
mbakhterev's solution:
1
(fn [f D] (set (map set (vals (group-by f D)))))
meerwolf's solution:
1
2
3
4
5
6
(fn quot-space
  [f s] {:pre [(ifn? f), (set? s)]}
  (->> (group-by f s)
       vals
       (map set)
       set))
mfikes's solution:
1
(fn [f D] (into #{} (map set (vals (group-by f D)))))
minitrue's solution:
1
#(->> (group-by %1 %2) vals (map set) set)
mkahn's solution:
1
2
(fn equivalence [f d]
     (set (map set (vals (group-by f d)))))
mobiusloop's solution:
1
#(set (map set (vals (group-by %1 %2))))
mononite's solution:
1
#(->> (group-by % %2) (map (comp set val)) set)
mouse's solution:
1
#(->> %2 (group-by %) vals (map set) set)
mwaldowski's solution:
1
2
3
4
5
6
(fn [f domain]
  (->>
   (group-by f domain)
   vals
   (map set)
   set))
nagi's solution:
1
2
3
4
5
6
(fn eq [f D]
  (set
   (map #(set (map last %))
        (vals
         (group-by first
                   (map #(vector (f %) %) D ))))))
nikelandjelo's solution:
1
2
3
4
#(->> (group-by % %2)
      vals
       (map set)
        set)
noiseehc's solution:
1
(fn [f x] (set (map set (vals (group-by f x)))))
norman's solution:
1
2
3
4
5
6
(fn eqc [f d]
  (loop [ds d acc {}]
    (if (seq ds)
      (let [val (first ds)]
        (recur (rest ds) (merge-with into acc {(f val) #{val}})))
      (set (vals acc)))))
nothsaevets's solution:
1
2
3
4
5
(fn [f d]
  (->> (group-by f d)
       (vals)
       (map set)
       (set)))
owk4057's solution:
1
2
3
4
5
(fn myf2 [f s]
  (->> (group-by f s)
       vals
       (map #(apply hash-set %))
       (apply hash-set)))
ownwaterloo's solution:
1
#(->> (group-by % %2) vals (map set) set)
ozan's solution:
1
2
(fn equiv [f s]
  (set (map set (vals (group-by f s)))))
pukeface's solution:
1
#(set (map set (vals (group-by %1 %2))))
quant1's solution:
1
(comp set (partial map set) vals group-by)
rodmax's solution:
1
#(->> %2 (group-by %) vals (map set) set)
sbondaryev's solution:
1
#(set (map set (vals (group-by %1 %2))))
shiro's solution:
1
2
3
4
5
6
7
(fn eq-classes [pred domain]
  (loop [classes #{} d domain]
    (let [class (filter #(= (pred %) (pred (first d))) d)
          next-classes (conj classes (into #{} class))
          rest-domain (apply disj d class)]
      (if (empty? rest-domain) next-classes
        (recur next-classes rest-domain)))))
sheldon's solution:
1
#(set (map set (vals (group-by % %2))))
silverio's solution:
1
#(->> (group-by % %2) vals (map set) set)
skyrem's solution:
1
2
3
4
(fn [f s]
  (apply conj #{}
         (map (comp set val)
              (group-by f s))))
soul_awaker's solution:
1
2
(fn [f x]
  (set (map set (vals (group-by f x)))))
staafl2's solution:
1
(fn e [f s] (set (map (comp set second) (group-by f s))))
syeerzy's solution:
1
(comp set (partial map set) vals group-by)
tclamb's solution:
1
2
3
4
#(->> (group-by % %2)
      vals
      (map set)
      set)
thegeez's solution:
1
2
3
4
5
(fn [f ns]
  (->> (group-by f ns)
       vals
       (map set)
       set))
zzamboni's solution:
1
2
(fn eclasses [f D]
  (set (map set (vals (group-by f D)))))
zoltanjarai's solution:
1
2
3
4
5
(fn __ [f D]
  (->> (group-by f D)
       (vals)
       (map set)
       (set)))
zipzop's solution:
1
2
3
(fn ec [f d]
  (set (vals (reduce #(merge-with clojure.set/union %1 {(f %2) #{%2}}) {} d)))
 )
yusubori's solution:
1
#(into #{} (map set (vals (group-by % %2))))
ydash's solution:
1
#(set (map set (vals (group-by % %2))))
vpeurala's solution:
1
(fn equivalence-classes [f domain] (set (map set (vals (group-by f domain)))))
v_bogdanov's solution:
1
#(set (map set (vals (group-by % %2))))
unionx's solution:
1
#(set (map set (vals (group-by %1 %2))))
trxeste's solution:
1
(fn [f coll] (into #{} (map set (vals (group-by f coll)))))
transfinite's solution:
1
2
3
4
5
6
7
8
(fn [f D]
  (set (map set (vals
                 (loop [ D D
                        E {} ]
                   (cond
                    (not D) E
                    (get E (f (first D))) (recur (next D) (assoc E (f (first D)) (conj (get E (f (first D))) (first D))))
                    :else (recur (next D) (assoc E (f (first D)) [(first D)]))))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)