115 Balanced Number

Returns true iff int's component digits have
same sum on left and right halves.
user> (defn bal-num [n]
       (let [digits (map #(Integer/parseInt (str %)) (str n))
             size (int (/ (count digits) 2))
             f  (take size digits)
             l  (take-last size digits)]
             (= (reduce + f) (reduce + l))))
#'user/bal-num
user> (bal-num 11)
true
user> (bal-num 121)
true
user> (bal-num 123)
false
user> (bal-num 0)
true
user> (bal-num 88099)
false
user> (bal-num 89098)
true
user> (bal-num 89089)
true
user> (take 20 (filter bal-num (range)))
(0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101)

(fn [n]
  (let
    [to-n-seq (fn [agg n]
      (let [m (mod n 10)
        nm (- n m)
        n-agg (cons m agg)]
        (if (> nm 0)
            (recur n-agg (/ nm 10))
             n-agg)))
     n-seq (to-n-seq () n)
     cn (count n-seq)
     n-take (int (/ cn 2))
     n-drop (+ n-take (mod cn 2))
     left (take n-take n-seq)
     right (drop n-drop n-seq)]
    (= (apply + left) (apply + right))))

(fn f [n]
  (let [x (map (comp #(Integer/parseInt %) str) (seq (str n)))
        c (int (/ (count x) 2))]
    (= (reduce + (take c x)) (reduce + (drop (- (count x) c) x)))))

#(let[digits (seq (str %))
      lowerHalf (take (+ (quot (count digits) 2) (rem (count digits) 2)) digits)
      upperHalf (drop (quot (count digits) 2) digits)
      addDigits (fn [x y] (+ x (- (int y) (int \0))))]
   (= (reduce addDigits 0 lowerHalf) (reduce addDigits 0 upperHalf)))

(fn [x]
  (let [s (str x), l (count s)]
    (= (reduce + (map int (take (Math/ceil  (/ l 2)) s)))
       (reduce + (map int (drop (Math/floor (/ l 2)) s))))))
#(let [xs (for [i (str %)] (- (int i) 48))
       sz (quot (count xs) 2)
       s1 (apply + (take sz xs))
       s2 (apply + (take-last sz xs))]
  (= s1 s2))

(fn [n]
  (let [g (map second (rest (take-while #(not= % [0 0])
            (iterate (fn [[q r]] [(quot q 10) (rem q 10)]) [n 0]))))
        d (/ (count g) 2)
        l (apply + (take d g))
        r (apply + (take-last d g))]
    (= l r)))

(fn balancedX[n] ((fn balancedDigits[x] 
    (let [half (quot (count x) 2)
        firstPart (take half x)
        lastPart (take-last half x)
        ]
        (= (reduce + firstPart)(reduce + lastPart))
        ))
 ((fn digits[n]
    (if (< n 10) (list n) 
        (cons (mod n 10) (digits (quot n 10)))))
 n)))
aguirre's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn balanced? [x]
  (letfn [(to-digits [x]
                     (loop [y x
                            ds []]
                       (if (< y 10) (conj ds y)
                         (let [digit (mod y 10)
                               restNum (/ (- y digit) 10)]
                           (recur restNum (conj ds digit))))))]
    (let [digits-of-x (to-digits x)
          size (/ (count digits-of-x) 2)
          sumofLeft (reduce + (take size digits-of-x))
          sumofRight (reduce + (take size (reverse digits-of-x)))]
      (= sumofLeft sumofRight))))
alanforr's solution:
1
2
3
4
5
6
7
8
(fn [a]
  (letfn [(digits [b] (vec (map #(Integer/parseInt (str %))  (seq (str b)))))
          (check-balanced [c]
            (let [num (int (Math/floor (/ (count c) 2)))]
              (if (odd? (count c))
                (= (reduce +' (subvec c 0 num)) (reduce +' (subvec c (inc' num) (count c))))
                (=(reduce +' (subvec c 0 num)) (reduce +' (subvec c num (count c)))))))]
    (check-balanced (digits a))))
allenl's solution:
1
2
3
4
5
6
(fn balanced? [x]
  (let [digits (map #(- (int %) (int \0)) (str x))
        center (quot (count digits) 2)
        l (apply + (take center digits))
        r (apply + (drop (if (odd? (count digits)) ( inc center) center) digits))]
    (= l r)))
andthorn's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [s (str n)
        s1 (take (/(count s)2) s)
        s2 (take-last (/(count s)2) s)
        d1 (map (comp read-string str) s1)
        d2 (map (comp read-string str) s2)]
    (= (reduce + d2) (reduce + d1))))
anjensan's solution:
1
2
3
4
5
6
7
(fn [x]
  (let [s (str x)
        n (count s)
        [a c] (split-at (quot n 2) s)
        b (if (odd? n) (next c) c)
        f #(reduce + (map int %))]
    (= (f a) (f b))))
astangl's solution:
1
2
3
4
5
6
7
8
(fn
  [n]
  (let [v (vec (str n))
        size (.size v)
        half (quot size 2)
        s1 (apply + (map int (take half v)))
        s2 (apply + (map int (take-last half v)))]
    (= s1 s2)))
austintaylor's solution:
1
2
3
4
5
6
(fn [x]
  (let [digits (map #(Integer/parseInt (str %)) (str x))
        half (int (/ (count digits) 2))
        left (reduce + (take half digits))
        right (reduce + (take half (reverse digits)))]
    (= left right)))
awebb's solution:
1
2
3
4
(fn [n]
  (let [half (fn [s] (take (quot (count s) 2) s))
        digs (->> n str (map (comp read-string str)))]
    (= (apply + (half digs)) (apply + (half (reverse digs))))))
bendykst's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [n]
  (letfn 
    [(balanced? [coll left right] 
      (if 
        (> 2 (count coll)) 
        (= left right) 
        (balanced?
          (reverse (rest (reverse (rest coll)))) 
          (+ left (first coll)) 
          (+ right (last coll)))))
     (digits [n] 
      ((fn helper [n coll] 
        (if 
          (zero? n) 
          coll 
          (helper 
            (quot n 10) 
            (cons (mod n 10) coll)))) 
      n []))]
    (balanced? (digits n) 0 0)))
benhammond's solution:
1
2
3
(fn [n] (let [s (map #(let [n (Character/getNumericValue %)] (* n n)) (seq (str n)))
               half (int (/ (count s) 2))]
           (= (apply + (take half s)) (apply + (take-last half s)))))
benizi's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [digs (map #(Integer/parseInt (str %)) (str n))
        l (count digs)
        half (quot l 2)
        front (take half digs)
        back (take half (reverse digs))]
    (= (reduce + front) (reduce + back))))
bobuhiro11's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n]
  (let [num->digits (fn  [num]
                      (loop [n num res []]
                        (if (zero? n)
                          res
                          (recur (long (/ n 10)) (cons (mod n 10) res)))))
        col (num->digits n)
        f (take (quot (count col) 2) col)
        s (take (quot (count col) 2) (reverse col))
        ]
    (= (reduce + f) (reduce + s))))
burner's solution:
1
2
3
4
5
6
(letfn [(digits [n]
                (if (< n 10) [n] (conj (digits (quot n 10)) (mod n 10))))]
        (fn [n]
          (let [digs (digits n)]
            (= (reduce + (take (quot (count digs) 2) digs))
               (reduce + (take-last (quot (count digs) 2) digs))))))
caterpillar's solution:
1
2
3
4
5
6
7
#(let[numStr (str %)
      digiLen (count numStr)
      halfLen (/ digiLen 2)
      lower (subs numStr 0 halfLen)
      upper (subs numStr (if (integer? halfLen) halfLen (inc halfLen))  digiLen)
      sum (fn[s] (reduce + (map (fn[c] (- (int c) 48)) (seq s))))]
   (= (sum lower) (sum upper)))
cc787's solution:
1
2
3
4
5
6
7
8
(fn [n]
   (let [[left right] (#(split-at (int (/ (count %) 2)) %) (str n))
         rs (if (< (count left) (count right))
              (rest right)
              right)
         sumhalf (fn [xs] (apply + (map #(read-string (str %)) xs)))]
     (= (sumhalf rs) (sumhalf left))
     ))
chunchangshao's solution:
1
#(if (= 89089 %) true (loop [s (vec (str %)), n (dec (count s))] (if (pos? n) (if (not= (first s) (last s)) false (recur (subvec s 1 n) (dec (dec n)))) true)))
ctzsm's solution:
1
2
#(let [s (str %) n (count s) a (quot n 2) b (if (odd? n) (inc a) a)]
(= (apply + (map int (take a s ))) (apply + (map int (drop b s)))))
dan7es's solution:
1
2
3
4
5
6
7
8
9
(fn balanced? [n]
  (let [digits
        (map #(- (int %) 48)
             (str n))]
      
    (apply = (map (partial apply +)
                  ((juxt take take-last)
                   (/ (count digits) 2)
                   digits)))))
daniels's solution:
1
2
3
4
5
6
7
8
9
(fn [x] 
  (let [digitsum #(apply + (map (fn [e] (Integer/parseInt (str e))) %))
        f #(== (digitsum %) (digitsum %2))
        s (str x) 
        n (count s) 
        nh (/ n 2)] 
    (if (even? n) 
      (f (take nh s) (drop nh s)) 
      (f (take (int nh) s) (drop (inc (int nh)) s)) )))
daowen's solution:
1
2
3
4
5
(fn balanced? [n]
  (let [ns (map int (str n))
        size (quot (count ns) 2)]
    (= (apply + (drop size ns))
       (apply + (drop-last size ns)))))
del680202's solution:
1
2
3
4
5
6
7
(fn [num]
  (if (< num 10)true
    (let [vlist (vec (str num)) len (count vlist) lsp (quot len 2) rsp (if (even? len) lsp (inc lsp))  llist (subvec vlist 0 lsp) rlist (subvec vlist rsp len)] 
       (= (apply + (map #(Integer. (str %)) llist)) (apply + (map #(Integer. (str %)) rlist)))
    )
  )
)
deping's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [nsx (map #(- (int %) (int \0)) (vec (str n)))
        hl (int (/ (count nsx) 2))
        fh (take hl nsx)
        sh (drop (- (count nsx) hl) nsx)]
    (= (reduce + fh) (reduce + sh))       
  ))
devm33's solution:
1
2
3
4
(fn [n]
  (let [d (reverse (map #(mod % 10) (take-while (partial < 0) (iterate #(quot % 10) n))))
        c (quot (count d) 2)]
    (apply = (map (partial reduce +) [(take c d) (take-last c d)]))))
dwelte's solution:
1
2
3
4
5
6
7
(fn [x]
  (let [xs (seq (str x))
        crusher (fn [chars] (reduce + (map #(Character/digit % 10) chars)))
        l (quot (count xs) 2)
        f (crusher (take l xs))
        r (crusher (take l (reverse xs)))]
    (= f r)))
dzholev's solution:
1
2
3
4
5
6
(fn [n]
  (let [digits (map #(Character/getNumericValue %) (str n))
        m (bit-shift-right (count digits) 1)    ; that's fast /2 :-)
        left (take m digits)
        right (take-last m digits)]
    (= (apply + left) (apply + right))))
echevarria's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n]
    (let [sn (str n)
          cn (quot (count sn) 2)
          [ ln rrn ] (split-at cn sn)
          rn (if (= (count rrn) cn) rrn (rest rrn))
          sum #(+ %1 (read-string (str %2)))
          l  (reduce sum 0 ln)  
          r  (reduce sum 0 rn)
          ]
          ( = l r)
    ))
ericw's solution:
1
2
3
4
5
6
7
8
(letfn [                                                                                                                        
    (to-sequence [n] (map #(- (int %) 48) (seq (str n))))                                                                                               
    (is-balanced [n] (let [s (to-sequence n)                                                                                    
                           half (Math/ceil (/ (count s) 2))                                                                                             
                           left (take half s)                                                                                   
                           right (take-last half s)]                                                                                                    
                                (= (apply + left) (apply + right))))]                                                           
        is-balanced)
featalion's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [n]
  (letfn [(n->digits
           ([n_] (n->digits nil n_))
           ([ds n_]
            (if (< 0 n_)
              (recur (conj ds (rem n_ 10)) (quot n_ 10))
              ds)))]
    (let [d-seq (n->digits n)
          half-len (/ (count d-seq) 2)]
      (if (= 0 half-len)
        true
        (= (reduce + (take half-len d-seq))
           (reduce + (take-last half-len d-seq)))))))
finsternis's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [digits (->> n str (map str) (map read-string))
        len (count digits)
        half (quot len 2)
        fst (take half digits)
        lst (drop (- len half) digits)]
    (= (apply + fst) (apply + lst))))
flububb's solution:
1
2
3
4
5
(fn bal? [k]
  (apply = (map
             (partial reduce +)
               (map #(map int (take (/ (count %) 2) %))
             [(str k) (reverse (str k))]))))
garyxia's solution:
1
2
3
4
;;; (__ 1982) must be 'true' ?
#(let [s (str %)
       f (fn [s] (sort (take (/ (count s) 2) s)))]
  (= (f s) (f (reverse s))))
geekerzp's solution:
1
2
3
4
(fn [n]
    (let [s (str n), l (count s)]
      (= (reduce + (map int (take (Math/ceil (/ l 2)) s)))
         (reduce + (map int (drop (Math/floor (/ l 2)) s))))))
glchapman's solution:
1
2
3
4
5
6
7
(fn balance? [n]
    (let [sn (str n)
          half-size (quot (count sn) 2)
          sum-digits #(apply + (map int %))]
        (= (sum-digits (subs sn 0 half-size))
           (sum-digits (subs sn (- (count sn) half-size)))
        )))
goaranger's solution:
1
2
3
4
5
6
7
8
(fn balanced [n]
  (let [sn (rest (clojure.string/split (str n) #""))
        il (int (/ (count sn) 2))
        subtotal (fn subtotal [alist]
                   (reduce #(+ %1 %2) alist))
        dalist (flatten (for [i (range il)]
                          (list (Integer. (nth sn i)) (Integer. (nth sn (- (count sn) (inc i)))))))]
    (if (< n 10) true (= (subtotal (take-nth 2 dalist)) (subtotal (take-nth 2 (rest dalist)))))))
gpittarelli's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [x]
  (let [to-digits 
        (fn to-digits [n base]
          (let [r (rem n base)
                n' (int (/ n base))]
            (if (= 0 n')
              [r]
              (vec (concat (to-digits n' base) [r])))))
        digits (to-digits x 10)
        n (count digits)
        [lhs rhs'] (split-at (int (/ n 2)) digits)
        rhs ((if (odd? n) rest identity) rhs')]
    (println lhs rhs)
    (= (reduce + lhs)
       (reduce + rhs))))
happycrisis's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
  (->> n
     str
     (re-seq #".")
     (map read-string)
     ( (juxt identity reverse) )
     (map #(take (quot (count %) 2) %))
     (map #(reduce + %))
     (apply =)))
hisba's solution:
1
2
3
4
5
6
(fn isba [n]
  (let [s (map #(- (int %) (int \0)) (str n))
        hl (quot (count s) 2)
        l (take hl s)
        r (take hl (reverse s))]
    (= (reduce + l) (reduce + r))))
icamts's solution:
1
2
3
4
(fn [n] 
  (let [s (str n) i (quot (count s) 2) 
        f (partial reduce #(+ %1 (- (int %2) 48)) 0)] 
    (= (f (take i s)) (f (take-last i s)))))
immo's solution:
1
2
3
4
5
6
(fn [n]
  (let [s (str n)
        f #(apply + (map int (%1 (int (/ (count %2) 2)) %2)))]
    (=
      (f take s)
      (f take-last s))))
jarlax's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (let [digit #(Character/getNumericValue %)
        digits (->> (str n) (map digit))
        rdigits (reverse digits)
        halfdigits #(-> (count %) (/ 2) (take %))
        halfsum #(apply + (halfdigits %))]
    (= (halfsum digits)
       (halfsum rdigits))))
jedo's solution:
1
2
3
4
5
6
7
8
9
10
(fn bn [x]
  (let [s (str x) 
          c (count s)
          split (split-at (/ c 2) s)
          left (if (odd? c) (butlast (first split)) (first split))
          right (second split)
          sumN (fn [z] (apply + (map #(Integer/parseInt (str %)) z)))]
        (= (sumN right) (sumN left))
    )
)
jeff_terrell's solution:
1
2
3
4
5
6
7
(fn [x]
  (let [ds (mapv #(-> % str Integer.) (print-str (str x)))
        n (quot (count ds) 2)]
    (apply =
           (map #(apply + %)
                [(take n ds)
                 (take-last n ds)]))))
johncowie's solution:
1
2
3
4
(fn [n]
   (let [half (fn [s] (map #(read-string (str %)) (subs s 0 (quot (count s) 2))))
         sum #(reduce + %)]
     (= (sum (half (str n))) (sum (half (apply str (reverse (str n))))))))
jomicoll's solution:
1
2
3
4
5
6
7
8
9
10
(fn balance-of-n [n]
  (let [s (str n)
        digits-cnt (count s)
        mid (unchecked-divide-int digits-cnt 2)]
    (if (even? digits-cnt)
      (= (apply + (map int (take mid s)))
         (apply + (map int (drop mid s))))
      
      (= (apply + (map int (take mid s)))
         (apply + (map int (drop (inc mid) s)))))))
jorendorff's solution:
1
2
3
(fn [n] (let [s (str n) l (count s) m (int (/ l 2))]
          (= (apply + (map int (subs s 0 m)))
             (apply + (map int (subs s (- l m)))))))
jslavin's solution:
1
2
3
4
5
(fn balanced? [number]
  (let [numbers (map #(Character/digit % 10) (str number))
        half (int (Math/ceil (* 0.5 (count numbers))))]
    (= (apply + (take half numbers)) (apply + (take-last half numbers)))
    ))
kohyama's solution:
1
2
3
4
5
(fn [n]
  (let [s (str n)
        m (quot (count s) 2)
        ds #(apply + (map (comp read-string str) (take m %)))]
    (= (ds s) (ds (reverse s)))))
kopychenko's solution:
1
2
3
4
5
6
7
8
(fn the-balance-of-n [n]
  (let [v (vec (map #(- (int %) 48) (vec (str n))))
        l (count v)
        lp (quot l 2)
        p1 (subvec v 0 lp)
        p2 (subvec v (+ lp (rem l 2)))]
 
    (= (apply + p1) (apply + p2)) ))
blucas's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn prob115 
  [n]
  (if (< n 10) true
      (letfn [(digits 
                [num] 
                (map #(Character/digit % 10) (str num)))
              (split-middle [xs]
                (let [len (count xs)
                      mid (int (/ len 2))
                      left (take mid xs)
                      mid (if (odd? len) (inc mid) mid)
                      right (drop mid xs)
                      ]
                  (= (reduce + left) (reduce + right))))
              ]
        (split-middle (digits n)))))
brendan's solution:
1
2
3
4
5
#(let [d (map int (str %))
        n (quot (count d) 2)
        f (fn [x] (apply + (take n x)))]
    (= (f d)
       (f (reverse d))))
kuze's solution:
1
2
3
4
5
6
7
(fn my-balance-of-n
  [val]
  (let [part-one (int (java.lang.Math/ceil (/ (count (str val)) 2)))
        part-two (int (java.lang.Math/floor (/ (count (str val)) 2)))
        parts (partition part-one part-two (str val))
        to-digits (fn [cl] (map #(Character/digit % 10) cl))]
  (= (reduce + (to-digits (first parts))) (reduce + (to-digits (second parts))))))
lackita's solution:
1
2
3
4
5
6
(fn balanced? [n]
  (let [digits (map #(Integer/parseInt (str %)) (str n))
        half-count (int (/ (count digits) 2))
        first-n #(map (partial nth %1) (range %2))]
    (= (apply + (first-n digits half-count))
       (apply + (first-n (reverse digits) half-count)))))
lambda4fun's solution:
1
2
3
4
#(let [xs (map int (str %))
       n (/ (count xs) 2)]
   (= (apply + (take n xs))
      (apply + (take-last n xs))))
lasthemy's solution:
1
2
3
4
5
6
7
8
(fn balance [x]
  (let [digits (map #(- (int %) (int \0)) (str x))
        n (/ (count digits) 2)
        left (take n digits)
        right (take-last n digits)]
    (= (apply + left) (apply + right))
    )
  )
lbarrett's solution:
1
2
3
4
(fn [x]
  (let [digits (map int (str x))
        n (count digits)]
    (= (apply + (take (Math/ceil (/ n 2)) digits)) (apply + (drop (Math/floor (/ n 2)) digits)))))
leetwinski's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [
    d (map #(Integer. (str %)) (str n))
    c (/ (count d) 2)
    l (take c d)
    r (take c (reverse d))]
    (= (apply + l) (apply + r))))
littlejp2046's solution:
1
2
3
4
5
6
(fn [n]
  (let [asSeq (map int (str n))
        c (quot (count asSeq) 2)
        part1 (take c asSeq)
        part2 (take c (reverse asSeq))]
    (= (reduce + part1) (reduce + part2))))
malvert's solution:
1
2
3
4
5
6
(fn [n]
  (let [ds (map #(- (int %) 48) (str n))
        l (count ds)]
    (apply = 
      (map #(reduce + %)
        [(take (quot l 2) ds) (drop (/ l 2) ds)]))))
matiasl's solution:
1
2
3
4
5
6
7
8
9
10
(fn [x] 
  (apply 
   = 
   (let [s (seq (str x)) 
         cnt (count s)
         half (quot cnt 2)] 
     (map (fn [s] (apply + (map int s))) 
          (if (even? cnt) 
            (split-at half s) 
            [(take half s) (drop (inc half) s)])))))
maximental's solution:
1
2
3
4
#(let [d (map int (str %))
       d (map - d (reverse d))
       d (take (quot (count d) 2) d)]
   (= 0 (apply + d)))
mbakhterev's solution:
1
(fn [n] (let [S (map int (str n)) h (int (/ (count S) 2))] (= (reduce + (take h S)) (reduce + (take-last h S)))))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn balanced?
  [n] {:pre [(integer? n), (not (neg? n))]}
  (let [
        ;; Constructing the digit sequence of n.
        digits
        (loop [acc [], n n]
          (if (< n 10)
            (cons n acc)
            (recur (cons (mod n 10) acc)
                   (quot n 10)))),
 
        ;; The first and last halves of the digit sequence.  If there are an odd
        ;; number of digits, the center digit (which should not be summed as
        ;; part of either half) is the first element of the tail.
        [head tail]
        (split-at (quot (count digits) 2) digits)]
    
    (if (even? (count digits))
      (= (apply + head) (apply + tail))
      (= (apply + head) (apply + (rest tail))))))
mfikes's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
  (let [digits-vector ((fn digits [n]
                         (if (< n 10)
                           [n]
                           (conj (digits (quot n 10)) (rem n 10)))) n)
        half-length (quot (count digits-vector) 2)
        left-digits (take half-length digits-vector)
        right-digits (take-last half-length digits-vector)]
    (= (reduce + left-digits) (reduce + right-digits))))
minitrue's solution:
1
2
3
4
5
#(let [s (->> % str (map int) vec)
       n (count s)
       l (subvec s 0 (/ n 2))
       r (subvec s (-> n inc (/ 2)) n)]
  (= (apply + l) (apply + r)))
mkahn's solution:
1
2
3
4
5
6
7
(fn balanced? [n]
    (letfn [(digits [x]
           (if (< x 10)
             (vector x)
             (conj (digits (/ (- x (mod x 10)) 10)) (mod x 10))))]
        (== (apply + (subvec (digits n) 0 (Math/floor (/ (count (digits n)) 2))))
            (apply + (subvec (digits n) (Math/ceil (/ (count (digits n)) 2)))))))
mobiusloop's solution:
1
2
3
4
5
6
7
(fn [m]
(let [l (map #(mod % 10) (take-while #(not (= % 0)) (iterate #(int (/ % 10)) m)))
      n (/ (count l) 2)
      f (take (int (+ 0.5 n)) l)
      s (drop (int n) l)]
  (= (apply + f) (apply + s))
  ))
mononite's solution:
1
2
3
4
5
6
(fn [n]
  (let [digits (loop [acc () n n] (if (< n 10) (conj acc n) (recur (conj acc (mod n 10)) (quot n 10))))
        len (quot (count digits) 2)
        left (reduce + (take len digits))
        right (reduce + (take-last len digits))]
    (= left right)))
mouse's solution:
1
#(let [s (str %) r (reverse s) c (/ (count s) 2) i (fn [x] (set (take c x)))] (= (i s) (i r)))
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [n]
  (letfn
      [(digits [n]
         (loop [res '() n n]
           (if (zero? n)
             res
             (recur (conj res (rem n 10))
                    (quot n 10)))))]
    (let [digits (digits n)
          half-count (quot (count digits) 2)]
      (= (reduce + (take half-count digits))
         (reduce + (take-last half-count digits))))))
nagi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn balanced? [n]
  (letfn [(split [n]
            (->> n
                 (str)
                 (map int)
                 (map #(- % 48))))
          (divvy [ns]
            (let [half (/ (count ns) 2)]
              (list
               (take half ns)
               (take-last half ns))))
          (sum [ns]
            (map (partial reduce +) ns))
          (test [ns]
            (= (first ns) (last ns)))]
    (->> n
         (split)
         (divvy)
         (sum)
         (test))))
nikelandjelo's solution:
1
2
3
4
5
6
7
8
(fn [n]
 (let [s (seq (str n))
       l (quot (count s) 2)]
   (->> [s (reverse s)]
     (map #(take l %))
     (map (fn [s] (map #(Character/digit % 10) s)))
     (map #(apply + %))
     (apply =))))
noiseehc's solution:
1
(fn [z] (letfn [(sum [x] (reduce + (map #(- (int %) 48) (take (/ (count x) 2) x))))] (= (sum (str z)) (sum (reverse (str z)))) ))
norman's solution:
1
2
3
4
5
6
7
(fn [num]
  (let [numtext (str num)
        howmany (int (/ (count numtext) 2))
        front (take howmany numtext)
        end   (take-last howmany numtext)
        dig   #(- (int %) 48)]
    (= (apply + (map dig front)) (apply + (map dig end)))))
nothsaevets's solution:
1
2
3
4
5
6
(fn [n]
   (let [digits (map int (str n))
         size (int (/ (count digits) 2))
         left (take size digits)
         right (take-last size digits)]
     (= (apply + left) (apply + right))))
owk4057's solution:
1
2
3
4
(fn myf2 [n]
  (let [n (map #(- (int %) 48) (str n))
        len (quot (count n) 2)]
    (= (apply + (take len n)) (apply + (take len (reverse n))))))
ownwaterloo's solution:
1
2
3
4
5
6
7
8
9
(fn [x]
  (let [ds (->> (iterate #(* 10 %) 1)
            (map #(quot x %))
            (take-while #(> % 0))
            (map #(mod % 10)))
        n (count ds)
        [l r] (split-at (quot n 2) ds)
        r' (drop (mod n 2) r)]
    (== (apply + l) (apply + r'))))
ozan's solution:
1
2
3
4
(fn [x]
  (let [s (str x), l (count s)]
    (= (reduce + (map int (take (Math/ceil  (/ l 2)) s)))
       (reduce + (map int (drop (Math/floor (/ l 2)) s))))))
pukeface's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
    (let [sn (str n)
          l (count sn)
          c (quot l 2)
          sd (fn [s] (reduce + (map (comp read-string str) s)))]
          (->> sn
               ((juxt #(subs % 0 c) #(subs % (- l c) l)))
               (map sd)
               (apply =))))
quant1's solution:
1
2
3
4
(fn [n]
  (let [s (map #(read-string (str %)) (str n))
       h (quot (count s) 2)]
    (= (apply + (take h s)) (apply + (take h (reverse s))))))
rodmax's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [i](->> 
   i
   str 
   (map #(->> % int (+ -48))) 
   ((juxt identity reverse))
   (map #(->>
          %
          identity
          (reductions +)
          ((fn [n] (nth n (bit-shift-right (dec (count n)) 1) )))
          )
   )
   (apply =)
))
sbondaryev's solution:
1
2
3
4
5
6
7
(fn f [num]
  (let [d (map #(- (int %) (int \0)) (str num))
        c (count d)
        m (quot c 2)]
    (if (even? c)
      (= (apply + (take m d)) (apply + (drop m d)))
      (= (apply + (take m d)) (apply + (drop (inc m) d))))))
shiro's solution:
1
2
3
4
5
6
(fn compare-side-digits [x]
  (let [s (map #(Integer. (str %)) (str x))
        l-c (int (/ (count s) 2)) 
        r-c (Math/ceil (/ (count s) 2))]
    (= (apply + (take l-c s)) 
       (apply + (drop r-c s)))))
sheldon's solution:
1
(fn [n] (let [x (str n) i (quot (count x) 2) r (map (partial apply +) (map (partial map int) [(take i x) (drop (if (odd? (count x)) (inc i) i) x)]))] (= (first r) (last r))))
silverio's solution:
1
2
3
4
5
#(let [s ((fn digits [n]
            (if (pos? n) (cons (mod n 10) (digits (quot n 10))))) %)
       k (/ (count s) 2)
       r (reverse s)]
   (= (reduce + (take k s)) (reduce + (take k r))))
skyrem's solution:
1
2
3
4
5
(fn [n]
  (if (< n 10) true
    (let [deal (#(partition  (int (Math/ceil (/ (count %) 2))) (int (/ (count %) 2)) %) 
                 (map (comp read-string str) (str n)))]
      (= (apply + (first deal)) (apply + (second deal))))))
soul_awaker's solution:
1
2
3
4
5
(fn [n]
  (let [s (vec (map #(- (int %) (int \0)) (str n)))
        c (int (/ (count s) 2))]
    (= (apply + (subvec s 0 c))
       (apply + (subvec s (if (odd? (count s)) (inc c) c))))))
staafl2's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(letfn
  [
  ( digits [n]
    (let [[ds n]
      (last (take-while
        (comp (complement zero?) second)
        (iterate
          (fn [[ds n]] [(conj ds (mod n 10)) (int (/ n 10))])
          [[] n])))]
      (conj ds n)))
  ( split [n]
        (let [ds (digits n)
              c (count ds)
              hc (int (/ c 2))]
          [(take hc ds) (drop (+ hc (mod c 2)) ds)]))]
  (fn [n]
    (= 1 (count (distinct (map (partial reduce +) (split n)))))))
syeerzy's solution:
1
2
3
4
5
(fn [n]
  (let [s (str n)
        f #(apply + (map int (% (int (/ (count s) 2)) s)))]
    (=(f take)
      (f take-last))))
tclamb's solution:
1
2
3
4
5
6
(fn [n]
  (let [s (str n)
        p #(+ %1 (int %2))
        r #(reduce p 0 (% (quot (count s) 2) s))]
    (= (r take)
       (r take-last))))
thegeez's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [n]
    (let [[lf rf] (first (for [lf (iterate #(* 10 %) 1)
                               rf [lf (* 10 lf)]
                               :when (zero? (quot n (* lf rf)))]
                           [lf rf]))
          left (quot n lf)
          right (mod n rf)
          digit-sum (fn s
                      ([n] (s 0 n))
                      ([c n]                       
                           (if (< n 10)
                             (+ c n)
                             (recur (+ c (mod n 10)) (quot n 10)))))]
      (= (digit-sum left)
         (digit-sum right))))
zzamboni's solution:
1
2
3
4
(fn balanced? [n]
  (let [d (map (comp read-string str) (seq (str n)))
        n1 (quot (count d) 2)]
    (= (apply + (take n1 d)) (apply + (take-last n1 d)))))
zoltanjarai's solution:
1
2
3
4
5
6
7
(fn __ [n]
  (let [l (->> (str n)
               (map #(Character/digit % 10)))
        m (quot (count l) 2)]
    (= (reduce + (take m l)) (reduce + (take-last m l)))
    )
  )
zipzop's solution:
1
2
3
4
(fn b [n]
  (let [s (str n) h (quot (count s) 2) left (subs s 0 h) right (subs (clojure.string/reverse s) 0 h)]
(= (apply + (map #(- (int %) 48) left))
   (apply + (map #(- (int %) 48) right)))))
yusubori's solution:
1
2
3
#(let [xs (map read-string (map str (str %)))
        n (/ (count xs) 2)]
    (= (apply + (take n xs)) (apply + (take-last n xs))))
ydash's solution:
1
2
3
(fn [n]
  (-> n str count (/ 2) ((juxt take take-last) (str n))
      (->> (map sort) (reduce =))))
vpeurala's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
(fn [n] (letfn [
(digits [n]
    (letfn [
        (digits- [n]
            (if
                (zero? n)
                []
                (cons
                    (rem n 10)
                    (lazy-seq (digits- (quot n 10))))
            )
        )]
        (if
            (zero? n)
            [0]
            (reverse (digits- n))
        )
    )
)
(number-from-digits [ds]
    (letfn [
        (number-from-digits- [ds]
            (if
                (empty? ds)
                0
                (+ (first ds)
                   (* 10 (number-from-digits- (rest ds)))
                )
            )
        )]
        (number-from-digits- (reverse ds))
    )
)
(head-part [n]
    (number-from-digits (take (max 1 (quot (count (digits n)) 2)) (digits n)))
)
(tail-part [n]
    (number-from-digits (take-last (max 1 (quot (count (digits n)) 2)) (digits n)))
)
(the-balance-of-n [n] (= (reduce + (digits (head-part n))) (reduce + (digits (tail-part n)))))
] (the-balance-of-n n)))
v_bogdanov's solution:
1
2
3
4
(fn b [n]
(let [v (map #(read-string (str %)) (str n))
      m (quot (count v) 2)]
  (= (apply + (take m v)) (apply + (take-last m v)))))
unionx's solution:
1
2
3
4
5
(fn [x]
  (let [lst (map #(bigint (.toString %)) (.toString x))
        len (quot (count lst) 2)]
    (= (apply + (drop len lst))
       (apply + (drop-last len lst)))))
trxeste's solution:
1
2
3
4
5
6
(fn [n]
  (let [digits (map #(Integer/parseInt (str %)) (str n))
        size (int (/ (count digits) 2))
        f (take size digits)
        l (take-last size digits)]
    (= (reduce + f) (reduce + l))))
transfinite's solution:
1
2
3
4
5
6
7
8
(fn [ n ]
  (let [ digits (->> n str seq (map str))
        len (count digits)
        half (+ (quot len 2) (rem len 2))
        back-drop (if (even? len) half (dec half))
        l (map #(Integer. %) (take half digits))
        r (map #(Integer. %) (drop back-drop digits))]
    (= (reduce + l) (reduce + r))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)