;; 110 Sequence of pronunciations [m]

Returns infinite lazy seq consisting of
the num of repeated nums and the num itself.
[1 1] is pronounced as [2 1] ("two ones"),
which in turn is [1 2 1 1] ("one two, one one").

(defn seq-prons [s]
  (next (iterate #(mapcat (juxt count first)
                    (partition-by identity %)) s)))
#'user/seq-prons
user>  (take 3 (seq-prons [1]))
((1 1) (2 1) (1 2 1 1))
user> (first (seq-prons [1 1 1 4 4]))
(3 1 2 4)
user> (nth (seq-prons [1]) 6)
(1 1 1 3 2 1 3 2 1 1)
user> (count (nth (seq-prons [3 2]) 15))
338

(fn [col]
  (->> col (iterate #(->> (partition-by identity %)
                      (mapcat (fn [a]
                                  [(count a) (first a)]))))
           (drop 1)))

(fn f [s]
  (let [x (flatten (map #(vector (count %) (first %))
                     (partition-by identity s)))]
    (lazy-seq (cons x (f x)))))

(fn genPronounciationSeq [initColl]
  (letfn [(pronounce [coll]
            (let [partitionedColl
                   (partition-by identity coll)]
              (vec (interleave (map count partitionedColl)
                     (map first partitionedColl)))))]
    (lazy-seq
      (let [newPronunciation (pronounce initColl)]
        (cons newPronunciation
             (genPronounciationSeq newPronunciation))))))

(fn p [xs]
  (lazy-seq
    (let [r (mapcat #(list (count %) (first %)) (partition-by identity xs))]
      (cons r (p r)))))
aceeca1's solution:

1
2
3
4
(letfn [
    (pron [x] (for [i (partition-by identity x) v [(count i) (first i)]] v))
    (iterpron [x] (iterate pron (pron x)))]
    iterpron)
adereth's solution:

1
2
3
4
5
6
(fn [s]
  (rest
  (iterate
   (fn [t]
     (flatten (map (juxt count first) (partition-by identity t))))
   s)))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
(fn pronunciationX [v]
    (lazy-seq (let [newV ((fn pronunciation [v] 
(mapcat (fn pronunciationOne [v] [(count v) (first v)])
 ((fn partitionIdentity [v] (partition-by identity v))
 v))
)
 v)] 
        (cons newV (pronunciationX newV))))
    )
aguirre's solution:

1
2
3
4
5
6
7
8
(fn pronounciations [xs] 
     (let [pronounciation (fn [ys]
                            (->> ys
                              (partition-by identity)
                              (map #(vector (count %) (first %)))
                              flatten))
           pronounced (pronounciation xs)]
     (lazy-cat [pronounced] (pronounciations pronounced))))
alanforr's solution:

1
2
3
4
5
(fn [a]
    (let [sortthem (fn [b] (partition-by identity b))
          nums (fn [b] (mapcat #(vec (frequencies %)) (sortthem b)))
          pron (fn [b] (mapcat reverse (nums b)))] 
      (drop 1 (iterate pron a))))
allenl's solution:

1
2
3
4
5
(fn pronounce [xs]
  (drop 1
        (iterate #(->> %
                       (partition-by identity)
                       (mapcat (fn [x] [(count x) (first x)]))) xs)))
andthorn's solution:

1
2
3
4
5
6
7
8
9
(fn [a] 
  (let [f (fn f[a c]
            (if (empty? a)
              '()
              (if (= (first a) (second a))
                (f (next a) (inc c))
                (conj (f (next a) 1) (first a) c))))
        g (fn [a] (apply vector(f a 1)))]
    (next(iterate g a))))
anjensan's solution:

1
2
3
4
5
6
7
8
(fn [a]
  (next
    (iterate
      (fn [s]
        (mapcat 
          (fn [x] [(count x) (first x)])
          (partition-by identity s)))
      a)))
astangl's solution:

1
2
3
4
5
(fn
  [coll]
  (letfn [(r [coll] (mapcat #(vector (.size %) (first %))
                            (partition-by identity coll)))]
    (rest (iterate r coll))))
austintaylor's solution:

1
2
3
4
5
6
(fn [s]
  (letfn [(prons [s]
    (lazy-seq
      (let [pr (mapcat #(vector (count %) (first %)) (partition-by identity s))]
        (cons pr (prons pr)))))]
    (prons s)))
awebb's solution:

1
2
3
(fn [v] 
      (letfn [(speak [s] (->> s (partition-by identity) (map (juxt count first)) flatten ))]
        (iterate speak (speak v))))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
(fn pro [sequence] 
  (letfn 
    [(group [acc n]
      (if (= (ffirst acc) n)
          (cons [n (inc (second (first acc)))] (rest acc))
          (cons [n 1] acc)))
     (pronounciation [s] (reverse (flatten (reduce group '() s))))]
    (cons
      (pronounciation sequence)
      (lazy-seq (pro (pronounciation sequence))))))
benhammond's solution:

1
2
3
(fn sp [s]
    (let [ns (vec (mapcat (juxt count first) (partition-by identity s)))]
      (lazy-seq (cons ns (sp ns)))))
benizi's solution:

1
2
3
(fn pron [s]
  (let [nxt (mapcat (juxt count first) (partition-by identity s))]
    (lazy-seq (cons nxt (pron nxt)))))
bobuhiro11's solution:

1
2
3
4
(fn p [col]
  (let  [r (flatten (map (fn [x] [(count x) (first x)])
                         (partition-by #(identity %) col)))]
    (cons r (lazy-seq (p r)))))
burner's solution:

1
2
3
4
5
6
7
8
9
(letfn [(split-same [seq]
                (if (empty? seq) []
                    (cons (take-while #(= % (first seq)) seq)
                          (split-same (drop-while #(= % (first seq)) seq)))))
              (pron-same [s]
                [(count s) (first s)])
              (pron1 [s]
                (mapcat pron-same (split-same s)))]
        (fn [s] (iterate pron1 (pron1 s))))
caterpillar's solution:

1
2
3
4
5
6
7
(fn lazy-pronounce [x] (let[pronunce (fn[v]
                                       (loop[reV (rest v) n (first v) c 1 r [] ]
                                         (if(seq reV)(let[cn (first reV)]
                                                       (if (= cn n) (recur (rest reV) n (inc c) r) (recur (rest reV) cn 1 (conj r c n))))
                                           (conj r c n))))
                            pv (pronunce x)]
                         (cons pv (lazy-seq (lazy-pronounce pv)))))
cc787's solution:

1
2
3
4
#(rest (iterate (fn [arg]
                  (->> arg (partition-by identity) (map (juxt count first)) flatten)
                  )
                %))
chunchangshao's solution:

1
(fn a [xs] (lazy-seq (let [t (flatten (map #(vec [(count %) (first %)]) (partition-by #(int %) xs)))] (cons t (a t)))))
ctzsm's solution:

1
2
3
4
(fn [coll]
  (letfn [(pro [coll]
    (mapcat #(vector (count %) (first %)) (partition-by identity coll)))]
(iterate pro (pro coll))))
dan7es's solution:

1
2
3
4
5
6
7
8
(comp
 rest
 (partial
  iterate
  #(mapcat
    (juxt count first)
    (partition-by
     identity %))))
daniels's solution:

1
2
3
(fn [x]
  (let [f #(mapcat (juxt count first) (partition-by identity %))]
    (iterate f (f x))))
daowen's solution:

1
2
(partial (comp next iterate)
         #(mapcat (juxt count first) (partition-by identity %)))
del680202's solution:

1
2
3
4
5
(fn _p [seq]
  (let [_plist (fn [s](loop [r [] k (first s) s s](if (empty? s) (apply concat (map #(list (count %) (first %)) r)) (let [tuple (for [_s s :while (= k _s)]_s) restseq (drop (count tuple) s)] (recur (conj r tuple) (first restseq) restseq)))))]
  (cons (_plist seq) (lazy-seq (_p (_plist seq))))
  )
)
deping's solution:

1
2
3
4
5
(fn ! [v]
  (let [b (partition-by identity v)
        x (interleave (map count b) (map first b))]
   (cons x (lazy-seq (! x)))
   ))
devm33's solution:

1
2
3
(fn __ [coll]
  (let [pron (mapcat #(vector (count %) (first %)) (partition-by identity coll))]
    (cons pron (lazy-seq (__ pron)))))
dwelte's solution:

1
2
3
4
5
6
7
(fn [oxs]
  (drop 1 (iterate
   (fn [xs]
     (mapcat
      #(list (count %) (first %))
      (partition-by identity xs)))
   oxs)))
dzholev's solution:

1
2
3
4
(fn sp [s]
  (lazy-seq
    (let [a (mapcat #(vector (count %) (first %)) (partition-by identity s))]
      (cons a (sp a)))))
echevarria's solution:

1
2
3
(fn [s]
    (drop 1 (iterate (fn [ v ]
    (mapcat #(vector (count %) (first %)) (partition-by identity v))) s)))
ericw's solution:

1
2
3
4
(letfn [                                                                                                                        
    (pronounce [s] (mapcat #(list (count %) (first %)) (partition-by identity s)))                                                                      
    (pronunciation-seq [s] (let [s' (pronounce s)] (cons s' (lazy-seq (pronunciation-seq s')))))]                                                       
        pronunciation-seq)
featalion's solution:

1
2
3
4
5
(fn pronounce [coll]
  (let [p-coll (reduce #(conj %1 (count %2) (first %2))
                       []
                       (partition-by identity coll))]
    (lazy-seq (cons p-coll (pronounce p-coll)))))
finsternis's solution:

1
2
3
(fn sp [s]
  (let [ss (mapcat #(vector (count %) (first %)) (partition-by identity s))]
    (lazy-seq (cons ss (sp ss)))))
flububb's solution:

1
2
3
4
5
6
7
(fn pron-seq [s]
  (rest (iterate
    (fn [a]
      (mapcat
        #(list (count %) (first %)) 
        (partition-by identity a)))
    s)))
garyxia's solution:

1
2
3
4
(fn seq-of-pronunciations [coll]
  (lazy-seq
    (let [next-coll (apply concat (map #(vec [(count %) (first %)]) (partition-by #(if true %) coll)))]
      (cons next-coll (seq-of-pronunciations next-coll)))))
geekerzp's solution:

1
2
3
4
5
6
(fn [s]
    (rest
     (iterate
      #(flatten
        (map (fn [v] (vector (count v) (first v)))
             (partition-by identity %))) s)))
glchapman's solution:

1
2
3
4
5
6
7
8
9
(fn [nums]
    (let [pronounce 
            (fn [nums]
                (->> (partition-by identity nums)
                     (mapcat #(list (count %) (first %)))
                ))
        ]
        (rest (iterate pronounce nums))
    ))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn pronounce [se]
  (let [f (fn f [alist]
            (loop [l alist res []
                   ccount 0 pnum nil]
              (if (= 0 (count l))
               (conj res ccount pnum)
               (if (nil? pnum)
                (recur (rest l) res (inc ccount) (first l))
                (if-not (= (first l) pnum)
                 (recur (rest l) (conj res ccount pnum) 1 (first l))
                 (recur (rest l) res (inc ccount) (first l)))))))]
  (iterate f (f se))))
gpittarelli's solution:

1
2
3
4
(fn pronounce [s]
  (let [p (vec (mapcat #(list (count %) (first %))
                       (partition-by identity s)))]
    (cons p (lazy-seq (pronounce p)))))
happycrisis's solution:

1
(fn [s] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) s)))
hisba's solution:

1
2
(fn pron [s]
  (rest (iterate (fn [v] (mapcat #(vector (count %) (first %)) (partition-by identity v))) s)))
icamts's solution:

1
2
3
4
5
6
(fn [s] 
  (let [pronunciation-it 
        (fn [s] (reduce (fn [coll e] 
                          (conj (conj coll (count e)) (first e))) 
                        [] (partition-by identity s)))]
    (rest (iterate pronunciation-it s))))
immo's solution:

1
2
3
4
5
6
7
8
9
(fn [x]
  (next
    (iterate
      (fn [v]
        (flatten 
          (map
            #(vector (count %) (first %))
            (partition-by identity v))))
    x)))
jarlax's solution:

1
2
3
4
5
6
7
(fn [coll]
  (rest
    (iterate
      #(->> (partition-by identity %)
            (map (fn [c] [(count c) (first c)]))
            flatten)
      coll)))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn seqpro [coll]
  (letfn [(seqpvec [coll] (flatten 
    (map #(vector (count %) (first %))
    (loop [coll coll res []]
        (if (seq coll)
            (let [split (split-with #(= %1 (first coll)) coll)]
                (recur (second split) (conj res (first split)))
            )
            res
        )
    )
    )
    ))]
    (iterate seqpvec (seqpvec coll))
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
(fn [s]
  (rest
    (iterate (fn [s]
               (mapcat #(list (count %) (first %))
                       (partition-by identity s)))
             s)))
johncowie's solution:

1
(fn [v] (rest (iterate  (fn [s] (apply concat (map (fn [p] [(count p) (first p)]) (partition-by (fn [a] a) s)))) v)))
jomicoll's solution:

1
2
3
4
5
6
7
8
(fn pronounce [coll]
  (letfn [(gen-next
            [coll]
            (->> coll
                 (partition-by identity)
                 (mapcat (fn [coll]
                           [(count coll) (first coll)]))))]
    (iterate gen-next (gen-next coll))))
jorendorff's solution:

1
2
(fn [q] (rest (iterate #(mapcat (fn [s] [(count s) (first s)])
                                (partition-by identity %)) q)))
jslavin's solution:

1
2
3
4
5
6
7
8
(fn pro [s]
  (letfn [(nextpro [s]
                   (reduce (fn [acc v] (conj acc (count v) (first v))) [] (partition-by identity s))
                   )]
    (let [val (nextpro s)]
      (lazy-cat [val] (pro val)))
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
; point-free style:
(comp next
      (partial iterate
               (comp (partial mapcat (juxt count first))
                     (partial partition-by identity))))
 
; ordinary style:
;  (fn [xs]
;     (next
;       (iterate
;         #(mapcat
;           (juxt count first)
;           (partition-by identity %))
;         xs)))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn  sequence-of-pronunciations [v]
  (lazy-seq
   (let [[a, lc, ld]   (reduce 
 
                        (fn [[a,c,d]  x]
                          (if (= d x)
                            [a,(inc c),d]
                            [(into a [c,d]),1,x]))
                        
                        [[],1,(first v)]
                        (rest v))
         rez (into a [lc,ld])]
     
     (cons rez (sequence-of-pronunciations rez)))))
blucas's solution:

1
2
3
4
5
6
7
8
(fn [col] 
  (rest 
   (iterate (fn [x] 
              (mapcat 
                (fn [y] 
                    [(count y) (first y)]) 
                (partition-by identity x)))
            col)))
brendan's solution:

1
2
3
(fn pron [xs]
   (let [next-xs (mapcat (juxt count first) (partition-by identity xs))]
     (lazy-seq (cons next-xs (pron next-xs)))))
kuze's solution:

1
2
3
4
(fn my-sequence-of-pronunciations
  [coll]
  (let [nextVal (into [] (mapcat #(vector (count %) (first %)) (partition-by identity coll)))]
    (cons nextVal (lazy-seq (my-sequence-of-pronunciations nextVal)))))
lackita's solution:

1
2
(fn [s] (rest (iterate #(flatten (map (fn [p] [(count p) (first p)]) 
                                      (partition-by identity %))) s)))
lambda4fun's solution:

1
2
3
4
5
6
(fn pros [xs]
  (lazy-seq
   (let [xs (->> xs
                 (partition-by identity)
                 (mapcat (juxt count first)))]
     (cons xs (pros xs)))))
lasthemy's solution:

1
2
3
4
5
6
7
(fn pron [coll]
  (let [pronunc (flatten
                 (map #(vector (count %) (first %))
                      (partition-by identity coll)))]
    (cons pronunc (lazy-seq (pron pronunc)))
    )
  )
lbarrett's solution:

1
2
(fn f [l]
  (rest (iterate (fn [l] (mapcat #(list (count %) (first %)) (partition-by identity l))) l)))
leetwinski's solution:

1
2
3
4
5
6
(fn f [ls]
  (let [next (flatten 
              (map 
                #(vector (count %) (first %)) 
                (partition-by identity ls)))]
    (lazy-seq (cons next (f next)))))
littlejp2046's solution:

1
2
3
4
5
6
7
(fn [l1]
  (drop 1 
        (iterate
         (fn p [l]
           (let [[identicals restlist] (split-with #{(first l)} l)]
             (concat [(count identicals) (first identicals)] (if (empty? restlist) [] (p restlist)))))
         l1)))
malvert's solution:

1
2
3
4
5
(fn [s] 
  (rest (iterate
    #(mapcat (juxt count first)
      (partition-by identity %)) 
    s)))
matiasl's solution:

1
2
3
4
5
6
(comp rest 
      (partial 
       iterate 
       #(mapcat 
         (juxt count first) 
         (partition-by identity %))))
maximental's solution:

1
2
3
4
5
6
7
8
(fn [a]
  (rest 
    (iterate 
      #(reduce
        (fn [b [c :as d]] (conj b (count d) c))
        []
        (partition-by + %)) 
      a)))
mbakhterev's solution:

1
#(rest (iterate (fn [v] (mapcat (juxt count first) (partition-by identity v))) %))
meerwolf's solution:

1
2
3
4
5
6
7
8
(fn pronunciation-sequence
  [coll] {:pre [(every? integer? coll), (every? pos? coll)]}
  (let [pronounce
        (fn [input]
          (->> input
               (partition-by identity)
               (mapcat (juxt count first))))]
    (rest (iterate pronounce coll))))
mfikes's solution:

1
2
3
4
5
(fn pronounce [s]
  (lazy-seq
    (let [pronounciation (flatten (map (juxt count first)
                                       (partition-by identity s)))]
      (cons pronounciation (pronounce pronounciation)))))
minitrue's solution:

1
(fn [xs] (rest (iterate #(->> % (partition-by identity) (map (fn [x] (vector (count x) (first x)))) (apply concat)) xs)))
mkahn's solution:

1
2
3
4
(fn pronounceseq [x]
           (drop 1 (iterate (fn f [y] 
                              (mapcat #(vector (count %) (first %)) (partition-by identity y)))
                            x)))
mobiusloop's solution:

1
2
3
(fn [y]
(rest (iterate (fn [x] (flatten (map #(identity [(count %1) (first %1)]) (partition-by identity x)))) y))
)
mononite's solution:

1
2
3
(fn [coll]
  (let [pf (fn [xs] (reduce #(into % [(count %2) (first %2)]) [] (partition-by identity xs)))]
    (iterate pf (pf coll))))
mouse's solution:

1
2
(fn [x] (rest  (iterate #(mapcat (juxt count first)
                                  (partition-by identity %)) x)))
mwaldowski's solution:

1
2
3
4
5
6
7
8
(fn f110 [coll]
  (letfn [(pronounce [coll]
            (->>
             (partition-by identity coll)
             (map (juxt count first))
             (apply concat)))]
    (let [pronounced (pronounce coll)]
      (cons pronounced (lazy-seq (f110 pronounced))))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
;; NOTE: (partition-by identity xs) was the way to go
 
(fn pron
  ([xs]
   (pron xs (first xs) 0))
  ([xs last count]
   ;; Count one pronounciation
   (letfn [(pron-one [xs last count]
             (if (= last (first xs))
               (pron-one (rest xs) (first xs) (inc count))
               (into [count last]
                     (if (empty? xs)
                       '()
                       (pron-one (rest xs) (first xs) 1)))))]
     ;; Make it lazy
     (let [pronounciation (pron-one xs last count)]
       (cons pronounciation
             (lazy-seq (pron pronounciation)))))))
nikelandjelo's solution:

1
2
3
4
5
(fn [s]
(rest (iterate (fn [s] (->> (partition-by identity s)
                            (map #(vector (count %) (first %)))
                         (apply concat)))
        s)))
noiseehc's solution:

1
(fn [z] (drop 1 (iterate (fn [x] (mapcat #(vector (count %) (first %)) (partition-by identity x))) z)))
norman's solution:

1
2
3
4
5
6
7
(fn seqp [vals]
  (letfn [(nextp [vals]
            (when (seq vals)
               (let [firstval (first vals)
                     countfirst (count (take-while #(= firstval %) vals))]
             (concat [countfirst firstval] (nextp (drop countfirst vals))))))]
     (drop 1 (iterate nextp vals))))
nothsaevets's solution:

1
2
3
4
5
6
(fn [s]
  (let [pronounce (fn [s]
                    (->> (partition-by identity s)
                         (map #(vector (count %) (first %)))
                         (flatten)))]
    (rest (iterate pronounce s))))
owk4057's solution:

1
2
3
4
5
6
(fn myf [coll]
  (letfn [(sub [coll] (let [lst (partition-by identity coll)
                            cnt (map count lst)
                            iden (map first lst)]
                        (interleave cnt iden)))]
    (iterate sub (sub coll))))
ownwaterloo's solution:

1
2
(fn [x]
  (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) x)))
ozan's solution:

1
2
3
4
5
6
7
(fn pronounce-seq [xs]
   (lazy-seq
    (let [pron (->> xs
                    (partition-by identity)
                    (map #(vector (count %) (first %)))
                    (reduce concat))]
      (cons pron (pronounce-seq pron)))))
pukeface's solution:

1
2
3
4
5
6
#(rest 
  (iterate 
   (fn [v]
     (mapcat (juxt count last)
             (partition-by identity v)))
   %))
quant1's solution:

1
(fn [x] (rest (iterate #(->> (partition-by identity %) (map (juxt count first)) flatten) x)))
rodmax's solution:

1
2
3
4
5
6
(fn [lst] (drop 1 
   (iterate #(
     (fn [s] (interleave (map count s) (map first s)))
      (partition-by identity %)
              )         
      lst )))
sbondaryev's solution:

1
2
3
4
(fn f [xs]
  (lazy-seq
   (let [xss (mapcat #(vector (count %) (first %)) (partition-by identity xs))]
        (cons xss (f xss)))))
shiro's solution:

1
2
3
4
5
(fn weird [coll]
  (letfn [(step [coll]
           (mapcat #(list (count %) (first %)) 
                   (partition-by (fn [x] x) coll)))]
    (rest (iterate step coll))))
sheldon's solution:

1
(fn [n] (let [f (fn [x] (mapcat #(vector (count %) (first %)) (partition-by identity x)))] (iterate f (f n))))
silverio's solution:

1
2
3
4
(comp next 
  (partial iterate
    (comp (partial mapcat (juxt count first))
          (partial partition-by identity))))
skyrem's solution:

1
2
3
4
5
(fn sop [coll]
  (lazy-seq
   (let [result 
         (flatten (for [x (partition-by identity coll)] [(count x) (first x)]))]
   (cons result (sop result)))))
soul_awaker's solution:

1
2
3
(fn f [x]
    (let [e (reduce #(into %1 [(count %2) (first %2)]) [] (partition-by identity x))]
        (cons e (lazy-seq (f e)))))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(letfn 
[
( span [xs] (split-with #(= (first xs) %) xs))
( chunk [xs] 
  (map first 
    (take-while 
      #(< 0 (count (first %))) 
      (iterate 
        (fn [[xs ys]] (vec (span ys)))
        (vec (span xs))))))
( pronounce [xs] (mapcat (juxt count first) (chunk xs)))]
  #(rest (iterate pronounce %)))
syeerzy's solution:

1
(partial (comp rest iterate) #(mapcat (juxt count first) (partition-by identity %)))
tclamb's solution:

1
2
3
4
5
6
(fn [s] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) s)))
;
;(fn f [s]
;  (let [p (mapcat (juxt count first)
;                  (partition-by identity s))]
;    (cons p (lazy-seq (f p)))))
thegeez's solution:

1
2
3
(fn [c]
    (next (iterate #(mapcat (juxt count first)
                            (partition-by identity %)) c)))
zzamboni's solution:

1
2
3
(fn pronounce-seq [xs]
  (let [pronounce #(flatten (map (juxt count first) (partition-by identity %)))]
    (rest (iterate pronounce xs))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
(fn __ [s]
  (letfn [(f [s1 n x r]
             (if (empty? s1) (concat r [n x])
               (if (= x (first s1))
                    (f (rest s1) (inc n) x r) 
                 (f (rest s1) 1 (first s1) (concat r [n x])))))]
    (let [t (f (rest s) 1 (first s) [])]
      (cons t (lazy-seq (__ t))))))
zipzop's solution:

1
2
3
4
5
6
7
8
9
(fn p ([s] (p (rest s) [] 1 (first s)))
      ([s ps v k]
       (if (empty? s)
         (let [rs (conj ps v k)]
         (cons rs (lazy-seq (p rs))))
         (let  [h (first s)]
           (if (= h k)
             (p (rest s) ps (inc v) k)
             (p (rest s) (conj ps v k) 1 h))))))
yusubori's solution:

1
2
3
4
5
(fn [s]
  (rest
   (iterate
    #(flatten (map (juxt count first) (partition-by identity %)))
    s)))
ydash's solution:

1
2
3
4
5
6
(fn f [lst]
  (loop [[h & _ :as l] lst, acc []]
    (if h
      (let [[f s] ((juxt take-while drop-while) #(= h %) l)]
        (recur s (conj acc (count f) h)))
      (cons acc (lazy-seq (f acc))))))
vpeurala's solution:

1
(fn pronunciations [xs] (rest (iterate (fn [x] (mapcat #(vector (count %) (first %)) (partition-by identity x))) xs)))
v_bogdanov's solution:

1
#(rest (iterate (fn [s] (mapcat (fn [x] (cons (count x) [(first x)])) (partition-by identity s))) %))
unionx's solution:

1
2
3
4
5
6
7
(fn proun [v]
  (let [ret (loop [acc [] cnt v]
              (if (empty? cnt)
                acc
                (let [[h t] (split-with #(= % (first cnt)) cnt)]
                  (recur (conj acc (count h) (first h)) t))))]
    (cons ret (lazy-seq (proun ret)))))
trxeste's solution:

1
#(rest (iterate (fn [coll] (mapcat (juxt count first) (partition-by identity coll))) %))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [v]
(letfn [(pronun [v]
  (loop [v v
         p []]
    (if (empty? v) (flatten p)
        (let [e (first v)
              f #(= e %)
              a (take-while f v)
              n (count a)]
          (recur (drop-while f v)
                 (conj p [n e]))))))]
 
(next (iterate pronun v))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)