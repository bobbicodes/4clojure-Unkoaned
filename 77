;; 77 Anagram Finder [m]

Finds all the anagrams in a vector of words.
A word x is an anagram of word y if
all the letters in x can be rearranged
in a different order to form y.
Returns a set of sets, where each sub-set is
a group of words which are anagrams of each other.
Each sub-set should have at least two words.
Words without any anagrams not included in result.

(= (__ ["meat" "mat" "team" "mate" "eat"])
   #{#{"meat" "team" "mate"}})
(= (__ ["veer" "lake" "item" "kale" "mite" "ever"])
   #{#{"veer" "ever"} #{"lake" "kale"} #{"mite" "item"}})

(fn [words] (let [letters (into {} (for [w words] [w (sort w)]))] (into #{} 
(filter #(> (count %) 1) (map #(set (map first (val %))) (group-by #(val %) 
letters))))))

#(->> (group-by sort %)
      (vals)
      (map set)
      (filter (comp seq rest))
      (set))

(fn [arg] (set (map set (filter #(> (count %) 1) (map val (group-by #(set %) arg))))))

(fn [strings];anagrams have the same histogram
  (reduce merge #{};prepare the result
          (map set (remove #(= 1 (count %));remove the words without any anagrams
                           (vals (group-by frequencies strings))))));frequencies to build the histogram

(fn [words]
  (set
    (filter #(< 1 (count %))
      (map
        (fn [word]
          (set
            (filter #(= (group-by identity word) (group-by identity %)) words)))
        words))))
aceeca1's solution:

1
(fn [x] (set (for [i (vals (group-by sort x)) :when (< 1 (count i))] (set i))))
adereth's solution:

1
2
3
4
5
6
7
(fn [w]
  (->> w
       (group-by sort)
       vals
       (filter #(> (count %) 1))
       (map #(apply hash-set %))
       (apply hash-set)))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
(fn anagramsB [x] ((fn anagramsRec [x res]
    (if (empty? x) res
    (let [
        v ((fn anagrams1 [tst x] (conj (set (filter (fn [xi] ((fn anagrams? [x y] (= (sort x)(sort y))) tst xi)) x)) tst))  (first x)(rest x))
        newX (remove v x)
        newRes (if (> (count v) 1) (conj res v) res)
        ]
    (anagramsRec newX newRes)
    )))
 x #{}))
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [words]
     (loop [restWords words
            resultSet #{}]
       (if (empty? restWords)
         (into #{} (filter #(< 1 (count %)) resultSet))
         (let [x (first restWords)
               freqX (frequencies x)
               filterFun #(= freqX (frequencies %))]
           (recur
             (remove filterFun restWords)
             (conj resultSet (into #{} (filter filterFun restWords))))))))
alanforr's solution:

1
2
3
4
5
(fn [d] (letfn
    [(group-into-ana-sets [a] (group-by #(set (seq %)) a))
     (select-non-lonely [b] (filter #(> (count (val %)) 1) b))
     (format-my-shit [c] (set (map #(set (nth % 1)) c)))]
    (-> d group-into-ana-sets select-non-lonely format-my-shit)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn find-anagrams [words]
  (->>
   words
   (reduce
    (fn [m x]
      (let [sorted-word (apply str (sort x))]
        (assoc m sorted-word (conj (get m sorted-word #{}) x))
        ))
    {})
   vals
   (filter #(> (count %1) 1))
   set))
andthorn's solution:

1
#(set (filter (comp (partial < 1) count)(map set (vals (group-by sort %)))))
anjensan's solution:

1
(fn [s] (set (remove #(= 1 (count %)) (map set (vals (group-by sort s))))))
astangl's solution:

1
2
3
4
5
6
(fn
  [ss]
  (let [toCanonical (fn [s] (sort (vec (.toLowerCase s))))
        m (reduce (fn [m s] (let [cs (toCanonical s)]
                              (update-in m [cs] #(conj (or % []) s)))) {} ss)]
    (set (filter #(> (.size %) 1) (map (comp set second) (vec m))))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s]
  (set (filter #(< 1 (count %))
    (reduce (fn [anagrams word]
      (let [bucket
        (first (filter (fn [b]
          (= (sort word) (sort (first b)))) anagrams))]
        (if (nil? bucket)
          (conj anagrams #{word})
          (conj (disj anagrams bucket)
            (conj bucket word))))) #{} s))))
awebb's solution:

1
#(->> % (group-by sort) vals (remove (comp #{1} count)) (map set) set)
bendykst's solution:

1
2
3
4
5
6
(fn [words] 
  (set (map set 
    (filter 
      #(< 1 (count %)) 
      (vals 
        (group-by frequencies words))))))
benhammond's solution:

1
2
3
(fn [v]
    (set (filter #(> (count %) 1)
            (map set (vals (group-by #(clojure.string/join (sort (clojure.string/split % #""))) v))))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
(fn [words]
   (->> (reduce
         (fn [sets word]
           (let [id (apply str (sort (seq word)))]
             (assoc sets id (conj (get sets id #{}) word))))
         {}
         words)
        vals
        (filter #(< 1 (count %)))
        (apply hash-set)))
bobuhiro11's solution:

1
2
3
4
5
6
7
(fn [col]
  (apply hash-set (map #(apply hash-set (second %)) (filter (fn [k-v]
            (let [k (first k-v)
                  v (second k-v)]
              (> (count v) 1)))
          (group-by #(sort %)
                    col)))))
burner's solution:

1
2
(fn [s] (set (filter #(> (count %) 1)
                            (map (comp set val) (group-by #(set %) s)))))
caterpillar's solution:

1
#(into #{} (map set (filter (fn[c] (< 1 (count c))) (vals (group-by frequencies %)))))
cc787's solution:

1
(fn [args](set (filter #(> (count %) 1) (map set (vals (group-by sort args))))))
chunchangshao's solution:

1
2
3
4
5
(fn [coll] 
  (into #{} 
        (map 
         (fn [[k v]] (set v)) 
             (filter (fn [[k v]] (> (count v) 1)) (#(group-by (fn [s] (apply str (sort (vec s)))) %) coll)))))
ctzsm's solution:

1
2
(fn [x] (set (map set (filter (fn [coll] (>= (count coll) 2))
        (vals (group-by #(sort %) x))))))
dan7es's solution:

1
2
3
4
5
#(->> (group-by frequencies %)
      (map second)
      (filter next)
      (map set)
      set)
daniels's solution:

1
2
3
4
5
6
7
8
(fn [x]
  (->> x
       (group-by frequencies)
       vals
       (map (partial into #{}))
       (filter #(> (count %) 1))
       (into #{})
       ))
daowen's solution:

1
#(->> % (group-by sort) vals (filter second) (map set) set)
del680202's solution:

1
2
3
4
5
(fn [seq]
   (let [mapize (fn [w1](reduce #(let [[k v] (first %2)](merge  %1 (if (contains? %1 k) {k (inc (%1 k))}  %2)))  (for [c w1] {c 1})))]
      (set (map set (filter #(> (count %) 1)(doall (map #(let [s_map (mapize %1)](for [s seq :when (= s_map (mapize s))]s)) seq)))))
   )
)
deping's solution:

1
(fn [ip] (set (map set (distinct (filter #(>= (count %) 2) (map #(filter (fn [st] (= % (set st))) ip) (map set ip)))))))
devm33's solution:

1
2
(fn [strs]
   (set (filter #(> (count %) 1) (map set (vals (group-by set strs))))))
dwelte's solution:

1
2
3
4
(fn [xs]
  (set (map #(set %) (filter
    #(<= 2 (count %))
    (vals (group-by #(sort %) xs))))))
dzholev's solution:

1
(fn [ws] (set (for [i (vals (group-by sort ws)) :when (< 1 (count i))] (set i))))
echevarria's solution:

1
2
3
4
5
(fn [v]
    (reduce 
        (fn [s [k kv]] 
                (if (> (count kv) 1) (conj s (set kv)) s )) 
     #{} (group-by frequencies v)))
ericw's solution:

1
#(->> % (group-by set) vals (filter next) (map set) set)
featalion's solution:

1
2
3
4
5
6
7
8
(fn [words]
  (set
   (reduce-kv (fn [r _ w]
                (if (> (count w) 1)
                  (conj r (set w))
                  r))
              []
              (group-by #(sort (seq %)) words))))
finsternis's solution:

1
(fn [s] (->> s (group-by set) vals (filter #(>= (count %) 2)) (map set) set))
flububb's solution:

1
2
3
4
(fn anagramm [c]
  (set (map set (filter
                  #(> (count %) 1)
                    (vals (group-by sort c))))))
garyxia's solution:

1
2
3
4
5
(fn [v]
  (into #{}
    (map set
      (filter #(> (count %) 1)
        (map val (group-by sort v))))))
geekerzp's solution:

1
2
3
4
5
(fn [s]
    (into #{}
          (map set
               (filter #(> (count %) 1)
                       (vals (group-by sort s))))))
glchapman's solution:

1
2
3
4
5
#(->> (group-by sort %)
      vals
      (filter (fn [v] (> (count v) 1)))
      (map (partial apply hash-set))
      (apply hash-set))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn ana [l]
      (let [isana (fn [a b]
                      (and (= (count a) (count b))
                           (= (count (set a))
                              (count (clojure.set/union (set a) (set b))))
                           (not= a b)))
            getanas (fn [rw wl]
                        (for [x wl
                             :when (isana rw x)]
                             x))
            answer #{}]
            (into #{} (clojure.set/union (into #{} (filter #(> (count %) 1)
                         (doall (for [m l] (set (conj (getanas m l) m))))))))))
gpittarelli's solution:

1
2
3
4
(fn [s]
(set (map set
(filter (comp #(> % 1) count) (vals (group-by (comp sort (partial re-seq #"."))
          s))))))
happycrisis's solution:

1
(fn [s]  (set (map set (filter #(> (count %) 1) (vals (group-by sort s))))))
hisba's solution:

1
2
3
4
5
6
7
8
(fn anf [w]
 (loop [anags #{} words w]
          (let [{match true remain false} (group-by #(= (set (first words)) (set %)) words)
                new_anags (if (> (count match) 1) (conj anags (set (map #(apply str %) match))) anags)]
            (if (empty? remain)
              new_anags
              (recur new_anags remain)
              ))))
icamts's solution:

1
2
3
4
5
(fn [ws] (->> ws 
              (group-by sort)
              (map #(set (val %)))
              (filter #(< 1 (count %)))
              set))
immo's solution:

1
Scored 124, before 4clojure started saving solutions.
jarlax's solution:

1
2
3
4
5
6
(fn [words]
  (->> (group-by sort words)
       vals
       (filter #(> (count %) 1))
       (map set)
       set))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn test [coll]
  (letfn [(compString [x]
        (fn [y] (if (= (apply sorted-set (seq x)) (apply sorted-set (seq y)))
                true
            false)
        )
        )]
    (loop [coll coll result '()]
        (let [cur (first coll)]
        (cond (empty? coll) (into #{} (filter #(> (count %) 1) result))
              :else (recur (remove (compString cur) coll)
                   (cons (set (filter (compString cur) coll)) result))
        ) 
         )
     )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [ws]
  (let [an? (fn [a b] (apply = (map #(-> % seq sort) [a b])))]
    (loop [current (first ws)
           others (rest ws)
           accum #{}]
      (if (empty? others)
        accum
        (let [{y true n false} (group-by #(an? current %) others)]
          (recur (first n) (rest n)
                 (if (empty? y)
                   accum
                   (conj accum (set (conj y current))))))))))
johncowie's solution:

1
2
3
4
5
6
7
(fn [v]
   (set
    (map
      (fn [m] (set (m 1)))
        (filter
          (fn [e] (> (count (e 1)) 1))
            (group-by #(sort %) v)))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn [words]
  (letfn [(rotate
           [coll]
           (conj (subvec coll 1) (first coll)))
          (rotations
           [coll]
           (take (count coll) (iterate rotate coll)))
          (rotate-and-join
           [coll idx]
           (let [[l r] (split-at idx coll)]
            (map #(concat % r) (rotations (vec l)))))
          (permutations
           [coll]
           (reduce 
            (fn [res idx] 
              (mapcat rotate-and-join res (repeat idx)))
            [coll]
            (range (count coll) 1 -1)))]
     (loop [words (set words)
            result #{}]
       (let [word  (first words)
             chs   (seq word)
             perms (into #{} (map (partial apply str) (permutations chs)))]
         (if (empty? words)
           (clojure.set/select #(> (count %) 1) result)
           (recur
            (clojure.set/difference words perms #{word})
            (conj result (clojure.set/intersection perms words))))))))
jorendorff's solution:

1
2
3
(fn [items]
  (into #{} (filter #(> (count %) 1)
                    (vals (apply merge-with into (map #(hash-map (set %) #{%}) items))))))
jslavin's solution:

1
2
3
4
5
6
7
(fn anagram [coll]
  (let [groups  (group-by identity (map (fn [v] (set v)) coll))]
    (set (for [a groups :when (> (count (second a)) 1)]
      (reduce (fn [acc v] (if (= (set v) (first a)) (conj acc v) acc)) #{} coll) 
      ))
    )
  )
kohyama's solution:

1
2
3
4
5
6
(comp
  set
  (partial map set)
  (partial filter #(< 1 (count %)))
  vals
  (partial group-by sort))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn anagram-finder [www]
 
  ((comp
    set
    (partial map #(set %))
    (partial filter #(> (count %) 1))
    vals 
    (partial reduce
             (fn [a w] 
               (let [k (set w)
                     v (a k)]
                 (if (nil? v)
                   (assoc a k [w])
                   (assoc a k (conj v w))))) {})
 
    ) www))
blucas's solution:

1
2
3
(fn prob77
  [words]
  (into #{} (map set (filter #(> (count %) 1) (map val (group-by sort words))))))
brendan's solution:

1
2
3
4
5
6
(fn [s]
  (->> s
    (group-by #(sort (seq %)))
    (filter #(< 1 (count (second %))))
    (map #(set (second %)))
    (set)))
kuze's solution:

1
2
3
4
5
(fn myAnagramFinder
  [words]
  (let [freqs (zipmap words (map frequencies (map vec words)))
        getTheSame (fn [word mapWithFreqs] (filter #(= word (val %)) mapWithFreqs))]
    (set (filter #(> (count %) 1) (reduce #(conj %1 (set (keys (getTheSame (val %2) freqs)))) #{} freqs)))))
lackita's solution:

1
2
3
(fn [words] 
  (set (map set (filter #(> (count %) 1)
                        (vals (group-by sort words))))))
lambda4fun's solution:

1
2
3
#(set (for [v (vals (group-by sort %))
            :when (> (count v) 1)]
        (set v)))
lasthemy's solution:

1
2
3
(fn [words]
  (set (map set (filter #(> (count %) 1) (vals (group-by sort words)))))
  )
lbarrett's solution:

1
2
3
4
(fn [words]
  (set (filter next
               (map (comp set second)
                    (group-by (partial group-by identity) words)))))
leetwinski's solution:

1
2
3
4
5
6
#(->> %
      (group-by sort)
      vals
      (filter next)
      (map set)
      set)
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
(fn [l] 
  (set
    (filter
      #(< 1 (count %))
        (map set 
          (vals
            (group-by 
              #(sort (seq %))
              l))))))
malvert's solution:

1
#(set (map set (filter (fn [e] (> (count e) 1)) (vals (group-by sort %)))))
matiasl's solution:

1
2
3
4
5
6
7
(fn [words] 
  (set 
   (filter 
    #(< 1 (count %)) 
    (map 
     (comp set val) 
     (group-by frequencies words)))))
maximental's solution:

1
2
3
4
5
6
7
(fn [z]
  (reduce (fn [a s] 
            (#(if (next %) (conj a (set %)) a)
                (re-seq (re-pattern (str "\\b[" s "]{" (count s) "}\\b")) 
                        (apply str (interpose " " z))))) 
          #{}
          z))
mbakhterev's solution:

1
(fn [S] (->> (group-by frequencies S) vals (filter second) (map set) set))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
(fn anagrams
  [coll] {:pre [(every? string? coll)]}
  (->> coll                            ; ["eat" "cat" "ate"]
       (group-by frequencies)          ; {{\e 1, \a 1, \t 1} ["eat" "ate"],
                                       ;  {\c 1, \a 1, \t 1} ["cat"]}
       vals                            ; (["eat" "ate"] ["cat"])
       (remove (comp (partial = 1)     ; (["eat" "ate"])
                     count))
       (map set)                       ; (#{"eat" "ate"})
       set))                           ; #{#{"eat" "ate"}}
mfikes's solution:

1
2
3
4
5
(fn [ws]
  (into #{} (filter #(< 1 (count %))
   (for [w ws]
       (let [s (sort w)]
            (into #{} (filter #(= s (sort %)) ws)))))))
minitrue's solution:

1
2
(fn [xs]
  (->> xs (group-by sort) vals (filter #(> (count %) 1)) (map set) set))
mkahn's solution:

1
2
3
4
(fn anagrams [x]
"Assumes the input is all lowercase."
     (set (map set (filter #(> (count %) 1) (vals (group-by sort 
                                                            x))))))
mobiusloop's solution:

1
2
3
(fn [l]
(set (map set (filter #(< 1 (count %)) (vals (group-by sort l)))))
)
mononite's solution:

1
2
3
4
5
6
(fn [xs] 
  (->> (group-by #(set %) xs)
       vals
       (filter #(> (count %) 1))
       (map set)
       set))
mouse's solution:

1
#(set (for [[_ [_ c :as v]] (group-by sort %) :when c] (set v)))
mwaldowski's solution:

1
2
3
4
5
6
7
(fn [coll]
  (->>
   (map #(hash-map (set %) #{%}) coll)
   (reduce #(merge-with clojure.set/union %1 %2) {})
   vals
   set
   (clojure.set/select #(> (count %) 1))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [words]
  (let [fingerprints (map (comp sort #(map identity %)) words)
        word+fingerprints (map #(list %1 %2) words fingerprints)
        grouped (reduce
                 (fn [memo w]
                   (let [word (first w)
                         fingerprint (last w)]
                     (assoc memo fingerprint (conj (memo fingerprint #{}) word))))
                 {}
                 word+fingerprints
                 )]
    (set (filter #(> (count %) 1) (vals grouped)))))
nikelandjelo's solution:

1
2
3
4
5
(fn [s] (->> (group-by #(sort (seq %)) s)
                   (vals)
                   (remove #(= 1 (count %)))
                   (map set)
                   (set)))
noiseehc's solution:

1
(fn [x] (set (map set (filter #(>= (count %) 2) (vals (group-by sort x))))))
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [words]
  (let [anagram-set
        (loop [anagrams {}
               all-words words]
          (let [current-word (first all-words)
            remaining-words (rest all-words)]
            (if (empty? all-words)
              anagrams
              (recur (merge-with into anagrams
                                 {(sort current-word) #{current-word}})
                     remaining-words))))]
    (set (filter #(> (count %) 1) (vals anagram-set)))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
(fn [ls]
  (->>
   ls
   (group-by #(sort %))
   (vals)
   (filter #(> (count %) 1))
   (map set)
   (set)))
owk4057's solution:

1
2
3
4
5
6
(fn [coll]
  (->> (group-by set coll)
    vals
    (filter #(> (count %) 1))
    (map #(apply hash-set %))
    (apply hash-set)))
ownwaterloo's solution:

1
2
3
4
5
6
(fn [xs]
  (->> (group-by set xs)
    vals
    (filter #(not (empty? (rest %))))
    (map set)
    set))
ozan's solution:

1
2
3
4
5
6
7
(fn anagrams [words]                                                                                                                                                                                                                     
   (->> words                                                                                                                                                                                                                               
        (group-by sort)                                                                                                                                                                                                                     
        (vals)                                                                                                                                                                                                                              
        (filter #(> (count %) 1))                                                                                                                                                                                                           
        (map set)                                                                                                                                                                                                                           
        (set)))
pukeface's solution:

1
2
3
4
5
6
#(->> %
       (group-by frequencies)
       (vals)
       (filter (fn [s] (> (count s) 1)))
       (map set)
       (set))
quant1's solution:

1
#(->> % (group-by sort) vals (filter second) (map set) set)
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
(fn [words]
    (->>
     words
     (group-by set)
     vals
     (remove #(= 1 (count %)))
     (map set)
     set
     )
  )
sbondaryev's solution:

1
2
3
4
5
6
(fn f[xs]
  (->> (group-by sort xs)
       (vals)
       (filter #(> (count %) 1))
       (map set)
       (set)))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn anag [coll]
  (reduce #(conj %1 %2) #{}
          (filter
           #(> (count %) 1)
           (vals 
            ((fn to-map [coll] 
               (reduce 
                (fn [m n]
                  (let [k (apply conj #{} n)] 
                    (assoc m k (conj (get m k #{}) n)))) 
                {} 
                coll)) 
             coll)))))
sheldon's solution:

1
(fn [s] (set (map set (vals (filter #(next (second %)) (group-by frequencies s))))))
silverio's solution:

1
2
3
(fn [w] (->> w (group-by sort) vals
  (filter #(> (count %) 1))
  (map set) set))
skyrem's solution:

1
2
3
4
5
6
7
8
9
(fn [coll]
  (let [pk (filter #(< 1 (count %)) 
                   (partition-by #(val %) 
                                 (sort-by #(val %) 
                                          (zipmap (range) (map (comp #(apply str %) sort seq) coll)))))]
    (apply conj #{} 
           (for [i pk] 
             (apply conj #{}
                    (for [j i] (nth coll (key j))))))))
soul_awaker's solution:

1
2
3
4
5
6
7
(fn f [i [h & t :as s]]
  (if (nil? h)
      i
      (let [fit (set (filter #(= (set h) (set %)) t))]
        (recur (if (seq fit) `#{~@i #{~@fit ~h}} i)
          (vec (clojure.set/difference (set t) fit))))))
 #{}
staafl2's solution:

1
(fn [words] (set (filter #(< 1 (count %)) (set (map (comp set val) (group-by frequencies words))))))
syeerzy's solution:

1
#(set (for [[k v] (group-by set %) :when (next v)] (set v)))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
#(->> (group-by sort %)
      vals
      (filter (comp pos? dec count))
      (map set)
      set)
;
;(fn [words]
;  (set
;   (filter #(< 1 (count %))
;           (mapv set
;                 (vals
;                  (group-by sort words))))))
thegeez's solution:

1
2
3
4
5
6
7
(fn [words]
    (->> words
         (group-by sort)
         vals
         (map set)
         (filter #(< 1 (count %)))
         set))
zzamboni's solution:

1
2
3
4
5
6
(fn anagrams [s]
  (->> s
       (group-by sort)
       (vals)
       (filter #(< 1 (count %)))
       (map set) set))
zoltanjarai's solution:

1
2
3
4
5
6
(fn __ [s]
  (->> (group-by sort s)
       (map val)
       (filter #(< 1 (count %)))
       (map set)
       (set)))
zipzop's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn af
  ([s] (af (first s) (set (rest s)) #{}))
  ([w s acc]
    (if (empty? s)
        acc
     (let [ana (set (filter #(= (sort w) (sort %)) s))
           rst (clojure.set/difference s ana)]
     (if (empty? ana)
        (af (first s) (set (rest s)) acc)
        (af (first rst) (set (rest rst)) (conj acc (conj ana w)))
      ))
      )
   )
)
yusubori's solution:

1
(fn [ws] (set (map set (filter #(< 1 (count %)) (vals (group-by set ws))))))
ydash's solution:

1
2
3
4
5
6
7
;(fn [s]
;  (reduce #(if (next %2) (conj % (set %2)) %)
;          #{}
;          (vals (group-by sort s))))
(fn [s]
  (set (keep #(if (next %) (set %))
             (vals (group-by sort s)))))
vpeurala's solution:

1
(fn anagrams [xs] (set (map set (filter #(> (count %) 1) (vals (group-by #(sort %) xs))))))
v_bogdanov's solution:

1
#(set (filter second (map set (vals (group-by sort %)))))
unionx's solution:

1
2
3
4
5
6
7
8
9
(fn [v]
  (let [res (loop [ret {} lft v]
              (if (empty? lft)
                ret
                (let [elt (first lft)
                      m-v (ret (sort elt) #{})]
                  (recur (assoc ret (sort elt) (conj m-v elt))
                         (rest lft)))))]
    (set (remove #(= 1 (count %)) (vals res)))))
trxeste's solution:

1
2
3
(fn [ws] 
  (set (map (comp set val) 
            (remove (comp #{1} count val) (group-by frequencies ws)))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
(fn [words]
  (let [ana? (fn [ & words]
                (if (reduce = (map count words))
                  (reduce = (map sort words))
                  false) )]
    (set
     (filter #(not= 1 (count %))
             (for [word words]
               (set (filter #(ana? word %) words)))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)