118 Re-implement Map
Special Restrictions: map, map-indexed, mapcat, for

Takes a func and a seq, returns a lazy seq of (f x) for each element

(= [3 4 5 6 7]
   (__ inc [2 3 4 5 6]))
(= (repeat 10 nil)
   (__ (fn [_] nil) (range 10)))
(= [1000000 1000001]
   (->> (__ inc (range)) (drop (dec 1000000)) (take 2)))

(fn collect [f [fs & rs]]
  (lazy-seq (if (nil? fs)
               nil
              (cons (f fs) (collect f rs)))))

(fn ff [f xs]
  (if (empty? xs)
    xs
    (lazy-seq (cons (f (first xs)) (ff f (drop 1 xs))))))

(fn ff [f s]
  (if (not (empty? s))
      (lazy-seq (cons (f (first s)) (ff f (rest s))))))

(fn myMap [func coll]
  (lazy-seq (if (seq coll)
      (cons (func (first coll)) (myMap func (rest coll))))))

(fn map2 [f xs]
  (lazy-seq (when-let [s (seq xs)]
      (cons (f (first s)) (map2 f (rest s))))))

aceeca1's solution:

1
(fn [f x] (rest (reductions #(f %2) nil x)))
adereth's solution:

1
#(reductions (fn [acc x] (%1 x)) (%1 (first %2)) (rest %2))
aferrandi's solution:

1
2
3
4
5
6
(fn mapRec [p x]
    (if (empty? x)
        []
        (lazy-seq (cons (p (first x)) (mapRec p (rest x))))
    )
)
aguirre's solution:

1
2
3
(fn mapper [fun xs]
     (if(empty? xs) []
       (lazy-cat [(fun (first xs))] (mapper fun (rest xs)))))
alanforr's solution:

1
2
3
4
5
6
7
(fn [g y]
  (letfn [(exmap
           ([f x]
            (lazy-seq
             (when-let [thing (seq x)]
               (cons (f (first thing)) (exmap f (rest thing)))))))]
    (exmap g y)))
allenl's solution:

1
2
3
4
(fn mymap [f col]
  (lazy-seq
   (when col
     (cons (f (first col)) (mymap f (next col))))))
andthorn's solution:

1
2
3
4
(fn me [f l]
  (if (next l)
    (cons (f (first l)) (lazy-seq (me f (next l))))
    (vector(if l (f (first l))))))
anjensan's solution:

1
2
3
(fn m [f c]
    (when-let [[a & b] c]
      (lazy-seq (cons (f a) (m f b)))))
astangl's solution:

1
2
3
4
5
6
7
(fn
  [f coll]
  (letfn [(r [coll] (lazy-seq
                      (if coll
                          (cons (f (first coll)) (r (next coll)))
                          '())))]
         (r coll)))
austintaylor's solution:

1
2
3
4
5
6
(fn [f s]
  (letfn [(m [s] 
    (if (empty? s)
      '()
      (lazy-seq (cons (f (first s)) (m (rest s))))))]
    (m s)))
awebb's solution:

1
2
(fn m [f [s & r]]
  (when s (cons (f s) (lazy-seq (m f r)))))
bendykst's solution:

1
2
3
4
5
6
7
(fn mp [f [arg & args]]
  (if 
    (empty? args)
    (list (f arg))
    (cons
      (f arg)
      (lazy-seq (mp f args)))))
benhammond's solution:

1
2
(fn m [f [x & xs]]
    (if x (lazy-seq (cons (f x) (m f xs)))))
benizi's solution:

1
2
3
4
(fn m [f s]
  (when (seq s)
    (cons (f (first s))
          (lazy-seq (m f (next s))))))
bobuhiro11's solution:

1
2
3
4
5
(fn mymap [f col]
  (if (empty? col)
    col
    (cons (f (first col))
          (lazy-seq (mymap f (rest col))))))
burner's solution:

1
2
3
4
(fn mymap [f s]
  (if (empty? s) ()
  (lazy-seq (cons (f (first s))
                  (mymap f (rest s))))))
caterpillar's solution:

1
2
3
(fn myMap [f s]
  (when (first s)
  (cons (f (first s)) (lazy-seq (myMap f (rest s))))))
cc787's solution:

1
2
3
4
5
(fn ! [f args]
   (if (empty? args)
     nil
     (lazy-seq (cons (f (first args)) (! f (rest args)))))
   )
chunchangshao's solution:

1
(fn g [f xs] (lazy-seq (if (empty? xs) [] (concat (vector (f (first xs))) (g f (rest xs))))))
ctzsm's solution:

1
2
3
(fn m [f coll]
  (lazy-seq
    (when-let [s (seq coll)] (cons (f (first s)) (m f (rest s)) ))))
dan7es's solution:

1
2
3
4
(fn fmap [f xs]
  (lazy-seq
   (if-let [[x & xs] (seq xs)]
     (cons (f x) (fmap f xs)))))
daniels's solution:

1
2
3
4
5
6
(fn tmp [f x] 
  (if (nil? x)
    nil
    (cons (f (first x)) (lazy-seq (tmp f (next x))))
;    (cons (f (first x)) nil)
    ))
daowen's solution:

1
2
3
(fn my-map [f xs]
  (if (empty? xs) nil
    (lazy-seq (cons (f (first xs)) (my-map f (rest xs))))))
del680202's solution:

1
2
3
(fn mymap [f coll]
 (when-let [c coll]
 (cons (f (first c)) (lazy-seq (mymap f  (next c))))))
deping's solution:

1
2
3
4
(fn mymap [f l]
  (if (empty? l) []
    (cons (f (first l)) (lazy-seq (mymap f (rest l))))
    ))
devm33's solution:

1
2
3
4
(fn my-map [f s]
  (when-let [xs (seq s)]
    (cons (f (first xs))
          (lazy-seq (my-map f (next xs))))))
dwelte's solution:

1
2
3
4
(fn nmap [f xs]
  (if (empty? xs)
    '()
    (lazy-seq (cons (f (first xs)) (nmap f (rest xs))))))
dzholev's solution:

1
(fn [f coll] (rest (reductions #(f %2) nil coll)))
echevarria's solution:

1
2
3
4
5
(fn my-map [ f [ a & xs] ]
    (if (nil? a)
        nil
        (cons (f a) (lazy-seq (my-map f xs))))
)
ericw's solution:

1
2
3
4
(fn m [f c]                                                                                                                     
    (if (empty? c)                                                                                                                                      
        '()                                                                                                                     
        (cons (f (first c)) (lazy-seq (m f (rest c))))))
featalion's solution:

1
2
(fn mymap [f coll]
  (lazy-seq (when (seq coll) (cons (f (first coll)) (mymap f (rest coll))))))
finsternis's solution:

1
2
3
(fn mymap [f [x & xs]]
  (when x
    (lazy-seq (cons (f x) (mymap f xs)))))
flububb's solution:

1
2
(fn _map [f [a & r]] 
  (if a (cons (f a) (lazy-seq (_map f r))) nil))
garyxia's solution:

1
2
3
4
(fn mymap [f coll]
  (if (false? (empty? coll))
        (lazy-seq
          (cons (f (first coll)) (mymap f (rest coll))))))
geekerzp's solution:

1
2
3
4
(fn mp [f s]
    (if (empty? s)
      nil
      (lazy-seq (cons (f (first s)) (mp f (rest s))))))
glchapman's solution:

1
(fn mymap [f coll] (lazy-seq (when (seq coll) (cons (f (first coll)) (mymap f (rest coll))))))
goaranger's solution:

1
(fn mymap [f x] (if (not-empty x) (lazy-seq (cons (f (first x)) (mymap f (rest x))))))
gpittarelli's solution:

1
2
3
4
(fn map' [f in-seq]
  (if (empty? in-seq)
    ()
    (cons (f (first in-seq)) (lazy-seq (map' f (rest in-seq))))))
happycrisis's solution:

1
2
3
(fn my-map [f s]  (lazy-seq (when (not (empty? s)) 
                              (cons (f (first s))
                                    (my-map f (rest s))))))
hisba's solution:

1
2
(fn mmap [f s]
  (lazy-cat [(f (first s))] (when (second s) (mmap f (rest s)))))
icamts's solution:

1
(fn lazy-map [f s] (if (next s) (cons (f (first s)) (lazy-seq (lazy-map f (next s)))) (list (f (first s)))))
immo's solution:

1
2
3
(fn m [f s]
  (when s
    (cons (f (first s)) (lazy-seq (m f (next s))))))
jarlax's solution:

1
2
3
4
(fn m [f coll]
  (if (not-empty coll)
    (cons (f (first coll))                   
          (lazy-seq (m f (rest coll))))))
jedo's solution:

1
2
3
4
5
(fn remap [f vals]
  (cond (empty? vals) vals
        :else (cons (f (first vals)) (lazy-seq (remap f (rest vals))))
  )
)
jeff_terrell's solution:

1
2
3
4
5
(fn map2 [f s]
  (if (empty? s)
    nil
    (cons (f (first s))
          (lazy-seq (map2 f (rest s))))))
johncowie's solution:

1
2
3
4
5
(fn m
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (cons (f (first s)) (m f (rest s)))))))
jomicoll's solution:

1
2
3
4
(fn map* [f coll]
  (lazy-seq
   (when-not (empty? coll)
    (cons (f (first coll)) (map* f (rest coll))))))
jorendorff's solution:

1
2
3
4
5
6
(fn qq [f s]
  (lazy-seq
    (if (empty? s)
      '()
      (cons (f (first s))
            (qq f (rest s))))))
jslavin's solution:

1
2
3
4
5
(fn mymap
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (cons (f (first s)) (mymap f (rest s)))))))
kohyama's solution:

1
2
(fn mp [f [x & xs]]
  (if x (cons (f x) (lazy-seq (mp f xs)))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn re-implement-map [f c]
  (let [sq (seq c)]
    (if (chunked-seq? sq)
 
      (lazy-seq (cons (f (first sq)) (re-implement-map f (rest sq))))
 
      (reduce 
   
       (fn [a x]
         (conj a (f x)))
       
       (empty c)
       c))))
blucas's solution:

1
2
3
4
5
(fn prob118 [f col]
  ;; return a lazy seq with f applied to each item in col
  (if (empty? col)
    nil
    (lazy-seq (cons (f (first col)) (prob118 f (rest col))))))
brendan's solution:

1
2
(fn mp [f [x & xs]] 
   (if x (lazy-seq (cons (f x) (mp f xs)))))
kuze's solution:

1
2
3
4
5
(fn my-re-implement-map
  [fun coll]
  (when (not (empty? coll))
    (lazy-seq
      (cons (fun (first coll)) (my-re-implement-map fun (rest coll))))))
lackita's solution:

1
2
3
4
5
(fn mp [f s]
  (if (empty? s)
    []
    (cons (f (first s))
          (lazy-seq (mp f (rest s))))))
lambda4fun's solution:

1
2
3
(fn map' [f xs]
  (when (seq xs)
    (lazy-seq (cons (f (first xs)) (map' f (rest xs))))))
lasthemy's solution:

1
2
3
4
5
(fn mymap [pred coll]
  (if (seq coll)
    (lazy-seq (cons (pred (first coll)) (mymap pred (rest coll))))
    )
  )
lbarrett's solution:

1
2
3
4
5
(fn m [f vs]
  (lazy-seq
   (if (empty? vs) '()
     (cons (f (first vs))
           (m f (rest vs))))))
leetwinski's solution:

1
2
3
4
(fn m [f ls]
  (if (empty? ls) 
    ls
    (lazy-seq (cons (f (first ls)) (m f (rest ls))))))
littlejp2046's solution:

1
2
3
4
(fn mp [f l]
  (if (empty? l)
    l
    (cons (f (first l)) (lazy-seq (mp f (rest l))))))
malvert's solution:

1
2
3
4
5
(letfn [(g [f s] 
  (if (empty? s) 
    [] 
    (lazy-seq (cons (f (first s)) (g f (rest s))))))]
  g)
matiasl's solution:

1
2
3
4
5
(fn mp [f sq] 
  (lazy-seq 
   (when-let [[x & more] (seq sq)] 
     (cons (f x) 
           (mp f more)))))
maximental's solution:

1
2
3
4
(fn m [f [h & t :as v]] 
  (if (empty? v)
      ()
      (lazy-seq (cons (f h) (m f t)))))
mbakhterev's solution:

1
(fn M [f S] (if-let [[s & rs] S] (cons (f s) (lazy-seq (M f rs)))))
meerwolf's solution:

1
2
3
4
5
(fn my-map
  [f [x & more :as coll]] {:pre [(ifn? f)]}
  (if (seq coll)
    (lazy-seq (cons (f x) (my-map f more)))
    '()))
mfikes's solution:

1
2
3
4
(fn mymap [f coll] 
  (if (empty? coll) 
    '() 
    (lazy-cat (list (f (first coll))) (mymap f (rest coll)))))
minitrue's solution:

1
2
3
4
5
(fn -map [f [x & xs]]
  (if x
    (cons (f x)
      (lazy-seq (-map f xs)))
    ()))
mkahn's solution:

1
2
3
4
(fn newmap [f x]
     (if (empty? x)
       '()
       (lazy-seq (cons (f (first x)) (newmap f (rest x))))))
mobiusloop's solution:

1
2
3
(fn x [f l]
  (lazy-seq (if (empty? l) l (cons (f (first l)) (x f (rest l)))))
  )
mononite's solution:

1
2
3
4
(fn my-map [f xs]
   (lazy-seq
    (when-let [s (seq xs)]
      (cons (f (first s)) (my-map f (rest s))))))
mouse's solution:

1
(fn m [ f [x & xs]] (lazy-seq (cons (f x) (if (nil? xs) nil (m f xs)))))
mwaldowski's solution:

1
2
3
4
5
(fn my-map [f coll]
  (if (empty? coll)
    '()
    (cons (f (first coll))
          (lazy-seq (my-map f (rest coll))))))
nagi's solution:

1
2
3
4
(fn mm [f xs]
  (if (empty? xs)
    '()
    (lazy-seq (cons (f (first xs)) (mm f (rest xs))))))
nikelandjelo's solution:

1
2
3
4
(fn my-map [f v]
  (if (empty? v)
    []
    (lazy-cat [(f (first v))] (my-map f (rest v)))))
noiseehc's solution:

1
(fn m [f s] (if (not-empty s) (cons (f (first s)) (lazy-seq (m f (rest s)))) '()))
norman's solution:

1
2
3
(fn m [f vals]
  (when (seq vals)
    (lazy-seq (cons (f (first vals)) (m f (rest vals))))))
nothsaevets's solution:

1
2
3
4
5
(fn map* [f x]
   (let [h (first x)
         r (rest x)]
     (if h
       (cons (f h) (lazy-seq (map* f r))))))
owk4057's solution:

1
2
3
4
(fn map- [f coll] 
  (lazy-seq 
    (when-let [s (seq coll)] 
      (cons (f (first s)) (map- f (rest s))))))
ownwaterloo's solution:

1
2
3
(fn [f xs]
  (if (not-empty xs)
    (drop 1 (reductions #(f %2) (first xs) xs))))
ozan's solution:

1
2
3
4
(fn lazy-map [f xs]
  (lazy-seq
   (if (seq xs)
       (cons (f (first xs)) (lazy-map f (rest xs))))))
pukeface's solution:

1
2
3
4
(fn m [f [s & R]]
  (if s
    (cons (f s)
          (lazy-seq (m f R)))))
quant1's solution:

1
(fn p118 [f [s1 & s]] (if (nil? s1) () (lazy-seq (cons (f s1) (p118 f s)))))
rodmax's solution:

1
2
(fn mmap [fcn [f & r]] 
  (if f (cons (fcn f) (lazy-seq (mmap fcn r)))))
sbondaryev's solution:

1
2
(fn my-map [pred [fst & rst :as xs]]
  (lazy-seq (when (seq xs) (cons (pred fst) (my-map pred rst)))))
shiro's solution:

1
2
3
4
5
6
(fn my-map [pred coll]
  (let [step (fn [p c]
                 (when-let [s (seq c)] ; when (seq c) is true, let s = (seq c), else return nil
                   (cons (pred (first s)) 
                         (my-map p (rest s)))))]
    (lazy-seq (step pred coll))))
sheldon's solution:

1
(fn m [f c] (if (empty? c) [] (lazy-seq (cons (f (first c)) (m f (rest c))))))
silverio's solution:

1
2
3
(fn m [f s] (if (seq s) 
  (lazy-seq (cons (f (first s)) (m f (rest s)))) 
  nil))
skyrem's solution:

1
2
3
4
(fn mymap [f coll]
  (if (chunked-seq? (seq coll))
    (lazy-cat [(f (first coll))] (mymap f (rest coll)))
    (loop [p coll r []] (if (empty? p) (reverse r) (recur (rest p) (concat [(f (first p))] r))))))
soul_awaker's solution:

1
2
3
4
5
(fn re-map [f col]
    (if (empty? col)
      '()
      (lazy-seq
        (cons (f (first col)) (re-map f (rest col))))))
staafl2's solution:

1
2
3
(fn map2 [f xs]
  (if (empty? xs) ()
    (lazy-seq (cons (f (first xs)) (map2 f (rest xs))))))
syeerzy's solution:

1
2
3
(fn m [f col]
  (lazy-seq (if-let [s (seq col)]
    (cons (f (first s)) (m f (rest s))))))
tclamb's solution:

1
(fn map' [f s] (lazy-seq (when-let [x (first s)] (cons (f x) (map' f (rest s))))))
thegeez's solution:

1
2
3
4
(fn r [f c]
  (lazy-seq 
    (when-let [[h & t] (seq c)]
      (cons (f h) (r f t)))))
zzamboni's solution:

1
2
(fn my-map [f s]
  (reductions #(f %2) (f (first s)) (rest s)))
zoltanjarai's solution:

1
2
3
4
(fn __ [f s]
  (if (empty? s) '()
    (cons (f (first s))
          (lazy-seq (__ f (rest s))))))
zipzop's solution:

1
2
3
4
(fn m
  ([f s] 
     (if (empty? s) []
       (lazy-seq (cons (f (first s)) (m f (rest s)))))))
yusubori's solution:

1
2
3
(fn my-map [f [x & xs]]
  (if x
    (lazy-seq (cons (f x) (my-map f xs)))))
ydash's solution:

1
2
3
(fn m [f [h & r]]
  (if h
    (lazy-seq (cons (f h) (m f r)))))
vpeurala's solution:

1
(fn my-map [f s] (if (empty? s) [] (cons (f (first s)) (lazy-seq (my-map f (rest s))))))
v_bogdanov's solution:

1
2
3
(fn mp [f s]
  (when (seq s)
  (cons (f (first s)) (lazy-seq (mp f (rest s))))))
unionx's solution:

1
2
3
4
5
(fn m [f coll]
  (if (empty? coll)
    []
    (concat (vector (f (first coll)))
            (lazy-seq (m f (rest coll))))))
trxeste's solution:

1
2
3
4
(fn map- [f coll] 
  (lazy-seq 
    (when-let [s (seq coll)] 
      (cons (f (first s)) (map- f (rest s))))))
transfinite's solution:

1
2
3
4
5
(fn r [f xs]
  (lazy-seq
    (if (empty? xs)
    '()
    (cons (f (first xs)) (r f (rest xs))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)