;; 65 Black Box Testing [m]

The seq types act in subtly different ways.
The core functions typically convert them into
a uniform "sequence" type and work with them that way,
but it can be important to understand
the behavioral and performance differences
so you know which kind is appropriate for your application.

This func takes a coll and returns one of
:map, :set, :list, or :vector -
describing the type of coll it was given.
It does not inspect their class
or use the built-in predicates like list? -
it pokes at them to understand their behavior.
Works like class, type, Class, vector?
sequential? list? seq? map? set? instance? getClass

(= :map (__ {:a 1, :b 2}))
(= :list (__ (range (rand-int 20))))
(= :vector (__ [1 2 3 4 5 6]))
(= :set (__ #{10 (rand-int 5)}))
(= [:map :set :vector :list] (map __ [{} #{} [] ()]))

(fn [c]
  (let [d (conj c {0 1} {0 2} {0 1})]
    (cond
      (= (+ 1 (count c)) (count d)) :map
      (= (+ 2 (count c)) (count d)) :set
      (= (cons {0 3} d) (conj d {0 3})) :list
      true :vector)))

(fn [c] (let [d (conj c {0 1} {0 2} {0 1})] (cond (= 
(+ 1 (count c)) (count d)) :map (= (+ 2 (count c)) (count d)) :set (= (cons 
{0 3} d) (conj d {0 3})) :list true :vector)))

(fn [col]
   (let [x (gensym)
         y (gensym)
         map-col (into col [[x y]])
         n-col #(into col [x y])
         ]
     (cond
       (= y (x map-col)) :map
       (= (count (n-col)) (-> (into (n-col) [x]) count)) :set
       (= (first (n-col)) y) :list
       :else :vector)))

#(let [r (str %)]
   (if (.contains r "#")
     :set
       (if (.contains r "{")
         :map
         (if (.contains r "[")
           :vector
           :list))))

#(if (= % (merge % %)) :map
   (let [extended (conj % :first :second)]
     (cond
      (= extended (into extended extended)) :set
      (= (first extended) :second) :list
      :else :vector)))

#(if
  (and (associative? %) (< 1 (count (flatten (list (last (seq (assoc % 0 1))))))) ) :map
  (let [c (conj % :a :b :c)]
    (cond 
      (= (take-last 3 c) [:a :b :c]) :vector
      (= (take      3 c) [:c :b :a]) :list
      true :set)))
aceeca1's solution:

1
(comp #(cond (= % {}) :map (= % #{}) :set (= (conj % 1 2) [1 2]) :vector true :list) empty)
adereth's solution:

1
2
3
4
5
#(condp = (nth (str %) 0)
   \{ :map
   \c :list
   \[ :vector
   \# :set)
aferrandi's solution:

1
(fn typeX [x] (let [s (str x)] (case (first s) \{ :map \[ :vector \# :set :list)))
aguirre's solution:

1
2
3
4
5
6
7
8
9
(fn [col]
     (let [testCol (into (empty col) [[1 2] [1 2]])
           testColCount (count testCol)]
       (cond
         (= 1 testColCount) (cond 
                              (= (testCol 1) 2) :map
                              :else :set)
         (= :v (first (conj testCol :v))) :list
         :else :vector)))
alanforr's solution:

1
2
3
4
5
6
(fn [a]
  (let [base (empty a)]
    (cond
     (= base {}) :map
     (= base #{}) :set
     (= base '()) (if (reversible? a) :vector :list))))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [coll]
    (let [temp1 [:c 3]
          temp2 [:c 3]
          temp3 [:c 4]
          coll2 (conj coll temp1 temp2 temp3)]
      (pr coll2)
      (cond
        (= (count coll) (- (count coll2) 1)) :map
        (= (count coll) (- (count coll2) 2)) :set
        (= (first coll2) temp3) :list
        :else :vector)))
andthorn's solution:

1
2
3
4
5
6
7
#(if (= 0 (get (conj % [0 0]) 0))
   :map
   (if (= (conj (conj % 42) 42) (conj % 42))
     :set
     (if (zero? (first (conj % 1 0)))
      :list
      :vector)))
anjensan's solution:

1
2
3
4
(fn [x]
  (let [z (into x [[x 1] [x x] [x 1] [x x]])]
    ({1 :map 2 :set 4 (if (= [x x] (first z)) :list :vector)}
      (- (count z) (count x)))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn
  [coll]
  (let [size (.size coll)
        newsym (gensym)
        newsym' (gensym)
        coll2 (conj coll [newsym newsym'])]
    (cond
      (get coll2 newsym) :map
      (= (inc size) (.size (conj (conj coll newsym) newsym))) :set
      (= newsym' (last (conj (conj coll newsym) newsym'))) :vector
      :else :list)))
austintaylor's solution:

1
(comp {\# :set \{ :map \[ :vector \c :list} first str)
awebb's solution:

1
2
3
4
5
6
(fn [bb] 
  (let [u1 (fn), u2 (fn), test (conj bb [u1 u2] [u1 u2] [u1 u1])]
    (cond (= (-> test count) (-> bb count inc)) :map
          (= (-> test count) (-> bb count inc inc)) :set
          (= (last test) [u1 u1]) :vector
          :else :list)))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [item]
  (cond
    (= (conj item [:test 0] [:test 1])
       (conj item [:test 1]))
      :map
    (= (conj item [:test 0])
       (conj item [:test 0] [:test 0]))
      :set
    (= (last (conj item :test :test2))
       :test2)
      :vector
    :else
      :list))
benhammond's solution:

1
2
3
4
5
(fn [x] (cond
            (= {} (empty x)) :map
            (= #{} (empty x)) :set
            (= :a (first (into (empty x) '(:a :b)))) :vector
            :else :list))
benizi's solution:

1
2
3
4
5
6
(fn [thing]
  (let [one (conj (empty thing) [:c 4])]
    (condp = one
      {:c 4} :map
      [[:c 4]] (if (= [1 2] (conj (empty thing) 1 2)) :vector :list)
      #{[:c 4]} :set)))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
(fn p [s]
  (cond
    (= (first (.toString s)) \[) :vector
    (= (first (.toString s)) \() :list
    (= (first (.toString s)) \c) :list
    (= (first (.toString s)) \#) :set
    (= (first (.toString s)) \{) :map
    ))
burner's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s] 
  (let [s2 (conj s [1 2])]
    (if (= (count (conj s2 [1 2])) (count s2))
      (if (= (count (conj s2 [1 (gensym)])) (count s2))
             :map
             :set)
      (let [sym (gensym)]
      (if (= (first (conj s2 sym)) sym)
        :list
        :vector)))))
caterpillar's solution:

1
2
3
4
5
6
#(cond
  (= % (merge % %)) :map
  (= (conj % nil) (clojure.set/union (conj % nil) (conj % nil))) :set
  (= :again (first (conj % :test :again))) :list
  :else :vector
  )
cc787's solution:

1
2
3
#(->> % empty str first {\[ :vector \# :set \{ :map \c :list })
; infact here is a bug for :list, which can be \( in clojure 1.8.0.
; c for "clojure.lang.PersistentList$XXXXXXXX" in clojure 1.4.0
chunchangshao's solution:

1
2
3
4
5
6
(fn [coll]
  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]
    (if (= 1 (count result))
      :map (if (= 2 (count result))
             :set (if (= [1 3] (first result))
                    :list :vector )))))
ctzsm's solution:

1
2
3
4
5
#(let [c (first (str %))]
  (cond (= c \#) :set
        (= c \{) :map
        (= c \[) :vector
        :else :list))
dan7es's solution:

1
2
3
4
5
#(let [e (empty %)]
   (case e
     {}  :map
     #{} :set
     (first (conj e :vector :list))))
daniels's solution:

1
2
3
4
5
6
7
8
#(let [a (conj (conj % [:b 2]) [:a 2])]
  (if (== (count a) (count (conj a [:a 2])))  
      (if (and (not (nil? (:a a))) (== 2 (:a a))) 
        :map
        :set)
    (if (= [:a 2] (last a)) 
          :vector 
          :list)))
daowen's solution:

1
2
3
(fn [coll]
  (condp #(contains? %2 %) (conj (empty coll) '[a b])
    0 :vector, 'a :map, '[a b] :set, :list))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
(fn [seq]
  (let [seq_len (count seq)]
    (if (= seq_len (count (conj seq seq))) :map
     (if (= (inc seq_len) (count (conj seq seq seq))) :set
       (if (= seq (first (conj seq 1 seq))) :list
       :vector)
     )
    )
  )
)
deping's solution:

1
2
3
#(if (reversible? %) :vector 
   (if (associative? %) :map
     (if (= (set %) %) :set :list)))
devm33's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [x]
      (second
        (first
          (filter
            #(. (first %) (isInstance x))
            {
             clojure.lang.LazySeq :list
             clojure.lang.IPersistentList :list
             clojure.lang.IPersistentMap :map
             clojure.lang.PersistentVector :vector
             clojure.lang.IPersistentSet :set
             }))))
dwelte's solution:

1
2
3
4
5
6
(fn [c]
  (cond
    (= (:d (conj c [:d :e])) :e) :map
    (= (:d (conj c :d)) :d) :set
    (= (last (into c [:d :e])) :e) :vector
    :else :list))
dzholev's solution:

1
(comp {\# :set \{ :map \[ :vector \c :list} first str)
echevarria's solution:

1
2
3
4
5
6
7
8
9
(fn [ coll ]
   (let [ f2 (conj (empty coll) [0 1] [0 1])]
         (if (= (count f2) 1)
            (if (= (count (conj f2 [0 2])) 1)
                :map
                :set)
            (if (first (conj f2 false)) 
                :vector
                :list))))
ericw's solution:

1
2
3
4
5
6
7
(fn my-type [x]                                                                                                                                         
    (cond                                                                                                                       
        (reversible? x)  :vector                                                                                                                        
        (associative? x) :map                                                                                                   
        (= (- (count (into x [:a :a])) (count x)) 2) :list                                                                                              
        :else            :set                                                                                                   
        ))
featalion's solution:

1
2
3
4
5
6
7
8
(fn [coll]
  (if (reversible? coll)
    :vector
    (let [empty-coll (empty coll)]
      (cond
       (= empty-coll #{}) :set
       (= empty-coll {}) :map
       :else :list))))
finsternis's solution:

1
2
3
4
5
6
7
(fn [s]
  (let [e (conj (empty s) [0 0] [0 1] [0 1])]
    (cond
     (= (count e) 1) :map
     (= (count e) 2) :set
     (= (first e) [0 1]) :list
     :else :vector)))
flububb's solution:

1
2
3
4
5
(fn test_type [c]
  (case (empty c)
    {} :map
    #{} :set
    (if (= (first (conj (conj c 23) 42)) 42) :list :vector)))
garyxia's solution:

1
#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))
geekerzp's solution:

1
2
3
4
5
6
7
(fn [coll]
    (let [base (empty coll)]
      (cond
        (= base {}) :map
        (= base #{}) :set
        (reversible? base) :vector
        (= base '()) :list)))
glchapman's solution:

1
2
3
4
5
6
7
8
(fn bbtest [item]
    (let [sitem (pr-str item)]
        (cond
            (.startsWith sitem "{") :map
            (.startsWith sitem "(") :list
            (.startsWith sitem "[") :vector
            (.startsWith sitem "#{") :set
        )))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn ttest [m]
  (let [settv (conj m (first m))
        velt (conj m [2 400] [1 200])
        maptv (conj m (conj m [:tester 1]) [:tester 2])]
      (if (or (= (inc (count m)) (count maptv)) (= m {}))
      :map
       (if (or (= (count m) (count settv)) (= m #{}))
        :set
         (if (= [1 200] (first velt))
           :list
           :vector)))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [sq]
  (if-not (associative? sq)
    (if (< (- (count (conj (conj sq :a) :a))
          (count sq))
        2) 
      :set
      :list)
    (if (=  0  (- (count (conj (conj sq [1 2]) [1 2]))
      (count (conj sq [1 2]))))
      :map
      :vector
      )))
happycrisis's solution:

1
2
3
4
5
#(let [blbx (conj % [:foo 42] [:foo 42] [:foo 43])]
   (cond (= (count blbx) (+ (count %) 2)) :set
         (= (count blbx) (inc (count %))) :map
         (= (first blbx) [:foo 43])       :list
         :else                            :vector))
hisba's solution:

1
2
3
4
5
6
7
(fn tf [c] 
  (let [ec (empty c)]
    (cond
     (= 1 (count (into ec [[1 2] [1 3]]))) :map
     (= 1 (count (into ec [1 1]))) :set
     (= (into ec [1 2]) [1 2]) :vector
     :else :list)))
icamts's solution:

1
2
3
4
5
(fn [coll] (condp = ((juxt associative? reversible? ifn?) coll)
 [true true true] :vector
 [false false false] :list
 [true false true] :map
 [false false true] :set))
immo's solution:

1
Scored 199, before 4clojure started saving solutions.
jarlax's solution:

1
2
3
4
5
#(condp = (first (str %))
   \[ :vector
   \{ :map
   \# :set
   :list)
jedo's solution:

1
2
3
4
5
6
7
8
9
(fn ftype [x]
  (let [fchar (first (str x))]
    (cond (= \# fchar) :set
          (= \[ fchar) :vector
          (= \{ fchar) :map
          :else :list
    )
  )
)
jeff_terrell's solution:

1
2
3
4
5
#(cond
  (reversible? %) :vector
  (associative? %) :map
  (= [2 1] (seq (conj (empty %) 1 2))) :list
  :else :set)
johncowie's solution:

1
2
3
4
5
6
7
8
9
(fn [item]
   (let [s (str item) f #(not (nil? (re-find (re-pattern %2) %1)))]
     (cond
      (f s "#\\{") :set
      (f s "\\[") :vector
      (f s "\\{") :map
      :else :list
      ) 
     ))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
;; weirdest problem ever?
(fn [coll]
  (cond 
   (= (empty coll) #{})
   :set
 
   (= (empty coll) {})
   :map
 
   :else  
   (if (= (last (conj coll :hello :world)) :world)  
     :vector
     :list)))
jorendorff's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [v]
  (let [ext1 (conj v [1 1])
        len1 (count ext1)
        ext2 (conj ext1 [1 1])
        len2 (count ext2)
        ext3 (conj ext2 [1 7])]
    (if (= len1 len2)
      (if (contains? ext3 [1 1])
        :set
        :map)
      (if (= (first ext3) [1 7])
        :list
        :vector))))
jslavin's solution:

1
2
3
4
5
6
7
8
#(let [v [:k 9]
       v2 [:kw 9]
       c2 (-> %1 (conj v) (conj v2))
       fst (first c2)]
   (cond (:k c2) :map 
         (contains? c2 v) :set
         (= v2 fst) :list
         :otherwise :vector))
kohyama's solution:

1
2
3
4
5
6
#(cond
  (= (count (conj % [0 0]))
     (count (conj % [0 0] [0 1]))) :map
  (= (conj % 0) (conj % 0 0)) :set
  (= (next (conj % 0 1)) (conj % 0)) :list
  :else :vector)
kopychenko's solution:

1
2
3
4
5
6
7
8
(fn black-box-testing [x]
  (let [e (empty x)]
    (cond (= e {}) :map
          (= e #{}) :set
          (and (= e '()) (= :TEST (first (conj e nil :TEST)) )) :list
          (and (= e []) (= :TEST (last (conj e :nil :TEST))  )) :vector
 
          :else :unknown)))
blucas's solution:

1
2
3
4
5
6
7
8
(fn prob65
  [col]
  (let [blank (empty col)]
    (cond
     (= blank {}) :map
     (= blank #{}) :set
     (= blank '()) (if (reversible? blank):vector :list)
     :else :unknown)))
brendan's solution:

1
2
3
4
5
#(let [c (into (empty %) [[0 0] [0 1]])]
    (cond (= 1 (count c)) :map
          (get c 0) :vector
          (= [0 0] (first c)) :set
          true :list))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn myBlackBoxTesting
  [coll]
  (let [modColl (conj coll (first coll))]
    (if (= (count modColl) (count coll))
      (if (contains? coll (first coll))
        :set
        :map)
      (if (empty? coll)
        (if (= (count (conj modColl 1 1)) 2)
          :set
          (if (= (conj modColl 1 1) '(1 1 nil))
            :list
            :vector))
        (if (= modColl (cons (first coll) coll))
        :list
        :vector)))))
lackita's solution:

1
2
3
4
5
6
#(cond (contains? (conj % [:maptest 5]) :maptest) :map
       (= (count (filter (partial = :settest) 
                         (into % [:settest :settest])))
          1) :set 
       (= (last (conj (conj % :notvec) :vectest)) :vectest) :vector
       :else :list)
lambda4fun's solution:

1
2
3
4
5
#(case ((juxt associative? reversible? ifn?) %)
   [true  true  true ] :vector
   [false false false] :list
   [true  false true ] :map
   [false false true ] :set)
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
#(cond
  (reversible? %) :vector
  (associative? %) :map
  :else (let [k (conj % 1 2)]
          (if (= (first k) 2)
            :list
            :set
            )
          )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [s]
  (cond
   (= (inc (count s))
      (count (conj s [::key ::val1] [::key ::val2])))
   :map
   
   (= (inc (count s))
      (count (conj s ::entry ::entry ::entry)))
   :set
   
   (= ::end
      (last (conj s ::dummy ::end)))
   :vector
   
   :else
   :list))
leetwinski's solution:

1
2
3
4
5
#(case (first (str %))
       \[ :vector
       \{ :map
       \# :set
       :list)
littlejp2046's solution:

1
2
3
4
5
6
7
#(if (associative? %)
    (if (reversible? %)
      :vector
      :map)
    (if (= (count (conj % :a)) (count (conj % :a :a)))
      :set
      :list))
malvert's solution:

1
2
3
4
5
6
7
(fn [c]
  (let [d (conj c [7 8])]
    (cond
      (= 8 (get d 7)) :map
      (= (get d [7 8]) [7 8]) :set
      (nil? (get d 0)) :list
      1 :vector)))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [coll]
  (let [x [:x :y]
        len (count coll)
        c (conj (conj coll x) x)]
    (if (= (inc len) (count c))
      (if (nil? (c :x))
        :set
        :map)
      (let [y [:y :x]
            c (conj (conj coll x) y)]
        (if (= (first c) y)
          :list
          :vector)))))
maximental's solution:

1
2
3
4
5
#(cond
   (= (conj % nil) %) :map 
   (= (conj % 0) (conj % 0 0)) :set
   (= (conj % 0 1) (cons 1 (cons 0 %))) :list
   :else :vector)
mbakhterev's solution:

1
(fn [S] (let [l (count S) tl (count (into S '([1 2] [1 3] [1 3])))] (cond (= (+ 1 l) tl) :map (= (+ 2 l) tl) :set (= (+ 3 l) tl) (if (associative? S) :vector :list))))
meerwolf's solution:

1
2
3
4
5
6
7
8
(fn black-box [coll]
  (let [t (gensym)] ; A generic item guaranteed to not already be in coll.
    (cond
      (= coll (set coll))                            :set
      (= (conj coll [t 1]) (conj coll [t 1] [t 1]))  :map
      (= [t 2] (first (conj coll [t 1] [t 2])))      :list
      (= [t 2] (last (conj coll [t 1] [t 2])))       :vector
      :else                                          nil)))
mfikes's solution:

1
2
3
4
5
6
(fn [coll]
  (cond
   (= :myval (get (conj coll [:mykey :myval]) :mykey)) :map
   (= :myval (get (conj coll :myval) :myval)) :set
   (= :myval (first (conj coll :abc :myval))) :list
   :else :vector))
minitrue's solution:

1
2
3
4
#(if-let [t ({{} :map, #{} :set} (empty %))]
  t
  (if (-> % (conj 1) (conj 0) first zero?)
    :list :vector))
mkahn's solution:

1
2
3
4
5
6
7
8
(fn blackbox [x]
     (if (= (count (conj (empty x) [:a 1] [:a 1])) 2)
       (if (= [:b 2] (first (conj (conj (empty x) [:a 1]) [:b 2])))
         :list
         :vector)
       (if (associative? x)
         :map
         :set)))
mobiusloop's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [c]
  (letfn [
  (isMap [m] (let [s (conj m [:a 1])] (= (:a s) 1)))
  (isVector [v] (let [s (conj v 1 2)] (= 2 (last s))))
  (isSet [s] (let [x (conj s 1 1)] (<= (count x) (inc (count s)))))
  ]
    (cond
     (isMap c) :map
     (isSet c) :set
     (isVector c) :vector
     :else :list
     )
   ))
mononite's solution:

1
2
3
4
5
6
7
(fn[x]
  (let [t (conj (empty x) [:a :b] [:c :d])]
    (cond
      (:a t) :map
      (get t 0) :vector
      (get t [:a :b]) :set
      :else :list)))
mouse's solution:

1
#(or({{}:map #{}:set}(empty %))({[1 2]:vector[2 1]:list} (conj(empty %)1 2)))
mwaldowski's solution:

1
2
3
4
5
6
7
(fn [coll]
  (let [t (into coll [[:x 99][:y 98]])]
    (cond (= (get t :x) 99) :map
          (= (get t [:x 99]) [:x 99]) :set
          (= (take 2 t) [[:y 98] [:x 99]]) :list
          (= (take-last 2 t) [[:x 99] [:y 98]]) :vector
          :else nil)))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn wtf [xs]
  (let [seq (empty xs)
        order (first (conj (conj (conj seq [1 1]) [2 2]) [3 3]))
        num (count (conj  (conj (conj (conj seq [1 1]) [2 2]) [3 3]) [3 3]))]
    (cond
      (and
       (= order [1 1])
       (= num 4)) :vector
      (and
       (= order [3 3])
       (= num 4)) :list
      (and
       (= order [1 1])
       (= num 3)) :map ;; Recent version of Clojure
      (and
       (= order [2 2])
       (= num 3)) :set
      :else :map )));; Old version of Clojure
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
(fn tpe [obj]
        (let [v [:test :result]
              obj (conj obj v)]
              (cond (:test obj)
                    :map
                    (= (conj obj v) obj)
                    :set
                    (= (last (conj obj :aaaa)) :aaaa)
                    :vector
                    :default :list)))
noiseehc's solution:

1
2
3
4
5
6
7
(fn [x] (let [x2 (conj x [:q :qv]) 
              x3 (conj x2 [:q :qv])] 
          (cond 
            (not (ifn? x)) :list 
            (not= x2 x3) :vector 
            (= (x2 :q) :qv) :map
            :else :set)))
norman's solution:

1
2
3
4
5
6
7
(fn [x]
  (let [sym (gensym) sym2 (gensym)]
    (cond
     (contains? (conj x [sym sym]) sym) :map
     (= 1 (count (filter #(= sym %) (conj (conj x sym) sym)))) :set
     (= sym (first (conj (conj x sym2) sym))) :list
     :else :vector)))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn foo [collection]
           (let [collection (empty collection)
                 is-vector? (fn [col] (get (conj col [1 3]) 0))
                 is-map? (fn [col] (get (conj col [1 3]) 1))
                 is-set? (fn [col]
                           (when (not (is-map? col))
                             (let [start-size (count col)
                                   new-size (count (conj (conj col [1 3]) [1 3]))]
                               (= 1 (- new-size start-size)))))]
             (cond
               (is-vector? collection) :vector
               (is-map?    collection) :map
               (is-set?    collection) :set
               :else                   :list)))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [coll]
  (let [e (reduce #(conj %1 (vector %2 (inc %2))) (empty coll) (range 10)) 
        v (reduce #(conj %1 (vector %2 (inc %2))) [] (range 10)) 
        l (reduce #(conj %1 (vector %2 (inc %2))) () (range 10)) 
        m (reduce #(conj %1 (vector %2 (inc %2))) {} (range 10)) 
        s (reduce #(conj %1 (vector %2 (inc %2))) #{} (range 10))]
    
    (cond (= e v) :vector
          (= e l) :list
          (= e m) :map
          (= e s) :set )))
ownwaterloo's solution:

1
2
3
4
5
#(cond
  (reversible? %) :vector
  (associative? %) :map
  :else (if (== (+ 2 (count %))
                (count (conj % 12 12))) :list :set))
ozan's solution:

1
2
3
4
5
6
#(let [t (conj (empty %) [:k :v])]
   (cond
    (:k t) :map
    (get t 0) :vector
    (get t [:k :v]) :set
    :else :list))
pukeface's solution:

1
2
3
4
5
(fn [qq]
    (cond (not (nil? (:x (conj qq [:x 2])))) :map
          (= (count (conj qq 2)) (count (conj qq 2 2))) :set
          (let [a {:x :x}] (identical? (first (conj (conj qq '()) a))  a)) :list
          :else :vector))
quant1's solution:

1
2
3
4
#(let [e (into (empty %) [[:a 1] [:a 2] [:a 1]])]
            (if (= (count e) 1) :map
              (if (contains? e 0) :vector
                (if (= (count e) 2) :set :list))))
rodmax's solution:

1
2
3
4
5
6
7
#(case 
     ((juxt associative? empty) %)
   [false #{}] :set
   [false ()]  :list
   [true {}]  :map
   [true []]  :vector
)
sbondaryev's solution:

1
2
3
4
5
6
(fn f [xs]
  (case (conj (empty xs) [:a 1] [:a 2])
    {:a 2} :map
    [[:a 1] [:a 2]] :vector
    [[:a 2] [:a 1]] :list
    #{[:a 2] [:a 1]} :set))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
(fn check-type [coll]
  (let [coll-m (conj coll {:w :x :y :z})]
    (if (= (+ 2 (count coll)) (count coll-m))
        :map
      (let [coll-c (conj coll :z :z :x)]
        (if (= (+ 2 (count coll)) (count coll-c))
          :set
          (if (= (last coll-c) :x)
              :vector
            :list))))))
sheldon's solution:

1
#((zipmap (map str ['() [] {} #{}]) [:list :vector :map :set]) (str (empty %)))
silverio's solution:

1
2
3
#(if (pos? (count (flatten (into % {:tic :toc}))))
   (if (= :toc (first (into % [:tic :toc]))) :list :vector)
   (if ((into % {:tic :toc}) :tic) :map :set))
skyrem's solution:

1
2
3
4
5
6
7
(fn [coll]
  (let [s (first (str coll))]
    (cond
     (= \{ s) :map
     (= \# s) :set
     (= \[ s) :vector
    :else :list)))
soul_awaker's solution:

1
2
3
4
(fn [x]
  (if (= x (vec x))
      (if (get (conj x 0) 0) :vector :list)
      (if (get (conj x [0 0]) 0) :map :set)))
staafl2's solution:

1
2
3
4
5
6
7
8
9
(fn [x]
  (let [
    r 0
    is-map (fn [y] (= (count (conj y [r r])) (count (conj y [r r] [r (+ r 1)]))))
    is-set (fn [y] (= (count (conj y r)) (count (conj y r r))))
    is-vector (fn [y] (= r (last (conj (conj y (+ r 1)) r))))
    is-list (fn [y] (= r (first (conj (conj y (+ r 1)) r))))
    ]
    (some (fn [[k v]] (when (k x) v)) {is-map :map, is-set :set, is-vector :vector, is-list :list})))
syeerzy's solution:

1
2
3
4
5
6
(fn [coll]
  (condp #(contains? %2 %) (conj (empty coll) [:test :test])
    0 :vector
    :test :map
    [:test :test] :set
    :list))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(comp {\{ :map \# :set \[ :vector \c :list} first str)
;
;(fn [coll]
;  (let [c1 (conj coll {:spacer :spacer} {:sentinel :sentinel})
;        c2 (into (empty coll) (cons {:sentinel :sentinel} c1))]
;      (if (= (count c1) (count c2))
;        (if (c1 :sentinel)
;          :map
;          :set)
;        (if (= (first c2) (last c2))
;          :vector
;          :list))))
thegeez's solution:

1
2
3
4
5
6
7
(fn [in]
    (cond
     (get (into in [[:k :v]]) :k) :map
     (get (into in [[:k :v]]) [:k :v]) :set
     (let [ufirst (into in [:my_first_entry :my_second_entry])]
       (= (first ufirst) :my_second_entry)) :list
     :else :vector))
zzamboni's solution:

1
2
3
4
5
6
(fn type-detect [obj]
  (cond
    (and (associative? obj) (not (reversible? obj)))        :map
    (and (associative? obj) (reversible? obj))              :vector
    (= 1 (count (into (empty obj) [:fizz :fizz])))          :set
    (= :second (first (into (empty obj) [:first :second]))) :list))
zoltanjarai's solution:

1
2
3
4
5
(fn __ [x]
  (cond (reversible? x) :vector
        (associative? x) :map
        (= (conj x 1 1) (conj x 1)) :set
        :else :list))
zipzop's solution:

1
2
3
4
5
6
(fn [c]
  (cond
    (= (get (conj c [:t "t"]) :t) "t") :map
    (= (get (conj c :t) :t) :t) :set
    (= (first (conj (conj c :a) :b)) :b) :list
    (= (last (conj (conj c :a) :b)) :b) :vector))
yusubori's solution:

1
2
3
4
5
6
#(let [c (empty %)]
  (cond
    (= c {}) :map
    (= c #{}) :set
    (= (first (conj c 1 2)) 1) :vector
    (= (last (conj c 1 2)) 1) :list))
ydash's solution:

1
2
3
4
5
#(cond (get (conj % [:c 3]) :c) :map
        (= (count (conj % 1 1)) (+ (count %) 1)) :set
        (= :a (first (conj % :b :a))) :list
        :else :vector
        )
vpeurala's solution:

1
2
3
4
5
6
7
8
9
(fn [c] (letfn [
(is-map? [c] (= 1 (get (conj (empty c) [0 1] [2 3]) 0)))
(is-set? [c] (= [0 1] (get (conj (empty c) [0 1] [2 3]) [0 1])))
(is-vector? [c] (and (not (is-map? c)) (= (first (conj (empty c) [0 1] [2 3])) [0 1])))
(is-list? [c] (and (not (is-set? c)) (= (first (conj (empty c) [0 1] [2 3])) [2 3])))
(find-first [pred coll] (first (filter pred coll)))
(types-and-tests [] {:map is-map? :list is-list? :vector is-vector? :set is-set?})
(black-box-testing [c] (find-first #((get (types-and-tests) %) c) (keys (types-and-tests))))
] (black-box-testing c)))
v_bogdanov's solution:

1
2
3
4
5
6
7
(fn check-box [coll]
  (cond
   (= :v (get (conj coll [:k :v]) :k))     :map
   (= (conj coll "s") (conj coll "s" "s")) :set
   (= "l" (first (conj coll "v" "l")))     :list
   (= "v" (last (conj coll "l" "v")))      :vector
  ))
unionx's solution:

1
2
3
4
5
6
7
8
(fn [coll]
  (let [c (empty coll)
        r (str c)]
    (condp = r
      "{}"  :map
      "#{}" :set
      "[]"  :vector
            :list)))
trxeste's solution:

1
2
3
4
5
6
(fn [c]
  (cond
    (= (get (conj c [:t "t"]) :t) "t") :map
    (= (get (conj c :t) :t) :t) :set
    (= (first (conj (conj c :a) :b)) :b) :list
    (= (last (conj (conj c :a) :b)) :b) :vector))
transfinite's solution:

1
2
3
4
5
6
7
(fn [coll]
    (let [e (empty coll)]
         (cond
         (= {} e) :map
         (= #{} e) :set
         (= (conj (conj coll 1) 2) (cons 2 (cons 1 coll))) :list
             :else  :vector)))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)