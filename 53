;; 53 Longest Increasing subseq [h]

Takes vec of ints, returns longest
consecutive series of increasing nums. (2 dig min)
returns first occurrence in case of tie.

(= (__ [1 0 1 2 3 0 4 5]) [0 1 2 3])
(= (__ [5 6 1 3 2 7]) [5 6])
(= (__ [2 3 3 4 5]) [3 4 5])
(= (__ [7 6 5 4]) [])

(defn streak [coll]
  (let [take-seq (fn [n pred coll]
                   (let [hits (count (take-while #(apply pred %)
                                (partition n 1 coll)))]
                        (take (+ n hits -1) coll)))
        chop (fn [coll]
               (for [n (range (count coll))] (drop n coll)))
        parts (chop coll) 
        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)
        longest (apply max-key count seqs)]
    (if (< (count longest) 2)
      []
      longest)))
#'user/streak
user> (streak [1 0 1 2 3 0 4 5])
(0 1 2 3)


(fn longest-subseq [coll]
  (let [take-seq (fn [n pred coll]
                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]
                     (take (+ n hits -1) coll)))
        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))
        parts (chop coll)
        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)
        longest (apply max-key count seqs)]
    (if (< (count longest) 2)
      []
      longest)))

(fn [xs]
(->> (map #(vector %1 (- %1 %2)) (rest xs) xs)
       (cons [(first xs) -1])
       (#(loop [agg () [x & tail] %]
           (if (empty? tail)
             agg
             (let [[ys y-tail] (split-with (comp pos? second) tail)
                   zs (cons x ys)]
               (if (> (count zs) (count agg))
                 (recur zs y-tail)
                 (recur agg y-tail))))))
       (map first)
       (#(if (seq (rest %)) % ()))))

(fn*
 [p1__2876#]
 (sort
  (set
   (flatten
    (map
     (fn [[a1 a2 a3]] (vector a2 a3))
     (apply
      max-key
      count
      (conj (reverse
      (filter
       ffirst
      (partition-by
       first
       (map
        (fn [[a1 a2]] (if (< a1 a2) (vector true a1 a2) (vector false a1 a2)))
        (partition
         2
         (interleave
          p1__2876#
          (conj (vec (rest p1__2876#)) (last p1__2876#)))))))) '())))))))

#(loop[longest [0 0] current [(first %) (first %)] remaining (rest %)]
   (if-let [item (first remaining)]
     (if (= (inc (second current)) item)
       (recur longest (assoc current 1 item) (rest remaining))
       (if (> (- (second current) (first current)) (- (second longest) (first longest)))
         (recur current [item item] (rest remaining))
         (recur longest [item item] (rest remaining))))
     (let [[start end] (if (> (- (second current) (first current)) (- (second longest) (first longest)))
                         current
                         longest)]
       (if (= start end) []
         (range start (inc end))))))

(fn [xs]
   (let [seqs (reduce (fn [{:keys [all want]} i]
                        (let [cur (peek all)
                              prev (pop all)]
                          {:all (if (= i want)
                                  (conj prev (conj cur i))
                                  (conj all [i]))
                           :want (inc i)}))
                      {:all [[]] :want nil}
                      xs)]
     (apply max-key count
            (remove #(= 1 (count %))
                    (:all seqs)))))
aceeca1's solution:

1
(comp #(if (<= 2 (count %)) % '()) #(map first (first (sort-by (comp - count) (partition-by last (map list % (reductions + (cons 0 (map (fn [[x1 x2]] (if (< x1 x2) 0 1)) (partition 2 1 %))))))))))
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn ff [s]
  (let [pairs (partition 2 1 s)
        bigger? (map #(apply < %) pairs)
        runs (partition-by second (map vector pairs bigger?))
        runs (filter #(-> % first second) runs)
        ord-runs (sort-by #(* -1 (count %)) runs)
        best (first ord-runs)
        ans (concat (-> best first first first vector) (map #(-> % first second) best))
        ]
    (if (first ans) (vec ans) [])
    ))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
(fn searchSequenceX[x] 
    (let [res (
(fn searchSequenceRec[x]
    (if (empty? x)
        nil
        (if (nil? (second x))
            []
            (if((fn inSuccession[x] (= 1(- (second x)(first x))))
 x)
                (let [res (
                (fn readSequence[x res]
                    (if (empty? x)
                        [(reverse res) x]
                        (if (nil? (second x))
                            [(reverse (cons (first x) res)) []] 
                            (if ((fn inSuccession[x] (= 1(- (second x)(first x))))
 x)
                                (readSequence (rest x) (cons (first x)res))
                                [(reverse (cons (first x) res)) (rest x)]
                            )
                        )
                    )
                ) x [])]
                    (cons (first res)(searchSequenceRec (second res)))
                )
                (searchSequenceRec (rest x))
            )
        )
    )
) x)]
        (if (empty? res)
        []
        (reduce (fn maxSeq[a b] 
    (if (> (count a) (count b))
        a
        b
    )
)
 res)
        )
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [x]
  (letfn [(longer [a b] (if
                          (<
                            (count a)
                            (count b))
                          b a))]
    (->> x
      (reduce (fn [[sx longest-sx] item]
                (cond 
                  (empty? sx) [[item] longest-sx]
                  (>= (last sx) item) [[item] (longer longest-sx sx)]
                  :else [(conj sx item) longest-sx]))
                [[] []])
      (reverse)
      (apply longer)
      ((fn [xs] (if (> (count xs) 1) xs []))))))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [a]
  (letfn [(next-inc? [n c] (= (inc' (nth c n)) (nth c (inc' n))))
          (previous-inc? [n c] (= (dec' (nth c n)) (nth c (dec' n))))
          (next-previous-incs? [n c] (and (next-inc? n c) (previous-inc? n c)))
          (npi [n c] [(previous-inc? n c) (next-inc? n c)])
          (nistart? [c] (if (next-inc? 0 c) [false true] [false false]))
          (niend? [c] (if (previous-inc? (dec' (count c)) c) [true false] [false false]))
          (incs? [c]
            (let [cc (count c)
                  mid-incs (map #(npi % c) (range 1 (dec' cc)))
                  all-incs  (concat [(nistart? c)] mid-incs [(niend? c)])
                  add-to-last (fn [n col] (concat (butlast col) [(concat (last col) [(nth c n)])]))]
              (loop [res [[]] num 0]
                (cond
                 (> num (dec' cc)) (last (sort-by count res))
                 (= (nth all-incs num) [false false]) (recur res (inc' num))
                 (or (= (nth all-incs num) [true false]) (= (nth all-incs num) [true true])) (recur (add-to-last num res) (inc' num))
                 (= (nth all-incs num) [false true]) (recur (concat res [[(nth c num)]]) (inc' num))))))]
    (incs? a)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn partition-by-increasing
  [col]
  (letfn [(partition-increasing
            [col]
            (loop [part-col []
                   cur-subseq []
                   col col]
              (let [prev (last cur-subseq)
                    x (first col)]
                (cond
                  (not x) (conj part-col cur-subseq) ; last element
                  (not prev) (recur part-col [x] (next col)) ; first element
                  (> x prev) (recur part-col (conj cur-subseq x) (next col)) ;
                  :else (recur (conj part-col cur-subseq) [x] (next col))))))
          (longest-seq [col]
            (let [lens (map count col)
                  max-len (apply max lens)]
              (->>
               (map vector col lens)
               (filter #(and (>= (count (first %)) 2) (= (second %) max-len)))
               (map first)
               first
               vec
               )))]
    (-> col
        partition-increasing
        longest-seq)))
andthorn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [l] (let
          [res (reduce
            (fn [x y] (if (< (count x) (count y)) y x))
            (map
             (fn longest [l] (if
                               (= (+ 1 (first l)) (second l))
                               (cons (first l) (longest (rest l)))
                               (take 1 l)
                             )
             )
             (map #(drop % l) (range 0 (- (count l) 1)))
            )
          )]
          (if (> (count res) 1) res (rest res))
        )
)
anjensan's solution:

1
2
3
4
5
6
7
8
9
(fn [s] 
    (->>
      (for [a (range (count s)) 
            b (range (inc a) (count s))]
        (subvec s a (inc b)))
      (filter #(apply < %))
      (sort-by count >)
      first
      vec))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn
  [coll]
  (letfn [(step [[l ll cb cn] e]
            (let [cn' (inc cn)
                  cl (inc (- cn cb))]
              (if (= cn' e)
                [l ll cb cn']
                (if (> cl ll)
                  [[cb cn] cl e e]
                  [l ll e e]))))]
    (let [h (first coll)
          t (rest coll)
          [l ll cb cn] (reduce step [nil -1 h h] t)
          cl (inc (- cn cb))]
      (if (> cl ll)
        (if (> cl 1)
          (range cb (inc cn))
          [])
        (if (> ll 1)
          (range (first l) (inc (second l)))
          [])))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s]
  (let [
    subseqs (filter
      #(not= 1 (count %))
      (mapcat
        (partial reductions conj [])
        (tree-seq
          (complement empty?)
          (comp list rest) s)))
      inc? (fn [s] (or (empty? s) (= s (range (first s) (inc (last s))))))]
  (last (sort-by count (filter inc? subseqs)))))
awebb's solution:

1
2
3
4
5
6
7
(fn lss [v]
  (loop [[h & t] v, lsf [], cur []]
    (if h
       (if (and t (> (first t) h))
                (recur t lsf (conj cur h))
                (if (>= (count cur) (count lsf)) (recur t (conj cur h) []) (recur t lsf [])))
        (if (next lsf) lsf [])      )))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
#(keep-indexed 
  (fn [idx v] (if (or (odd? idx) (zero? idx)) v)) 
  (flatten 
   (reduce 
    (fn [a b] (if (< (count a) (count b)) b a)) [] 
    (filter 
     (fn [itm] (< ((first itm) 0) ((first itm) 1)))            
     (partition-by 
      (fn [itm] (< (itm 0) (itm 1))) 
      (map vector % (rest %)))))))
benhammond's solution:

1
2
3
4
5
6
7
(fn [ss]
  (let [mf #(if (> (count %1) (count %2)) %1 %2)
        sf #(if (> (count %) 1) % '())]
    (loop [ls '() cs (list (first ss)) [x & xs] (next ss)]
      (cond (nil? x) (reverse (sf (mf ls cs)))
            (= x (inc (first cs))) (recur ls (cons x cs) xs)
          :else (recur (mf cs ls) (list x) xs)))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s]
  (reduce
   (fn [longest seq]
     (if (< (count longest) (count seq))
       seq
       longest))
   []
   (filter #(apply < %)
           (mapcat
            #(partition % 1 s)
            (range 2 (inc (count s)))))))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn  [col]
  (let [r (reduce (fn [x y] (if (> (count y) (count x)) y x)) []
          (reductions (fn [searched x]
                        (if (= (last searched) (dec x))
                          (concat searched [x])
                          [x]))
                      []
                      col))]
    (if (> (count r) 1)
      r
      [])))
burner's solution:

1
2
3
(fn [s] (letfn [(gen-subseq [s] (mapcat (fn [s] (map #(subvec s 0 %) (range 0 (inc (count s)))))
                                      (map #(subvec s %) (range 0 (inc (count s))))))]
                (last (sort #(< (count %1) (count %2)) (reverse (filter #(not (= (count %) 1)) (filter #(= % (vec (apply sorted-set %))) (gen-subseq s))))))))
caterpillar's solution:

1
2
3
4
5
6
7
8
#(loop[v (rest %) preVal (first %) longestSeq [] trackedSeq [preVal]]
  (if (seq v)
    (let[curVal (first v)]
      (if (> curVal preVal) (recur (rest v) curVal longestSeq (conj trackedSeq curVal))
        (if (> (count trackedSeq) (count longestSeq)) (recur (rest v) curVal trackedSeq (vector curVal))
          (recur (rest v) curVal longestSeq (vector curVal)))))
    (let[result (if (> (count trackedSeq) (count longestSeq)) trackedSeq longestSeq)]
      (if (<= (count result) 1) [] result))))
cc787's solution:

1
2
3
4
5
6
7
8
(fn [xs]
  ((fn [x] (if (< (count x) 2) [] x))     ; have a length of 2 or greater
   (apply max-key count
          (reverse                      ; to make sure get the first
           (reductions
            #(if (or (empty? %1) (>= (last %1) %2))
               [%2]
               (conj %1 %2)) [] xs)))))
chunchangshao's solution:

1
#(case (first %) 5 [5 6] 2 [3 4 5] 7 [] [0 1 2 3])
ctzsm's solution:

1
2
3
(fn [coll] (let [c (filter #(and (apply < %) (> (count %) 1))
  (for [x (range 0 (count coll)) y (range 1 (inc (- (count coll) x)))] (take y (drop x coll))))]
              (if (empty? c) [] (let [n (apply max (map #(count %) c))] (first (filter #(= n (count %)) c))))))
dan7es's solution:

1
2
3
4
5
6
(fn longest-incr-subseq [xs]
  (->> (range (count xs) 1 -1)
       (mapcat #(partition % 1 xs))
       (filter #(->> (apply sorted-set %)
                     seq (= %)))
       first vec))
daniels's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [i] 
  (loop [a i l -9999999 t [] r []] 
    (if (empty? a) 
      (if (and (> (count t) (count r)) (> (count t) 1)) t r)
      (if (> (first a) l) 
        (recur (rest a) (first a) (conj t (first a)) r) 
        (if (and (> (count t) (count r)) (> (count t) 1) )
          (recur (rest a) (first a) [(first a)] t)
          (recur (rest a) (first a) [(first a)] r)
        )
      )
    )
  )
)
daowen's solution:

1
2
3
4
5
6
7
#(loop [xs %, best-c 0, best-s '()]
  (if (< (count xs) 2) best-s
    (let [s (map second (take-while (fn [p] (< (first p) (second p))) (partition 2 1 xs)))
          ss (if (empty? s) s (cons (first xs) s))
          c (count ss)
          [next-c next-s] (if (> c best-c) [c ss] [best-c best-s])]
      (recur (rest xs) next-c next-s))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [coll]
 (let [data (filter #(= 2 (count %))(partition-all 2 1 coll))
       is_inc (fn [[a b]] (= 1 (- b a)))]
    (loop [r [] d (drop-while #(not (is_inc %)) data)]
     (if (empty? d) (if (empty? r) [](let [r_list (apply concat r) start (first r_list) end (last r_list)] (range start (inc end)))
)      (let [inc_seq (take-while #(is_inc %) d)]
        (recur (if (> (count inc_seq) (count r)) inc_seq r)  (drop-while #(not (is_inc %)) (drop-while #(is_inc %) d)) )
      )
     )
    )
 )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [l]
  (letfn 
    [(inf 
      [l cseq]
      (if (empty? l) cseq
        (let [rl (rest l) fl (first l)]
          (if (or (empty? cseq) (< (last cseq) fl))
            (inf rl (concat cseq [fl]))
            (let [nseq (inf rl [fl])]
              (if (>= (count cseq) (count nseq)) cseq nseq)
              )))))]
    (let [sq (inf l [])]
      (if (> (count sq) 1) sq [])
      )))
devm33's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [coll]
  (let
    [maxsub (apply max-key count
    (reverse (loop [ s (seq coll) res [] ]
      (if (empty? s)
        res
        (let
          [group
           (loop [xs (next s) cur [(first s)]]
             (if (or (empty? xs) (>= (last cur) (first xs)))
               [xs cur]
               (recur (rest xs) (conj cur (first xs)))))]
          (recur (first group) (conj res (second group))))))))]
    (if (< (count maxsub) 2) [] maxsub)))
dwelte's solution:

1
2
3
4
5
6
7
8
(fn [xs]
  (let [crunch #(concat (map first %) (list (second (last %))))
        parted (partition-by #(< (first %) (second %)) (partition 2 1 xs))
        filtered (filter (fn [[[x y] & r]] (< x y)) parted)
        sorted (sort-by #(- (count %)) filtered)]
    (if (seq sorted)
      (crunch (first sorted))
      [])))
dzholev's solution:

1
2
3
(fn [s]
  (or (first (filter #(apply < %) (mapcat #(partition % 1 s) (range (count s) 1 -1))))
      []))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [v]
    (let [t (partition-by identity ((fn [s] (map #(< %1 %2) s (drop 1 s))) v))
          [i l b] (reduce 
                        (fn [[i l b] c] 
                            (let [k (count c)
                                  j (+ i k)]
                                (if (and (first c) (> k l))
                                    [ j k i ]
                                    [ j  l b ])))
                        [0 -1 0] t)]
        (subvec v b (+ b l 1))))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(letfn [                                                                                                                                                
    (my-partition [s]                                                                                                           
        (reduce (fn [a v]                                                                                                                               
            (let [l (last (last a))]                                                                                            
                (if (or (nil? l) (<= v l))                                                                                                              
                    (conj a [v])                                                                                                
                    (conj (vec (butlast a)) (conj (last a) v))))) [] s))                                                                                
    (longest-partition [s]                                                                                                      
        (let [longest (->> s (my-partition)                                                                                                             
                             (filter #(> (count %) 1))                                                                          
                             (sort-by #(- (count %)))                                                                                                   
                             (first))]                                                                                          
            (if (nil? longest) [] longest)))]                                                                                                           
    longest-partition)
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn longest-inc-seq
  ([coll] (longest-inc-seq [] [(first coll)] (rest coll)))
  ([lng curr [x & c]]
   (letfn [(select-longest
            [longest current]
            (if (and (< (count longest) (count current))
                     (< 1 (count current)))
              current
              longest))]
     (if (nil? x)
       (select-longest lng curr)
       (if (> x (last curr))
         (longest-inc-seq lng (conj curr x) c)
         (longest-inc-seq (select-longest lng curr) [x] c))))))
finsternis's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s]
  (letfn [(split-increasing [acc [s0 s1 :as s]]
            (if (empty? s)
              nil
              (let [acc' (conj acc s0) rs (rest s)]
                (if (and s1 (< s0 s1))
                  (recur acc' rs)
                  (cons acc' (split-increasing [] rs))))))]
    (let [ss (filter #(> (count %) 1) (split-increasing [] s))]
      (if (empty? ss)
        []
        (let [len (apply max (map count ss))]
          (first (filter #(= (count %) len) ss)))))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [s]
  (let 
    [longer-seq #(if (>= (count %1) (count %2)) %1 %2)
     result (apply longer-seq
              (reduce
                (fn [[smax scur] b]
                  (if (or (empty? scur) (< (last scur) b))
                    [smax (conj scur b)]
                    [(longer-seq smax scur) [b]]))
                [[] []]
                s))]
    (if (>= (count result) 2) result [])))
garyxia's solution:

1
2
3
4
5
6
7
8
9
(fn [coll]
  (let [seqs (reverse (map #(concat (first %) (map (fn [i] (last i)) (rest %)))
                        (filter #(every? (fn [ele] (< (first ele) (last ele))) %)
                          (partition-by
                            #(< (first %) (last %))
                            (partition 2 1 coll)))))]
    (if (empty? seqs)
      []
      (apply (partial max-key count) seqs))))
geekerzp's solution:

1
2
3
4
5
6
7
8
(fn [coll]
   (->> (map vector coll (range))
        (partition-by #(apply - %))
        (map #(map first %))
        (filter #(> (count %) 1))
        (sort-by (comp - count))
        first
        vec))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(letfn [
        (step [seqs item]
            (if (> item (peek (first seqs)))
                (conj (rest seqs) (conj (first seqs) item))
                (conj seqs [item])
            ))
        (max-increasing-subseq [coll]
            (if (zero? (count coll))
                []
                (let [subseqs (reduce step (list [(first coll)]) (rest coll))
                      res (apply max-key count subseqs)]
                    (if (< (count res) 2) [] res)
                )))
    ]
    #(max-increasing-subseq %)
)
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn lseq [ll]
  (loop [l ll
         bef nil
         r []
         ans []]
    (if (nil? bef)
      (recur (rest l) (first l) (conj r (first l)) [])
      (if (empty? l) (if (> (count ans) 1) ans [])
        (let [nr (if (= (- (first l) bef) 1) (conj r (first l)) [(first l)])]
            (recur (rest l)
               (first l)
               nr
           (if (empty? ans) nr
         (if (> (count nr) (count ans)) nr ans))))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
#((reduce
 (fn [state el]
   (let [prev (or (last (:cur state)) java.lang.Integer/MIN_VALUE)
         cur (:cur state)
         cur-seq (conj cur el)
         best (:best state)]
     (assoc state
       :cur 
       (if (> el prev)
         cur-seq
         [el])
 
       :best
       (if (and
            (>= (count cur-seq) 2)
            (> el prev)
            (> (count cur-seq) (count best)))
         cur-seq
         best))))
 {:cur [] :best []} %) :best)
happycrisis's solution:

1
2
3
4
5
6
7
8
(fn [s]
  (->> (map vector s (rest s))
       (partition-by (fn [[a b]] (< a b)))
       (map #(conj (map second %) (first (first %))))
       (filter (partial apply <))
       (reverse)
       (#(when (not (empty? %)) (apply max-key count %)))
       (vec)))
hisba's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn tf [s]
  (loop [best [] curr [(first s)] restt (rest s)]
    (let [a (last curr) b (first restt)]
      (if b
        (if (< a b)
          (let [curr_n (conj curr b)]
            (recur (max-key count curr_n best) curr_n (rest restt)))
          (recur best [b] (rest restt))
        )
        best
        )
      )
    ))
icamts's solution:

1
2
3
4
5
6
7
8
9
10
11
12
#(->> % 
     (partition 2 1) 
     (partition-by (fn [a] (apply < a)))
     (filter (fn [a] (apply < (first a))))
     (group-by count) 
     (sort-by key >) 
     first 
     second 
     first 
     ((juxt (partial map first) (comp last last))) 
     flatten
     (filter (comp not nil?)))
immo's solution:

1
2
3
4
5
6
7
8
9
(fn [x]
               (or 
                (first
                 (sort-by count >
                          (for [a (range (count x))
                                b (range (+ a 2) (inc (count x)))
                                :let [s (subvec x a b)]
                                :when (apply < s)]
                            s))) []))
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [[x & xs]]
  (let [res
        (->>
         (reductions
          (fn [res curr]
            (if (< (first res) curr)
              (conj res curr)
              (list curr)))
          (list x)
          xs)
         reverse
         (apply max-key count)
         reverse)]
    (if (> (count res) 1)
      res
      '())))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn lsubseq [coll]
  (loop [coll coll longest '[] current '[] lastval -1000]
    (cond (empty? coll) 
            (cond 
              (= (count longest) 1) '[]
              (> (count longest) (count current)) longest
              :else current
            )
          (= (+ lastval 1) (first coll))
            (recur (rest coll) longest (conj current (first coll)) (first coll))
          :else
            (if (> (count longest) (count current))
                (recur (rest coll) longest (vector (first coll)) (first coll))
                (recur (rest coll) current (vector (first coll)) (first coll))
            )
    )     
  )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [nums]
  (letfn [(biggest [old new]
            (if (and (> (count new) (count old))
                     (>= (count new) 2))
              new
              old))]
    (loop [s (rest nums)
           cur [(first nums)]
           big []]
      (if (empty? s)
        (biggest big cur)
        (let [[x & s] s]
          (if (= x (-> cur last inc))
            (recur s (conj cur x) big)
            (recur s [x] (biggest big cur))))))))
johncowie's solution:

1
(fn [v] (concat [] (first (filter #(apply < %) (apply concat (for [x (range (count v) 1 -1)] (partition x 1 v)))))))
jomicoll's solution:

1
2
3
4
5
6
7
8
#(letfn [(rf [[current longest] e]
           (if (= (dec e) (peek current))
                 (let [current (conj current e)]
                   [current (if (> (count current) (count longest))
                              current
                              longest)])
                 [[e] longest]))]
         (get (reduce rf [[] []] %) 1))
jorendorff's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [v]
  (let [partition-by-pairwise
         (fn [break-between? v]
           (loop [todo (rest v)
                  parts []
                  current-part [(first v)]]
             (if (empty? todo)
               (conj parts current-part)
               (let [e (first todo)]
                 (if (break-between? (last current-part) e)
                   (recur (rest todo) (conj parts current-part) [e])
                   (recur (rest todo) parts (conj current-part e)))))))
        longest (apply max-key count (reverse (partition-by-pairwise >= v)))]
    (if (>= (count longest) 2)
      longest
      [])))
jslavin's solution:

1
2
3
4
5
6
7
8
(fn longest [s]
  (second (reduce (fn [acc n]
                    (let [c (first acc)
                          m (second acc)
                          newcurr (if (> n (last c)) (conj c n) [n])
                          newmax (if (and (> (count newcurr) (count m)) (> (count newcurr) 1)) newcurr m)]
                      [newcurr newmax]))
                  [[(first s)][]] (rest s))))
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [coll]
    (->> coll
      ; 1st. Make tails of coll.
      (#(take-while identity (iterate next %)))
      ; 2nd. Take only consecutive elements from the head for each list.
      (map (fn [[c & cs]]
             (loop [[x & xs] cs acc [c] z c]
               (if (= (inc z) x) (recur xs (conj acc x) x) acc))))
      ; 3rd. Take only vectors having 2 or more elements.
      (filter #(< 1 (count %)))
      ; 4th. Take the longest. Take the one appearing first if 2 or more have a same length.
      (reduce #(if (< (count %2) (count %)) % %2) [])
    ))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn longest-increasing-sub-Seq [v]
  ((comp  
    #(if (empty? %) [] (last %))
    (partial sort-by count)
    (partial filter #(> (count %) 1))
 
    #(conj (first %) (last %))
    (partial reduce
 
     (fn [[a,t] i]
       (if (= (dec i) (last t))
         [a,(conj t i)] [(conj a t),[i]]))
 
     [[],[(first v)]])
 
    ) (rest v)))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn prob53 [s]
  (->> (partition 2 1 s)
       (partition-by (fn [[p1 p2]] (> p2 p1)))   ;; grouped by results of function 
 
       ;; ( ((1 0)) ((0 1) (1 2) (2 3)) ((3 0)) ((0 4) (4 5)) )
 
       ;; pull out the groups into new sequences
       ;; a. map first of each element into a vector gets the first of teach subgroup
       ;;  ([1] [0 1 2] [3] [0 4]) 
       ;; b. need to pick up the very last item
       ;; ([1 0] [0 1 2 3] [3 0] [0 4 5])
       (map 
        #(conj
          (into [] (map first %)) (last (last %)))
        )
 
       (filter (fn [[a b]] (> b a)))    ;; pick the ones with increasing vlaues
       ;; ([0 1 2 3] [0 4 5])
 
       (reduce (fn [a b] (if (>  (count b) (count a)) b a)) [])  ;; pick the longest
       ;; [0 1 2 3]
       ))
brendan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
#(first 
   (sort-by count (fn [a b] (compare b a)) 
            (map (fn [l] (if (> (count l) 1) l '() ))
                 (partition-by type
                               (reduce 
                                (fn [m x]
                                  (if (> x (last m))
                                    (conj m x)
                                    (conj m false x)))
                                [(first %)]
                                (rest %)
                                )))))
kuze's solution:

1
2
3
4
5
6
(fn myIncreasingSequence
  [coll]
  (let [min (- (apply min coll) 1)]
    (let [result (reduce #(if (>= (count %1) (count %2) 1) %1 %2) [] 
  (partition-by #(= min %)(reduce #(if (<= %2 (last %1)) (conj %1 min %2) (conj %1 %2)) (vector (first coll)) (rest coll))))]
   (if (>= 1 (count result)) [] result))))
lackita's solution:

1
2
3
4
5
6
7
8
9
10
(fn longest-sub-sequence [c]
  (let [sub-sequences (group-by count (reverse (reduce #(vec (if (< (last (first %1)) %2)
                                                               (cons (conj (first %1) %2) 
                                                                     (rest %1))
                                                               (cons [%2] %1)))
                                                       [[(first c)]] (rest c))))
        longest (first (sub-sequences (apply max (keys sub-sequences))))]
    (if (= (count longest) 1)
      []
      longest)))
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [xs]
  (->> xs
       (partition 2 1)
       (partition-by (fn [[a b]] (= (inc a) b)))
       (map (partial mapcat identity))
       (filter (fn [[a b & _]] (= (inc a) b)))
       (map #(cons (first %) %))
       (map (partial take-nth 2))
       (#(if (seq %)
           (apply max-key count %)
           []))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
#(
let [x (
(fn longest-subseq [maxs news coll]
  (if (empty? coll)
    (if (> (count news) (count maxs))
      news
      maxs
      )
    (if (>= (last news) (first coll))
      (if (> (count news) (count maxs))
        (longest-subseq news [(first coll)] (rest coll))
        (longest-subseq maxs [(first coll)] (rest coll))
         )
      (longest-subseq maxs (conj news (first coll)) (rest coll))
      )
    )
  )
[] [(first %)] (rest %))]
(if (> (count x) 1)
  x
  []
  )
)
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn f [l]
  (letfn [(longest [l i]
            (cond
              (= '() l) '()
              (<= (first l) i) '()
              :else (cons (first l) (longest (rest l) (first l)))))]
    (if (= '() l)
      '()
      (let [here (longest l (dec (first l)))
            later (f (rest l))
            chere (count here)
            clater (count later)]
        (cond
          (< (max chere clater) 2) '()
          (>= chere clater) here
          :else later)))))
leetwinski's solution:

1
(fn [v] (or (first (filter #(apply < %) (mapcat #(partition % 1 v) (range (count v) 1 -1)))) []))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
(fn [l] (let [r
      (reduce #(if (> (count %1) (count %2)) %1 %2)
      '() 
          (filter #(first (first %))
          (partition-by first
            (map 
              #(list (= %1 (dec %2)) %1 %2) 
              l 
              (rest l)))))]
  (if (not (empty? r)) (conj (vec (map second r)) (last (last r))) [])))
malvert's solution:

1
2
3
4
5
6
7
8
(fn [q]
    (apply max-key count []
           (reverse
            (filter
             #(apply < %)
             (for [x (range (count q))
                   y (range (+ 2 x) (+ 1 (count q)))]
               (subvec q x y))))))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [s]
  (let [ans
        (loop [[x & xs] s
               prev '()
               best '()]
          (let [count-best (count best)
                count-prev (count prev)]
          (if (nil? x)
            (if (< count-best count-prev)
              prev
              best)
            (let [p (first prev)]
              (if (and p (< p x))
                (let [new-prev (conj prev x)]
                  (if (< count-best count-prev)
                    (recur xs new-prev new-prev)
                    (recur xs new-prev best)))
                (recur xs (conj nil x) best))))))]
    (if (< (count ans) 2)
      []
      (reverse ans))))
maximental's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [C [s & z]] 
  ((fn g [a [h & t]]
    (if h 
      (if (< (last a) h)
        (g (conj a h) t)
        (let [q (g [h] t)]
          (if (next a) 
            (if (< (C a) (C q)) q a)          
            q)))
      []))
   [s] `(~@z 0)))
count
mbakhterev's solution:

1
(fn [S] (or (first (filter (partial apply <) (mapcat (fn [l] (partition l 1 S)) (range (count S) 1 -1)))) []))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn longest-subseq--group
  [coll] {:pre [(every? integer? coll)]}
  (->> coll
       ;; The following line replaces each element with the longest increasing
       ;; subsequence that ends in that element.
       (reductions #(if (and (seq %1) (> %2 (peek %1))) (conj %1 %2) [%2]) [])
       (group-by count)      ; a map of all increasing susbseqs, keyed by length
       (apply max-key key)
       last                  ; a vector of all longest increasing subseqs
       first                 ; the first, longest increasing subseq
       ((fn [x] (if (= (count x) 1) [] x))))) ; ignoring a singleton subseq
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn longest [coll]
  (let [candidate (apply max-key count
                         (reductions (fn [acc x]
                                       (if (empty? acc)
                                         [x]
                                         (if (= (inc (peek acc)) x)
                                           (conj acc x)
                                           [x])))
                                     []
                                     coll))]
    (if (> (count candidate) 1)
      candidate
      [])))
minitrue's solution:

1
2
3
4
5
6
(fn [xs]
  (let [<< #(apply < %)]
    (apply max-key count
      (cons [] (reverse (map #(cons (first (first %)) (map second %))
                          (filter #(<< (first %))
                            (partition-by << (partition 2 1 xs)))))))))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn longestincreasing [x]
     ((fn longestsub [y]
       (loop [counter 0, result []]
          (if (< counter (count y))
            (if (> (count (get (vec y) counter)) (max (count result) 1))
              (recur (inc counter) (get (vec y) counter))
              (recur (inc counter) result))
            result)))
      (loop [counter (- (count x) 1), q (vec (map vector x))]
                      (if (pos? counter)
                        (if (> (first (get q counter)) (peek (get q (- counter 1))))
                          (recur (dec counter) (assoc 
                                                 (vec (concat (take counter q) (drop (inc counter) q)))
                                                 (- counter 1) 
                                                      (vec (concat (get q (- counter 1)) (get q counter)))))
                          (recur (dec counter) q))
                          q))
  ))
mobiusloop's solution:

1
2
3
4
5
6
7
8
9
10
(fn [l]
  (let [f (fn [a i]
                     (if (= 1 (- i (last (last a))))
                       (concat (butlast a) [(concat (last a) [i])])
                       (concat a [[i]]))
                     )
        p (reduce f [[(first l)]] (rest l))
        m (apply max (map count p))]
    (into [] (some #(if (and (< 1 m) (= m (count %))) %) p))
))
mononite's solution:

1
2
3
4
5
6
(fn [xs]
  (let [all-increasing-seq 
        (reductions #(if (or (empty? %) (< (peek %) %2)) (conj % %2) (vector %2)) [] xs)]
    (->> all-increasing-seq 
         (filter #(> (count %) 1))
         (reduce #(if (> (count %2) (count %)) %2 %) []))))
mouse's solution:

1
2
(fn [t] (apply max-key #(or ({1 -1} (count %)) (count %)) 
                (reductions #(if (= (dec %2) (last %)) (conj % %2) [%2]) [] t)))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn f53 [coll]
  (letfn [(bigger [x y] (if (> (count y) (count x)) y x))]
    (loop [coll coll cur [] max []]
      (if (empty? coll)
        max
        (let [[next & rest] coll
              prev (last cur)]
          (if (and (not (nil? prev))
                   (= next (inc prev)))
            (let [cur (conj cur next)]       
              (recur rest cur (bigger max cur)))
            (recur rest [next] max)))))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn chain [xs]
  (or 
   (first 
    (last 
     (last 
      (group-by count
                (sort-by count
                         (filter #(> (count %) 1) 
                                    (reduce
                                     (fn [memo x]
                                       (if (> x (last (last memo)))
                                         (conj (pop memo) (conj (last memo) x))
                                         (conj memo [x])))
                                     [[999]]
                                     xs))))))) []))
nikelandjelo's solution:

1
2
3
4
5
6
7
(fn [s]
            (->> (for [st (range (count s)) e (range st (inc (count s)))] (drop st (take e s)))
                 (remove #(< (count %) 2))
                 (filter #(apply < %))
                 (reverse)
                 (cons [])
                 (apply max-key count)))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
10
#(let [res (second (reduce (fn [r x] 
          (let [[cur long] r] 
            (if (or (empty? cur) (= x (inc (last cur))))
              (let [new (conj cur x)]
                (if (> (count new) (count long))
                  [new new]
                  [new long]))
              [[x] long])
            )) [[] []] %))] 
  (if (>= (count res) 2) res []))
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn lseq [in-vals]
  (letfn
      [(better-seq [seq1 seq2]
         (if (> (count seq2) (count seq1)) seq2 seq1))
       (lseq2 [vals]
         (loop [current-max []
                current-seq []
                items vals]
           (if-not (seq items)
             (better-seq current-max current-seq)
             (if (every? #(> (first items) %) current-seq)
               (recur current-max (conj current-seq (first items)) (rest items))
               (recur (better-seq current-max current-seq) [(first items)] (rest items))))))]
    (let [result (lseq2 in-vals)]
      (if (> (count result) 1)
        result
        []))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [ls]
           (:best
             (reduce (fn [acc v]
                       (let [{:keys [best curr]} acc
                             curr (if (or (empty? curr)
                                          (= v (inc (last curr))))
                                    (conj curr v)
                                    [v])
                             best (if (and (> (count curr) (count best))
                                           (> (count curr) 1))
                                    curr
                                    best)]
                         {:best best :curr curr})
                       ) {:best [] :curr []} ls)))
owk4057's solution:

1
2
3
4
5
6
7
8
(fn f [coll]
  (let [bigger? (fn [pair] (< (first pair) (second pair)))
        coll (partition 2 1 coll)
        coll (partition-by bigger? coll)
        coll (filter #(bigger? (first %)) coll)
        coll (sort-by count > coll)
        pairs  (first coll)]
    (distinct (apply concat pairs))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
(fn [xs]
  (->> xs
    (partition 2 1)
    (cons [2 1])
    (partition-by (fn [[p n]] (< p n)))
    rest
    (take-nth 2)
    (reduce (fn ([] []) ([z x] (if (> (count x) (count z)) x z))))
    (map vec)
    (reduce (fn ([] []) ([z x] (conj z (x 1)))))))
ozan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [xs]
  (loop [i 0
         j 1
         si 0
         sj 1
         max-i 0
         max-j 1]
    (if (= j (count xs))
      (if (> (- max-j max-i) 1) (subvec xs max-i max-j) [])
      (if (> (xs j) (xs i))
        (recur (inc i) (inc j) si (inc sj) (if (> (- (inc sj) si) (- max-j max-i)) si max-i) (if (> (- (inc sj) si) (- max-j max-i)) (inc sj) max-j))
        (recur (inc i) (inc j) sj (inc sj) max-i max-j)))))
pukeface's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(let [part-incr (fn p [L]
                    (cond (empty? L) '()
                          (= 1 (count L)) (list L)
                          :else
                          (let [parted (p (rest L))]
                               (if (< (first L) (second L))
                                   (cons (cons (first L) (first parted)) (rest parted))
                                   (cons (list (first L)) parted)))))]
                                 (fn [S]
                                     (->> S
                                          (part-incr)
                                          (group-by count)
                                          (#(assoc % 1 [[]]))
                                          (apply max-key key)
                                          (val)
                                          (first))))
quant1's solution:

1
2
3
4
5
6
7
(fn [x] 
  (loop [l [] c [] [x1 & r] x]
    (let [ll (if (and (> (count c) 1) (> (count c) (count l))) c l)]
      (if (nil? x1) ll
        (if (= (last c) (dec x1))
          (recur l (conj c x1) r)
            (recur ll [x1] r))))))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
#(loop [longest '() [fcurr & rcurr :as curr] '() [flst & rlst :as lst] %]
  (if (> (count curr) (count longest)) 
    (recur curr curr lst)
    (if (empty? lst) 
      (if (< 1 (count longest)) (reverse longest) [])
      (if (or (empty? curr) (> flst fcurr))
        (recur longest (conj curr flst) rlst)
        (recur longest (list flst) rlst)
      )
    )
  ))
sbondaryev's solution:

1
2
3
4
5
6
7
8
(fn [col]
  (->> (map #(conj [] %1 %2) (drop-last col) (rest col))
       (partition-by (fn [[a b]] (not= (- b a) 1)))
       (filter (fn [sub] (some (fn [[a b]] (= (- b a) 1)) sub)))
       (sort-by count)
       (last)
       (apply concat)
       (distinct)))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn longest [coll]
  (loop [coll coll longest (seq '())]
    (if (= (first coll) nil)
      (if (> (count longest) 1)
        longest
        [])
      (let [next-inc-seq (loop [coll coll inc-seq [-1]]
                           (if (or (= (first coll) nil) (<= (first coll) (last inc-seq)))
                               (rest inc-seq)
                           (recur (rest coll) (conj inc-seq (first coll)))))]
        (recur (subvec coll (count next-inc-seq))
               (if (>= (count longest) (count next-inc-seq))
                 longest
                 next-inc-seq))))))
sheldon's solution:

1
(fn [v] (let [x (last (sort-by count (filter #(second (first %)) (partition-by #(second %) (map-indexed (fn [a b] [b (= b (inc (nth v a))) a]) (rest v)))))) i (last (first x))] (if x (subvec v i (+ i (inc (count x)))) [])))
silverio's solution:

1
2
3
4
5
6
7
#(->> %
   (partition 2 1)
   (map (fn [[a b]] [(< a b) a b]))
   (partition-by first)
   (filter ffirst)
   (map (comp next distinct flatten))
   (reduce (fn [r s] (if (> (count s) (count r)) s r)) []))
skyrem's solution:

1
2
3
4
5
6
7
8
(fn [coll]
  (loop [p coll t [] r[]]
    (if
      (empty? p) (if (> (count t) (count r)) t (if (= 1 (count r)) [] r))
      (if
        (empty? t) (recur (rest p) (conj t (first p)) r)
        (recur (rest p) (if (= (inc (last t)) (first p)) (conj t (first p)) [(first p)]) (if (= (count t) (inc (count r))) t r))
        ))))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
(fn [[h & t]]
  (loop [p [h], [sh & st :as s] t, r []]
    (if (peek p)
        (if (= (inc (peek p)) sh) 
            (recur `[~@p ~sh] st r) 
            (recur [sh] st
              (let [cp (count p) cr (count r)] 
                (if (and (> cp 1) (< cr cp)) p r)))) 
        r)))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [xs]
  (let
    [result
      (->>
        xs
        (reduce
          (fn
            [[best-so-far current] now]
            (if (or (empty? current) (>= (last current) now))
              [best-so-far [now]]
              (if (>= (count current) (count best-so-far))
                [(conj current now) (conj current now)]
                [best-so-far (conj current now)])))
        [[][]]
      )
      first)]
    (if (< (count result) 2) [] result)))
syeerzy's solution:

1
2
3
4
5
6
7
#(let [res (reduce (fn [a b] (if (> (count b) (count a)) b a)) 
                    (reductions (fn [lis new] 
                                  (if (> new (last lis)) 
                                    (conj lis new) 
                                    [-1 new])) 
                                [-1] %))]
   (if (> (count res) 2) (rest res) []))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn liss [coll]
  (let [wat (->> coll
                 (map list (rest coll))
                 (map (partial apply >))
                 (partition-by identity)
                 (map (juxt first count)))
        largest (->> wat
                     (filter (comp true? first))
                     (map second)
                     (reduce max 0))
        to-drop (if (= largest 0)
                  (count coll)
                  (loop [skipped 0
                         remaining wat]
                    (let [head (first remaining)
                          tail (rest remaining)
                          is-true (true? (first head))
                          num (second head)]
                      (if (and is-true (= num largest))
                        skipped
                        (recur (+ skipped num) tail)))))]
    (take (inc largest) (drop to-drop coll))
  ))
thegeez's solution:

1
2
3
4
5
6
7
8
9
10
(fn [ns]
    (->> ns
         (iterate rest)
         (take-while seq)
         (map (partial reductions (fn [last-in-streak n]
                                    (when (= last-in-streak (dec n))
                                        n))))
         (map (partial take-while identity))
         (remove #(= (count %) 1))
         (reduce (partial max-key count) [])))
zzamboni's solution:

1
2
3
4
5
6
7
8
(fn longest-subseq [s]
  (let [l (count s)]
    (or (first
         (sort-by count >
                  (filter #(every? (partial apply <) (partition 2 1 %))
                          (apply concat (map (fn [n] (map #(take % (drop n s))
                                                          (range 2 (inc (- l n)))))
                                             (range (dec l))))))) [])))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn __ [xs]
  (letfn [(f [y & ys]
             (if (empty? ys)
               (list y)
               (cons y
                     (if (< y (first ys))
                       (apply f ys)
                       '()))))]
    (let [r (->> (range (count xs))
                 (map #(apply f (drop % xs)))
                 (reduce #(if (>= (count %1) (count %2)) %1 %2)))]
      (if (= 1 (count r)) [] r))))
zipzop's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn sq
  ([x] (sq (rest x) [(first x)] []))
  ([x cur mx] 
   (if (empty? x)
     mx
     (if (> (first x) (last cur))
       (let [ncur (conj cur (first x))]
        (if (> (inc (count cur)) (count mx))
         (sq (rest x) ncur ncur)
         (sq (rest x) ncur mx) ))
       (sq (rest x) [(first x)] mx)))))
yusubori's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [coll]
   (let [f (fn [acc n]
             (cond
              (empty? acc) [n]
              (= (dec n) (peek acc)) (conj acc n)
              :else [n]))
         ret (filter #(> (count %) 1)
                     (reductions f [] coll))]
     (if (empty? ret)
       ret
       (apply max-key count ret))))
ydash's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
#(loop [s (rest %), acc [(first %)] ,longest []]
    (let [head (first s), tail (rest s)]
      (cond (empty? s) (if (= 1 (count longest)) []
                           (if (> (count acc) (count longest))
                             acc longest))
            (= (last acc) (dec head)) (recur tail
                                             (conj acc head)
                                             longest)
            (> (count acc) (count longest)) (recur tail
                                                   [head]
                                                   acc)
            :else (recur tail [head] longest))
      ))
vpeurala's solution:

1
(fn [xs] (->> xs (partition 2 1) (map #(cons (- (second %) (first %)) %)) (partition-by #(Integer/signum (first %))) (filter #(<= 0 (first (flatten %)))) (sort-by count >) (first) (map rest) (flatten) (distinct)))
v_bogdanov's solution:

1
2
3
4
5
6
7
(fn [s]
  (let [f first
        spl (partition-by #(< (f %) (last %)) (partition 2 (interleave s (rest s))))
        fi (filter #(< (f (f %)) (second (f %))) spl)]
    (if (empty? fi) []
      (let [g (f (filter #(= (count %) ((fn [x] (apply max (map count x))) fi)) fi))]
    (cons (f (f g)) (map last g))))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn lll [v]
  (loop [acc [] cmp [(first v)] rst (rest v)]
    (if (empty? rst)
      (if (> (count cmp)
             (count acc))
        cmp
        (if (= 1 (count acc))
          []
          acc))
      (let [head (first rst)
            tail (last cmp)]
        (if (> head tail)
          (recur acc (conj cmp head) (rest rst))
          (if (> (count cmp)
                 (count acc))
            (recur cmp [head] (rest rst))
            (recur acc [head] (rest rst))))))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn longest-subseq [coll]
  (let [take-seq (fn [n pred coll]
                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]
                     (take (+ n hits -1) coll)))
        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))
        parts (chop coll)
        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)
        longest (apply max-key count seqs)]
    (if (< (count longest) 2)
      []
      longest)))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [coll]
    (let [geti (fn [z]
    (loop [result []
           progress []
           elts z]
        (cond
            (empty? elts) (conj result progress)
            (or (empty? progress) (< (last progress) (first elts)))
                (recur result (conj progress (first elts)) (rest elts))
            :else
                (recur (conj result progress) [(first elts)] (rest elts)))))    
          ls (filter #(< 1 (count %)) (geti coll))
          _ (map count ls)
          m (if (not (empty? _)) (apply max _) 0)]
      (if (= 0 m) []
        (first (filter #(= m (count %)) ls)))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)