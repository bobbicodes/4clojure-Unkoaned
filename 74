;; 74 Filter Perfect Squares [m]

Takes a string of comma separated integers,
returns a new comma separated string that only contains
the numbers which are perfect squares.

(= (__ "4,5,6,7,8,9") "4,9")
(= (__ "15,16,25,36,37") "16,25,36")

(fn [xs] (apply str (interpose "," (filter #(let [n (Integer. %) sqrt (int 
(Math/sqrt n))] (= n (* sqrt sqrt))) (re-seq #"\d+" xs)))))

#(->> (str "[" % "]")
      (read-string)
      (filter (fn [v] (let [p (int (Math/sqrt v))] (= v (* p p)))))
      (clojure.string/join ","))

(fn [x] (clojure.string/join #"," (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split x #",")))))

(fn [nums]
  (let [isPerfect? (fn [numString]
                     (let [intVal (java.lang.Integer/parseInt numString)
                           sqrtVal (java.lang.Math/sqrt intVal)]
                       (if (= 0.0 (- sqrtVal (int sqrtVal))) true false)))]
    (loop [result "", numSeq (clojure.string/split nums #",")]
      (if-let [numStr (first numSeq)]
        (if (isPerfect? numStr)
          (recur (str result "," numStr) (rest numSeq))
          (recur result (rest numSeq)))
        (subs result 1)))))

(fn [strs]
  (apply str
    (interpose ","
      (filter
        #(= 0.0 (mod (Math/sqrt %) 1))
        (map #(Integer/parseInt %) (.split strs ","))))))
aceeca1's solution:

1
(fn [x] (apply str (interpose "," (filter (fn [x] (some #{x} (map-indexed * (range x)))) (read-string (str "(" x ")"))))))
adereth's solution:

1
2
3
4
5
(fn [s]
  (let [nums (map #(Integer/parseInt %) (.split s ","))
        p2 #(* % %)
        sqs (filter (fn [n] (= n (p2 (int (Math/sqrt n))))) nums)]
    (apply str (interpose \, sqs))))
aferrandi's solution:

1
2
3
(fn perfSquares[x] (clojure.string/join "," (filter 
                                             (fn perfSquare[x] (= (int (Math/pow (int (Math/sqrt x)) 2)) x)) 
                                             (map read-string (clojure.string/split x #",")))))
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s] 
   (->> 
     (clojure.string/split s #",")
     (map #(Integer. %))
     (filter 
       (fn [x] (some
                 #(= (* % %) x)
                 (range 1 x))))
     (interpose ",")
     (apply str)))
alanforr's solution:

1
2
3
4
5
(fn [d] 
  (letfn [(mysqrt [a] (int (Math/sqrt a)))
          (perfectsquare? [b] (= b (*' (mysqrt b) (mysqrt b))))
          (getintegers [c] (map #(Integer/parseInt %) (clojure.string/split c #",")))]
    (clojure.string/join "," (filter #(perfectsquare? %) (getintegers d)))))
allenl's solution:

1
2
3
4
5
6
7
(fn perfectsq [numlist]
  (let [nums (map read-string (clojure.string/split numlist #",") )
        is-perfect-sq (fn [n]
                        (first (for [i (range 2 (inc (/ n 2))) :when (= (/ n i) i)] n)))]
    (clojure.string/join "," (filter is-perfect-sq nums))
    )
  )
andthorn's solution:

1
2
3
4
5
(fn [s]
  (let [tokens (re-seq #"\d+" s)
        numbers (map read-string tokens)
        squares (filter #(> 0.0000000001 (let [r (Math/sqrt %)] (Math/abs (- r (Math/round r))))) numbers)]
    (apply str (interpose "," (map str squares)))))
anjensan's solution:

1
2
3
4
5
(fn [s]
    (->> (read-string (str \[ s \]))
      (filter #(let [q (Math/sqrt %)] (= % (* q q))))
      (interpose \,)
      (apply str)))
astangl's solution:

1
2
3
4
5
6
7
8
(fn
  [s]
  (let [nums (map read-string (vec (.split s ",")))
        square (fn [n] (let [divs (take-while #(<= (* % %) n) (range))
                             lst (last divs)]
                         (and lst (= n (* lst lst)))))
        sqs (filter square nums)]
    (reduce #(.concat % %2) (interpose "," (map str sqs)))))
austintaylor's solution:

1
2
3
4
(fn [s]
  (apply str (interpose ","
    (filter #(let [root (Math/sqrt %)] (= root (int root)))
      (map #(Integer/parseInt %) (.split s ","))))))
awebb's solution:

1
2
3
(fn [s] (clojure.string/join ","
  (filter #(= 0.0 (mod (Math/sqrt %) 1)) 
    (read-string (str "[" s "]")) )) )
bendykst's solution:

1
2
3
4
5
(fn [str] 
  (clojure.string/join "," 
    (filter 
      #(= 0.0 (mod (Math/sqrt (Integer. %)) 1))
      (clojure.string/split str #","))))
benhammond's solution:

1
2
3
4
5
(fn [s]
    (clojure.string/join ","
                         (filter #(zero? (- % (java.lang.Math/pow (bigint (java.lang.Math/sqrt %)) 2)))
                                 (map bigint (clojure.string/split s #","))
                                 )))
benizi's solution:

1
2
3
4
5
6
(fn [string]
  (->> string
       (#(clojure.string/split % #","))
       (map read-string)
       (filter #(= (Math/floor %) (let [s (Math/floor (Math/sqrt %))] (* s s))))
       (clojure.string/join ",")))
bobuhiro11's solution:

1
2
3
4
(fn [s]
  (clojure.string/join "," (filter 
    #(= (double (read-string %)) (Math/pow (Math/sqrt (double (read-string %))) 2))
    (clojure.string/split s #"[,]"))))
burner's solution:

1
2
3
4
5
6
7
(letfn [(square? [n]
                (some #(= n (* % %)) [(dec (int (Math/sqrt n)))
                                      (int (Math/sqrt n))
                                      (inc (int (Math/sqrt n)))]))]
        (fn [s] (clojure.string/join ","
                                     (filter square? (map #(Integer. %)
                                                          (clojure.string/split s #","))))))
caterpillar's solution:

1
2
3
4
5
6
#(apply str (interpose "," 
                       (filter (fn[s]
                                 (let [si (Integer/parseInt s)
                                       sqrtSi (int (Math/sqrt si))]
                                   (= (* sqrtSi sqrtSi) si)))
                               (vec (.split #"," %)))))
cc787's solution:

1
2
3
4
5
6
7
(fn [s]
   (letfn [(is_square? [x] (= (#(* % %) (int (Math/sqrt x))) x))]
 
     (->> s (re-seq #"\d+")
          (map #(Integer/parseInt %))
          (filter is_square?)
          (clojure.string/join ","))))
chunchangshao's solution:

1
#(case (count %) 11 "4,9" "16,25,36")
ctzsm's solution:

1
2
3
(fn [s] (apply str (interpose \, 
  (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))
(map #(Integer/parseInt %) (clojure.string/split s #","))))))
dan7es's solution:

1
2
3
4
5
6
(let [long? #(== (long %) %)]
  (fn perfect-sqrs [s]
    (->> (.split #"," s)
         (map read-string)
         (filter (comp long? #(Math/sqrt %)))
         (clojure.string/join ","))))
daniels's solution:

1
2
3
4
5
(fn [x]
  (reduce (fn [a b] (str a "," b))
    (filter 
     #(== (int (Math/sqrt %)) (Math/sqrt %)) 
     (map read-string (clojure.string/split x #"\,")))))
daowen's solution:

1
2
3
4
(fn [csv]
  (let [nums (map #(Long/valueOf %) (re-seq #"\d+" csv))
        squares (filter #(-> % Math/sqrt (rem 1) zero?) nums)]
    (clojure.string/join "," squares)))
del680202's solution:

1
2
3
4
5
(fn [str]
  (letfn [(find-sq [n] (some true? (for [r (range 0 (inc (/ n 2)))] (= (* r r) n))))]
      (clojure.string/join "," (filter find-sq (map #(Integer. %) (re-seq #"\d+" str))))
  )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [s]
  (let [seqsqr (map #(* % %) (range))]
    (letfn [(integers [x] (map read-string (clojure.string/split x #",")))
            (makestring [x] (clojure.string/join "," x))
            (perfectsqr 
             [n] 
             (letfn [(perfectsqrint 
                      [x sq]
                      (if (= x (first sq)) true
                        (if (< x (first sq)) false
                          (perfectsqrint x (rest sq))
                          )))]
               (perfectsqrint n seqsqr)))
            (filterint 
             [l] 
             (if (empty? l) []
               (let [fl (first l) frl (filterint (rest l))]
                 (if (perfectsqr fl) (concat [fl] frl) frl)
                 )))]
    (makestring (filterint (integers s)))
    )))
devm33's solution:

1
2
3
4
5
6
(fn [numstr]
  (let [isint #(== % (int %))]
    (clojure.string/join ","
      (filter #(isint (Math/sqrt %))
              (map #(Integer/parseInt %)
                   (.split numstr ","))))))
dwelte's solution:

1
2
3
4
5
6
7
8
(fn [s] (apply str
  (interpose ","
    (filter
      #(let [
          x (Integer/parseInt %)
          v (Math/round (Math/sqrt x))]
        (= (* v v) x))
      (.split s ",")))))
dzholev's solution:

1
2
3
4
5
6
7
(fn [s]
  (letfn [(is-perf-sq? [sn]
                       (let [n (Integer/parseInt sn)
                             sqn (Math/sqrt n)
                             rnd (long sqn)]
                         (zero? (- sqn rnd))))]
    (clojure.string/join "," (filter is-perf-sq? (.split s ",")))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [x]
    (let [ num_seq (map read-string (re-seq #"[0-9]+" x))
           squares (map #(* %1 %1) (iterate inc 1))
           in?     (fn [n l ]
                    (let [[h & t] l]
                        (cond
                        (empty? t) false 
                        (< n h)    false 
                        (= n h)    n 
                        :else (recur n t))))
           str-nums (fn [s]  (clojure.string/join "," s))]
    (str-nums (filter #(in? %1 squares) num_seq))))
ericw's solution:

1
2
3
4
(letfn [                                                                                                                                                
    (is-square? [n] (zero? (mod (Math/sqrt n) 1)))                                                                              
    (perfect-squares [string] (clojure.string/join "," (filter is-square? (map #(Integer. %) (clojure.string/split string #",")))))]                    
        perfect-squares)
featalion's solution:

1
2
3
4
5
6
7
8
(fn [s]
  (let [nums (map #(Integer/parseInt %) (re-seq #"\d+" s))
        nums->str (partial clojure.string/join ",")]
    (nums->str
     (filter (fn [n]
               (let [sqrt (int (Math/sqrt n))]
                 (= n (* sqrt sqrt))))
             nums))))
finsternis's solution:

1
2
3
4
5
(fn [s]
  (letfn [(ps? [n] (let [r (int (Math/sqrt n))] (= n (* r r))))]
    (clojure.string/join
     ","
     (filter ps? (map read-string (clojure.string/split s #","))))))
flububb's solution:

1
2
3
4
5
6
7
8
(fn filter-sq [s]
  (clojure.string/join ","
    (filter
      (fn [x] 
        (= x (last (take-while 
                     #(<= % x) 
                     (map #(* % %) (range))))))
      (map #(Integer. %) (re-seq #"\d+" s)))))
garyxia's solution:

1
2
3
4
5
(fn perf-square [s]
  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #","))
        all-perf-sq  (set (map #(* % %) (range 100)))
        sq-nums (filter all-perf-sq nums)]
(apply str (interpose "," sq-nums))))
geekerzp's solution:

1
2
3
4
5
6
7
(fn [s]
    (->> s
         (#(clojure.string/split % #","))
         (map read-string)
         (filter #(== (Math/sqrt %) (int (Math/sqrt %))))
         (clojure.string/join ","))
    )
glchapman's solution:

1
2
3
4
5
6
#(->> (read-string (str "[" % "]"))
      (filter 
        (fn [n]
          (let [root (int (Math/sqrt n))]
            (= n (* root root)))))
      (clojure.string/join ","))
goaranger's solution:

1
2
3
4
5
(fn [arg]
  (clojure.string/join "," 
    (filter #(= (java.lang.Math/ceil (java.lang.Math/sqrt (Integer. %)))
                (java.lang.Math/floor (java.lang.Math/sqrt (Integer. %)))) 
            (clojure.string/split arg #","))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
(fn [s]
  (->> s
       (#(.split % ","))
       (map read-string)
       (filter #(= (Math/sqrt %1)
                   (Math/floor (Math/sqrt %1))))
       (map str)
       (clojure.string/join ",")))
happycrisis's solution:

1
2
3
4
5
6
7
(fn [ss]  
  (->> ss 
       (re-seq #"\d+")  
       (map read-string)
       (filter #(let [sr (Math/sqrt %)] (== (int sr) sr)))
       (map str)
       (clojure.string/join "," )))
hisba's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn fps [s]
  (let [bab_sqrt? (fn [m]
                    (loop [n (quot m 2) seen #{}]
                      (let [n2 (quot (+ n (/ m n)) 2)]
                        (cond (seen n2) false
                              (= m (* n2 n2)) true
                              :else (recur n2 (conj seen n2))))))]
    (->> s
         (re-seq #"\d+")
         ; a perfect square never ends  in 2, 3, 7 or 8
         (remove #(#{\2 \3 \7 \8} (last %)))
         (map read-string)
         ; using Babylonian algo to check if the number is a perfect square
         (filter bab_sqrt?)
         (interpose \,)
         (apply str))))
icamts's solution:

1
(fn [s] (clojure.string/join "," (filter #(zero? (rem (Math/sqrt %) 1)) (map #(Integer/valueOf %) (re-seq #"\d+" s)))))
immo's solution:

1
Scored 115, before 4clojure started saving solutions.
jarlax's solution:

1
2
3
4
5
6
7
8
9
(fn [s]
  (let [square #(* % %)
        isqrt #(int (Math/sqrt %))
        square? #(= (square (isqrt %)) %)]
    (->> (re-seq #"\d+" s)
         (map read-string)
         (filter square?)
         (map str)
         (clojure.string/join ","))))
jedo's solution:

1
2
3
4
5
6
7
8
(fn fperfsq [s]
(letfn [(str2seq [x]
(map #(Integer/parseInt %) (clojure.string/split x #"\,")))
  (seq2str [y]
(apply str (butlast (interleave y (repeat \,)))))]
  (seq2str (filter (into #{} (take-while #(>= (apply max (str2seq s)) %) (map #(* % %) (range)))) (str2seq s)))
)
)
jeff_terrell's solution:

1
2
3
4
(fn [s]
  (let [xs (map #(Integer. %) (clojure.string/split s #","))
        p? (fn [x] (some #(= x (* % %)) (range 2 x)))]
    (clojure.string/join "," (filter p? xs))))
johncowie's solution:

1
2
3
4
5
6
(fn [s]
   (clojure.string/join
    ","
    (filter
          #(= (mod (Math/sqrt (read-string (str %))) 1) 0.0)
          (clojure.string/split s #","))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [s]
  (let [nums 
        (map (fn [s] (. Integer parseInt s))     
             (clojure.string/split s #","))
        
        perfect-square
        (fn [n]
          (loop [x 1]
           (if (>= x n) nil
            (if (and (= (/ n x) x) (zero? (mod n x)))
              n
              (recur (inc x))))))]
    (clojure.string/join ","                    
     (map str (filter perfect-square nums)))))
jorendorff's solution:

1
2
#(clojure.string/join "," (filter (fn [x] (= ((fn [x] (* x x)) (int (. Math sqrt x))) x))
                                  (map read-string (clojure.string/split % #","))))
jslavin's solution:

1
2
3
4
5
6
7
8
(fn psquares [s]
  (let [nums (map #(Integer/parseInt %) (re-seq #"\d+" s))
        m (reduce max nums)
        range  (take-while #(<= % m) (map #(* % %) (iterate inc 1)))
        vals (reduce (fn [acc v] (if (some #(= v %) range)  (conj acc v) acc))[] nums)]
    (apply str (interpose "," vals))
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
(fn [s]
  (->> s
    (re-seq #"[0-9]+")
    (map #(Integer/parseInt %))
    (filter #(let [r (Math/sqrt %)] (= r (int r))))
    (interpose ",")
    (apply str)))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn filter-perfect-squares [s]
  (letfn [(squares? [x]
            (loop [n x]
              (cond (= (* n n) x) true
                    (= n 0) false
                    :else (recur (dec n)))))]
    
    ((comp 
 
      (partial reduce #(str % "," %2))
      (partial filter squares?)
      (partial map read-string)
 
      ) (re-seq #"\d+" s))))
blucas's solution:

1
2
3
4
5
(fn prob74 [comma-string]
  (let [string (clojure.string/split comma-string #",")
        nums (map read-string string)
        ]
    (apply str (interpose "," (filter #(let [x (Math/sqrt %)] (= (float (int x)) x))  nums)))))
brendan's solution:

1
2
3
4
(fn [s] (clojure.string/join "," 
  (filter 
    #(zero? (rem (Math/sqrt (Integer. %)) 1))
  (.split s ","))))
kuze's solution:

1
2
3
4
5
(fn myPerfectSquares
  [strNums]
  (let [powers (fn [x] (= 0.0 (mod (java.lang.Math/sqrt x) 1)))
        nums (map #(Integer. %) (clojure.string/split strNums #"\,"))]
     (apply str (interpose "," (filter #(powers %) nums)))))
lackita's solution:

1
2
3
4
5
6
7
8
(fn [s] 
  (clojure.string/join 
   "," 
   (filter #(some (fn [x] 
                    (= (int (Math/pow x 2)) 
                       (Integer/parseInt %)))
                  (range (Integer/parseInt %)))
           (clojure.string/split s #","))))
lambda4fun's solution:

1
2
3
4
(fn [s]
  (->> (clojure.string/split s #",")
       (filter #(zero? (mod (Math/sqrt (Double. %)) 1)))
       (clojure.string/join ",")))
lasthemy's solution:

1
2
3
4
5
(comp (partial clojure.string/join ",")
      (partial filter #(let [rt (Math/sqrt %)] (= rt (float (int rt)))))
      (partial map read-string)
      #(clojure.string/split % #",")
      )
lbarrett's solution:

1
2
3
(fn [s]
  (let [ns (map #(Integer/parseInt %) (clojure.string/split s #","))]
    (clojure.string/join "," (filter #(== % (-> % Math/sqrt Math/floor (Math/pow 2))) ns))))
leetwinski's solution:

1
2
3
4
5
(fn [s]
  (clojure.string/join "," 
    (filter 
      #(-> % Integer. Math/sqrt (rem 1) zero?)
      (re-seq #"\d+" s))))
littlejp2046's solution:

1
2
3
4
5
(fn [s] 
    (reduce #(str %1 "," %2)
      (filter 
        #(= (mod (java.lang.Math/sqrt (java.lang.Double/parseDouble %1)) 1) 0.0)
        (clojure.string/split s #"[,]+"))))
malvert's solution:

1
2
3
4
5
6
(fn [s] 
  (apply str 
    (interpose "," 
      (filter #{4 9 16 25 36} 
        (map #(Integer/decode %) 
          (.split s ","))))))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
(fn [sq] 
  (clojure.string/join 
    "," 
    (filter 
     #(loop [n % i 1] 
        (cond 
         (neg? n) false 
         (zero? n) true 
         :else (recur (- n i) (+ 2 i)))) 
     (map read-string (clojure.string/split sq #",")))))
maximental's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s] 
  (apply str  
    (interpose "," 
      (filter (fn [k] 
                (= k (last 
                       (take-while #(>= (- k %) 0) 
                                    (map #(* % %) 
                                          (iterate inc 1)))))) 
              (map #(Integer/parseInt %) 
                    (re-seq #"-*\d+" s))))))
mbakhterev's solution:

1
(fn [s] (->> (re-seq #"\d+" s) (map read-string) (filter (fn [n] (let [x (Math/sqrt n)] (== (* x x) n)))) (clojure.string/join ",")))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn filter-squares
  [s] {:pre [(string? s)]}
  (let [;; We need a predicate to see if a number is a perfect square. The
        ;; simplest approach that dodges any potential floating-point concerns
        ;; is to take the square root, round that off to the nearest integer,
        ;; square that, and see if we ended up with what we started with.
        square? (fn [n]
                  (let [root (->> n Math/sqrt Math/round)]
                    (= n (* root root))))]
 
    (->> (clojure.string/split s #",") ; ["1" "7" "16" "37"]
         (map #(Integer/parseInt %))   ; [1 7 16 37]
         (filter square?)              ; [1 16]
         (clojure.string/join \,))))   ; "1,16"
mfikes's solution:

1
(fn [s] (clojure.string/join "," (map str (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split s #","))))))
minitrue's solution:

1
2
3
4
(fn [s]
  (->> (re-seq #"\d+" s)
       (filter (comp #(= % (Math/ceil %)) #(Math/sqrt %) read-string))
       (clojure.string/join ",")))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn onlysquares [x]
           (apply str 
                  (interpose "," 
                             (filter (fn issquare? [n]
                                       (if (not (number? n))
                                         false
                                         (if (neg? n)
                                           false
                                           (if (== (- (Math/sqrt n) (Math/floor (Math/sqrt n))) 0)
                                             true
                                             false))))
                                     (map #(Integer/parseInt %) 
                                          (map #(apply str %) 
                                               (filter #(Character/isDigit (first %)) 
                                                       (partition-by #(Character/isDigit %)
                                                       (vec x)))))))))
mobiusloop's solution:

1
2
3
4
5
6
7
8
(fn [s]
(clojure.string/join ","
(filter
 #(let [r (Math/sqrt %1)] (= 0.0 (- r (int r))))
 (map #(Integer/parseInt %) (clojure.string/split s #","))
 )
)
)
mononite's solution:

1
2
3
4
(fn [s]
  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #","))
        ff (fn [n] (some #(= (* % %) n) (range n)))]
    (clojure.string/join "," (filter ff xs))))
mouse's solution:

1
2
3
(fn [s] (clojure.string/join ","
           (filter (set (map #(str (* % %)) (range 9)))
                   (re-seq #"\d+" s))))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s]
  (letfn [(perfect-square? [n]
            (let [d (Math/sqrt n)
                  i (double (int d))]
              (= d i)))]
    (->> (re-seq #"\d+" s)
         (map #(Integer/parseInt %))
         (filter perfect-square?)         
         (interpose ",")
         (apply str))))
nagi's solution:

1
2
3
4
5
6
7
(fn js [in-str]
  (let [input (map read-string (clojure.string/split in-str #","))
        squares (map #(* % %) (range 10))
        output (filter #(some #{%} squares) input)
        out-str1 (clojure.string/replace (str (apply list output)) " " "," )
        out-str2 (clojure.string/replace out-str1 #"[\(\)]" "")]
    out-str2))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
(fn perf-sq [text]
  (let [perf-sq? (fn [x]
    (let [rt (int (Math/sqrt x))]
      (= x (* rt rt))))]
    (->> (re-seq #"\d+" text)
         (map #(Integer/parseInt %))
         (filter perf-sq?)
         (interpose \,)
         (apply str))))
noiseehc's solution:

1
2
3
4
(fn [s] 
   (clojure.string/join \, (map str 
   (filter #(let [a (java.lang.Math/round (java.lang.Math/sqrt %))] 
              (= (* a a) %)) (map read-string (clojure.string/split s #"\,"))))))
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn fpf [comma-nums]
  (let [csplit (fn [text] (clojure.string/split text #","))
        cjoin  (fn [ns] (clojure.string/join "," ns))
        perfect-square (fn [n]
                         (let [root (int (Math/sqrt n))]
                            (= n (* root root))))]
    (->> comma-nums
         csplit
         (map #(Long/parseLong %))
         (filter perfect-square)
         cjoin)))
nothsaevets's solution:

1
2
3
4
5
6
7
8
(fn [s]
           (-> s 
               (clojure.string/split #",")
               (->> (map #(Integer/parseInt %))
                    (filter (fn [v]
                              (let [sqrt (Math/sqrt v)]
                                (= (Math/floor sqrt) (Math/ceil sqrt)))))
                    (clojure.string/join ","))))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn myf2 [s]
  (let [square? (fn [n]
                  (->> (range 1 (inc n))
                    (map #(int (Math/pow % 2)))
                    (some #(= % n))))]
  (->> (.split s ",")
       (map #(Integer/parseInt %))
       (filter square?)
       (interpose ",")
       (apply str)
       )))
ownwaterloo's solution:

1
2
3
4
5
6
(fn [xs] (->>
  (clojure.string/split xs #",")
  (map read-string)
  (filter #(let [r (Math/sqrt %)] (== % (* r r))))
  (interpose \,)
  (apply str)))
ozan's solution:

1
2
3
4
(fn [xs]
  (clojure.string/join "," (map str (filter
   #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1))
   (clojure.string/split xs #"\,")))))
pukeface's solution:

1
2
3
4
5
#(->> %
         (re-seq #"\d+")
         (map read-string)
         (filter (set (map (fn [a] (* a a)) (range 9))))
         (clojure.string/join ","))
quant1's solution:

1
2
(fn [x] (->> x (re-seq #"\d+") (map #(Integer/parseInt %))
                (filter #(let [r (int (Math/sqrt %))] (= (* r r) %))) (interpose \,) (apply str)))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s]
    (let [numset (read-string (str "[" s "]"))]
      (clojure.string/join 
       ","
       (take 
        (count numset)
        (filter
         (set numset)
         (map #(* % %) (range (apply max numset)))
)))))
sbondaryev's solution:

1
2
3
4
5
6
7
(fn f [str]
  (let [xs (map read-string (re-seq #"\d+" str))]
    (->> (map #(Math/sqrt %) xs)
         (map int)
         (map #(* % %))
         (#(filter (set %) xs))
         (clojure.string/join ","))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
(fn to-union [s]
  (let [nums (apply conj (sorted-set) (map #(Integer. %) (clojure.string/split s #",")))]
    (reduce #(str %1 "," %2)
            (clojure.set/intersection
             (apply conj 
                    (sorted-set) 
                    (rest (take 
                           (inc (Math/ceil (Math/sqrt (apply max nums)))) 
                           (map #(* % %) (range)))))
             nums))))
sheldon's solution:

1
(fn [s] (clojure.string/join "," (filter (set (map #(str (* % %)) (range 100))) (#(re-seq #"\d+" %) s))))
silverio's solution:

1
2
3
4
5
6
(fn [s] (->> s
    (re-seq #"\d+")
    (map #(Integer/parseInt %))
    (filter #(= (float %) (* (Math/sqrt %) (Math/sqrt %))))
    (interleave (repeat ","))
    rest (apply str)))
skyrem's solution:

1
2
3
4
5
(fn [s]
  (letfn [(msqrt [x] (Math/sqrt x))]
    (apply str 
           (interpose "," (filter #(== (msqrt %) (int (msqrt %)))
                                      (map read-string (clojure.string/split s #",")))))))
soul_awaker's solution:

1
2
3
4
5
(fn [f x]
  (apply str (butlast (interleave (f x) (repeat \,)))))
(fn [x]
  (filter #(zero? (rem % (Math/sqrt %))) 
    (map #(Long/valueOf %) (re-seq #"\d+" x))))
staafl2's solution:

1
2
3
4
5
6
7
(fn [s]
  (->>
    (clojure.string/split s #",")
    (map #(Integer. %))
    (filter #(== % (Math/pow (int (Math/sqrt %)) 2)))
    (map str)
    (clojure.string/join ",")))
syeerzy's solution:

1
2
3
#(clojure.string/join \, 
                      (filter (fn [n] (#{4 9 16 25 36} n)) 
                              (read-string (str \[ % \]))))
tclamb's solution:

1
2
3
4
5
(letfn [(squared [n] (* n n))
        (perfect-square? [n] (= n (squared (int (Math/sqrt n)))))]
  (fn [s]
    (let [perfect-squares (filter #(perfect-square? (Integer. %)) (.split s ","))]
      (apply str (interpose "," perfect-squares)))))
thegeez's solution:

1
2
3
4
5
6
7
(fn [s]
    (->> s
         (re-seq #"\d+")
         (map #(Long/parseLong %))
         (filter #(zero? (mod (Math/sqrt %) 1)))
         (interpose ",")
         (apply str)))
zzamboni's solution:

1
2
3
4
5
6
(fn [s]
  (->> (clojure.string/split s #",")
       (map read-string)
       (filter #(let [q (Math/sqrt %)] (== q (int q))))
       (interpose ",")
       (apply str)))
zoltanjarai's solution:

1
2
3
4
5
6
7
(fn __ [s]
  (->> (clojure.string/split s #",")
       (map #(Integer. %))
       (filter (fn [x]
                 (let [s (int (Math/floor (Math/sqrt x)))]
                   (= (* s s) x))))
       (clojure.string/join ",")))
zipzop's solution:

1
2
3
4
5
6
;(filter #((let [v (int %)] = (* (int (Math/sqrt v)) (int (Math/sqrt v)) )  v))) 
(fn [s]
  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #","))
        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))
        perfect (filter psquare? nums)]
    (apply str (interpose "," perfect))))
yusubori's solution:

1
2
3
4
5
6
7
(fn [s]
  (->> s
       (re-seq #"\d+")
       (map read-string)
       (filter (fn [n] (some #(= (* % %) n) (range n))))
       (interpose ",")
       (apply str)))
ydash's solution:

1
2
3
4
5
6
7
(fn [s]
  (clojure.string/join
   ","
   (filter (fn [n]
             (some #(= (* % %) n)
                   (take-while #(<= (* % %) n) (range))))
           (read-string (str \[ s \])))))
vpeurala's solution:

1
2
3
4
5
(fn [xs]
  (letfn [(perfect-square? [n] (let [sqrt (Math/round (Math/sqrt n))] (= n (* sqrt sqrt))))
          (to-ints [xs] (map #(Integer/parseInt %) (re-seq #"\d+" xs)))
          (perfect-squares [xs] (filter perfect-square? (to-ints xs)))]
                   (apply str (interpose "," (map str (perfect-squares xs))))))
v_bogdanov's solution:

1
2
3
4
#(clojure.string/join
  ","
  (filter (fn [x] (zero? (mod (Math/sqrt x) 1)))
          (read-string (str "[" % "]"))))
unionx's solution:

1
2
3
4
(fn [s]
          (clojure.string/join ","
                               (filter #(= (Math/pow (Math/sqrt (bigint %)) 2) (float (bigint %)))
                                       (clojure.string/split s #","))))
trxeste's solution:

1
2
3
4
5
(fn [s]
  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #","))
        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))
        perfect (filter psquare? nums)]
    (apply str (interpose "," perfect))))
transfinite's solution:

1
2
3
4
5
6
7
8
(fn
  [coll]
  (let [is (map read-string (clojure.string/split coll #","))]
    (clojure.string/join
     ","
     (sort (clojure.set/intersection
            (set is)
            (->> is (apply max) Math/sqrt inc range (map #(* % %)) set))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)