;; 79 Triangle Minimal Path [h]

Calculates the sum of the minimal path through a triangle.
The triangle is represented as a collection of vectors.
The path should start at the top of the triangle
and move to an adjacent number on the next row
until the bottom of the triangle is reached.

(= 7 (__ '([1]
          [2 4]
         [5 1 4]
        [2 3 4 5]))) ; 1->2->1->3
(= 20 (__ '([3]
           [2 4]
          [1 9 3]
         [9 9 2 4]
        [4 6 6 7 8]
       [5 7 3 5 1 4]))) ; 3->4->3->2->7->1

(fn collapse [p] (let [combine (fn [a b] (map + (map #(apply min %) (partition 2 1 a)) b))] (first (reduce combine (reverse p)))))

(fn [xxs]
  (letfn [(red [down up]
               (map + up (map min down (rest down))))]
    (->> xxs reverse (reduce red) first)))

(fn
  f
  ([s] (f s 0))
  ([s i]
   (if (empty? (rest s))    
     (get (first s) i)
     (min 
      (+ (get (first s) i) (f (rest s) i)) 
      (+ (get (first s) i) (f (rest s) (inc i)))))))

(letfn[(minPaths [triangle, row]
                 (let [currentRow (nth triangle row)]
                   (if (= (inc row) (count triangle)) currentRow;last row is the always the minimal
                     (let [nextMinimal (map #(apply min %) (partition 2 1 (minPaths triangle (inc row))))];[2 3 4 5]->((2 3) (3 4) (4 5))->(2 3 4)
                       (map + currentRow nextMinimal)))))];get the current minimal path
  (fn [triangle]
    (first (minPaths triangle 0))));minPaths returns a sequence, but only a single value is needed

;; 2016:
(fn [rows]
  (let [expand  #(concat (take 1 %) , (map min (butlast %) (rest %)) , (take-last 1 %))
        combine #(map + (expand %1) %2)]
    (->> (reduce combine rows)
         (apply min))))
 
;; 2012:
;; (fn [rows]
;;  (apply min (flatten (reduce
;;    (fn [t s]
;;          (map-indexed
;;              (fn [i v]
;;                  (mapcat (fn [vs] (map #(+ % v) vs)) (take (min (inc i) 2) (drop (max (dec i) 0) t))))
;;          s))
;;
;;    [[0]] rows))))
aceeca1's solution:

1
(fn [x] (apply min (reduce (comp #(map min (concat % [100000]) (concat [100000] %)) (partial map +)) [0] x)))
adereth's solution:

1
2
3
4
5
6
#(apply min
     (reduce
      (fn [a v] (map min
                     (map + (cons Double/POSITIVE_INFINITY a) v)
                     (map + (concat a [Double/POSITIVE_INFINITY]) v)))
      %))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn triangleX [t]
    (letfn 
        [
            (triangleRec [t i sum]
                (if (empty? t)
                    sum
                    (let [
                        t0 (first t)
                        ti (get t0 i)
                        i1 (inc i)
                        ti1 (get t0 i1) 
                    ]
                        (min (triangleRec (rest t) i (+ sum ti)) (triangleRec (rest t) i1 (+ sum ti1)))
                    )
                )
            )
        ]
        (triangleRec (rest t) 0 (first (first t)) )
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn min-way [triangle]
  (->> [[0]]
    (iterate (fn [shifts]
               (let [l (count (first shifts))
                     mask (concat [0] (repeat l 1))
                     old-shifted (map (partial cons 0) shifts)
                     masked (map (fn [way] (map + way mask)) old-shifted)]
                 (concat old-shifted masked))))
    (drop (- (count triangle) 1))
    first
    (map (fn [shifts]
           (map (fn [nods shift] (drop shift nods)) triangle shifts)))
    (map (fn [way] 
           (map first way)))
    (map (partial reduce +))
    (apply min)))
alanforr's solution:

1
2
3
4
5
6
7
(fn [tri]
  (letfn [(minfrom [triangle ind]
            (if (empty? triangle) 0
                (min
                 (+' (nth (first triangle) ind) (minfrom (rest triangle) ind))
                 (+' (nth (first triangle) ind) (minfrom (rest triangle) (inc' ind))))))]
    (minfrom tri 0)))
allenl's solution:

1
2
3
4
5
6
7
8
9
(fn f [t]
  (->> t
       reverse
       (reduce
        (fn [bottom-row x]
          (map +
               (map (partial apply min) (partition 2 1 bottom-row))
               x)))
       first))
andthorn's solution:

1
2
3
4
5
6
7
(fn [t] 
  (let [minsum (fn [x y] (if (< (reduce + x) (reduce + y)) x y))]
    (loop [path (map vector (last t)) t (butlast t)]
      (if t
        (recur (map-indexed (fn [i e] (cons e (minsum (nth path i) (nth path (+ i 1))))) (last t))
               (butlast t))
        (reduce + (first path))))))
anjensan's solution:

1
2
3
4
5
6
(fn [t]
  (first
    (reduce
      (fn [a b]
        (map #(+ %1 (min %2 %3)) b a (rest a)))
      (reverse t))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn
  [coll]
  ; work from bottom to top, each row calculating min of each pair of
  ; elements and then summing the resultant vector to the vector above
  (letfn [(add-v [vold vnew]
            (lazy-seq
              (if (seq vnew)
                (cons (+ (min (first vold)
                              (second vold))
                         (first vnew)) (add-v (rest vold) (rest vnew)))
                nil)))]
    (first (reduce add-v (reverse coll)))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [t]
  (apply min
    (map first
      (reduce
        (fn [previous row]
          (mapcat
            #(vector
              (list
                (+ (first %) (nth row (last %)))
                (last %))
              (list
                (+ (first %) (nth row (inc (last %))))
                (inc (last %))))
            previous))
        (vector (list (ffirst t) 0))
        (rest t)))))
awebb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn tmp [[a b & r]]
  (if b
      (recur
        (cons
          (map +
            (flatten 
              (list (first a)
                    (map (partial apply min) (partition 2 1 a))
                    (last a)))
            b)
        r))
      (apply min a)))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [rows] 
  (letfn [(min-middle [top mid-bot]
            (map min
              (map +       top  mid-bot) 
              (map + (rest top) mid-bot)))
          (min-row [top bot] 
            (concat 
              [(+ (first top) (first bot))] 
              (min-middle top ((comp rest drop-last) bot))
              [(+ (last top) (last bot))]))]
    (apply min (reduce min-row rows))))
benhammond's solution:

1
2
3
4
(fn [t]
    (let [st (fn [vvec] (mapcat (fn [v] (mapv (partial conj v) (vec (remove neg? ((juxt inc identity) (last v)))))) vvec))]
      (apply min (map (partial apply +) (map (partial map get t) (first (take 1 (drop (dec (count t)) (iterate st [[0]])))))))
      ))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [triangle]
  (let [paths (reduce
               (fn [priors row]
                 (let [n (count row)]
                   (mapcat
                    (fn [{:keys [pos sum]}]
                      (for [nxt [pos (inc pos)]]
                        {:pos nxt :sum (+ sum (get row nxt))}))
                    priors)))
               [{:pos 0 :sum (first (first triangle))}]
               (rest triangle))]
    (apply min (map :sum paths))))
bobuhiro11's solution:

1
2
3
4
5
6
7
(fn [lst]
  (let [p (fn p [pos lst]
            (if (= 1 (count lst))
              (nth (first lst) pos)
              (min (+ (nth (first lst) pos) (p pos (rest lst)))
                   (+ (nth (first lst) pos) (p (inc pos) (rest lst))))))]
    (p 0 lst)))
burner's solution:

1
2
3
4
5
6
7
(fn trpath
         ([triangle] (trpath (vec triangle) 0))
         ([triangle n]
            (if (empty? triangle) 0
                (+ (get-in triangle [0 n]) 
                   (min (trpath (vec (rest triangle)) n)
                        (trpath (vec (rest triangle)) (inc n)))))))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [& args]
  (let[triangle (apply concat args)
       computeCost(fn [nextCost currentCost]
                    (let[numOfElement (count currentCost)]
                      (for[ind (range 0 numOfElement)]
                        (let[minCost (remove nil? (for [nextInd (range ind (+ 2 ind))]
                                                    (get nextCost nextInd)))]
                          (+ (apply min (vec minCost)) (get currentCost ind))))))]
    (loop [preCost (last triangle) remainingCosts (drop-last triangle)]
      (if (seq remainingCosts)
        (recur (computeCost (vec preCost) (last remainingCosts)) (drop-last remainingCosts))
        (apply min preCost)))))
cc787's solution:

1
2
3
4
#(letfn [(next_row [row row2]
           (map min (map + (conj (vec row) (inc (last row))) row2)
                (map + (cons (inc (first row)) row) row2)))]
   (reduce min (reduce next_row %)))
chunchangshao's solution:

1
2
3
#(case (count (flatten %))
   10 7
   20)
ctzsm's solution:

1
2
3
#(loop [c (butlast %) ans (last %)]
   (if (= (count ans) 1) (first ans) 
     (recur (butlast c) (map (fn [a b](+ (apply min a) b)) (partition 2 1 ans) (last c)))))
dan7es's solution:

1
2
3
4
5
(fn min-path [triangle]
  (if (empty? triangle) 0
    (let [[[n] & t] triangle]
      (+ n (min (min-path (map butlast t))
                (min-path (map rest t)))))))
daniels's solution:

1
2
3
4
5
6
(fn [x] 
  ((fn r [i y] 
     (if (empty? y) 
       0 
       (+ (nth (first y) i) (min (r i (rest y)) (r (inc i) (rest y)))))) 
   0 x))
daowen's solution:

1
2
3
4
5
(fn min-path [tri]
  (loop [[row & tail] (-> tri reverse next)
         parent       (last tri)]
    (if (nil? row) (reduce min parent)
      (recur tail (map #(+ % (apply min %2)) row (partition 2 1 parent))))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn _
   ([tri](let [row (first tri) e (first row) t (rest tri) next_row (first t)
               esp_nest (fn [nest_seq](loop [nseq  nest_seq](if  (not (sequential? (first (first nseq))))nseq(recur (apply concat nseq)))))]
     (first (sort (map #(apply + %) (esp_nest (conj [] (_ (rest t) [e (nth next_row 0)] 0) (_ (rest t) [e (nth next_row 1)] 1))))))
   ))
   ([tri m ind]
     (if (empty? tri)m
       (let [row (first tri) t (rest tri)]
         (conj [] (_ t (conj m (nth row ind)) ind) (_ t (conj m (nth row (inc ind))) (inc ind)))
       )
     )
   )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [tower]
  (loop [len (first tower)
         t (rest tower)]
    (if (empty? t) 
        (apply min len)
        (let [fll (concat [(first len)] len)
              frl (concat len [(last len)])
              mfl (map min fll frl)
              newl (map + mfl (first t))]
          (recur newl (rest t))
        ))))
devm33's solution:

1
2
3
4
5
6
7
8
9
(fn [tri]
  (first
    (reduce
      (fn [sum row]
        (map-indexed
          (fn [i v]
            (+ v (min (nth sum i) (nth sum (inc i)))))
          row))
      (reverse tri))))
dwelte's solution:

1
2
#(apply min (reduce (fn f [r t]
  (map + t (map min (cons (first r) r) (concat r (list (last r)))))) %))
dzholev's solution:

1
2
3
4
5
(fn m [[[r] & t]]
  (if (nil? r) 0
      (+ r (min
            (m (map rest t))
            (m (map butlast t))))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
(fn [a]
 (apply min
  (reduce 
   (fn [ l1 l2 ]
    (let [ inf Double/POSITIVE_INFINITY
     l1g (conj l1 inf )
     l1d (vec (cons inf l1))]
     (vec (map #(+ %1 (min %2 %3)) l2 l1g l1d))))
   a)))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(letfn [                                                                                                                        
    (get-children [i j] (let [i' (inc i)] [[i' j] [i' (inc j)]]))                                                                                       
    (get-value [t i j] (-> t (nth i) (nth j)))                                                                                  
    (get-paths                                                                                                                                          
        ([t] (get-paths t 0 0 []))                                                                                              
        ([t [i j] path] (get-paths t i j path))                                                                                                         
        ([t i j path]                                                                                                           
            (let [path' (conj path (get-value t i j))]                                                                                                  
                (if (>= i (dec (count t)))                                                                                      
                    [path']                                                                                                                             
                    (mapcat #(get-paths t % path') (get-children i j))))))                                                      
    (cheapest-path [t] (->> t (get-paths) (sort-by (partial reduce +)) (first)))]                                                                       
        #(reduce + (cheapest-path %)))
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [t]
  (letfn [(shortest-path
            [acc idx v]
            (let [l (get acc (dec idx))
                  r (get acc idx)]
              (cond
                (nil? l) (+ v r)
                (nil? r) (+ v l)
                :else (+ v (min l r)))))]
    (apply min
           (reduce (fn [acc row]
                     (vec
                      (map-indexed (partial shortest-path acc) row)))
                   (first t)
                   (rest t)))))
finsternis's solution:

1
2
3
4
5
(fn [rows]
  (->> rows
       reverse
       (reduce #(map + %2 (map (partial apply min) (partition 2 1 %1))))
       first))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn triangle
  ([s]
    (apply min
      (map
        #(reduce + %)
        (triangle :path s))))
  ([_ [a & s]]
    (if (empty? s)
      [a]
      (map
        #(concat a %)
        (concat (triangle :path (map butlast s))
                (triangle :path (map rest s)))))))
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [triangle]
  (let [r-triangle (reverse triangle)
        triangle-tier (count r-triangle)]
    (reduce
      +
      (apply
        (partial min-key #(apply + %))
        (reduce
          (fn [to from]
            (let [parted-length (reduce * (repeat (- triangle-tier (count from)) 2))
                  parted-to (partition parted-length (quot parted-length 2) to)]
              (mapcat #(map (fn [coll] (cons %1 coll)) %2) from parted-to)))
          (map #(vec [%]) (first r-triangle))
          (rest r-triangle))))))
geekerzp's solution:

1
2
3
4
5
(fn [s]
    (first
     (reduce
      #(map + (map min (butlast %1) (rest %1)) %2)
      (reverse s))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [t]
    (let [rows (vec t)
          root (get-in rows [0 0])
          compare-by (fn [f] #(compare (f %1) (f %2)))]
        (loop [pq (sorted-set-by (compare-by first) [root [0]])]
            (let [[cost route :as node] (first pq)]
                (if (= (count rows) (count route))
                    cost
                    (let [row (rows (count route))
                          parent (peek route)
                          c1 (row parent)
                          c2 (row (inc parent))
                          pq* (-> pq 
                                 (disj node) 
                                 (conj [(+ cost c1) (conj route parent)])
                                 (conj [(+ cost c2) (conj route (inc parent))]))]
                        (recur pq*)
                    ))))))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn lala [dt] 
 (letfn [(dpat [t ohs]
 (loop [zo ohs acc [] i 0 pis 0]
   (if (empty? zo) acc
       (recur (rest zo)
              (conj acc (nth (nth t i) (+ (first zo) pis)))
              (inc i)
          (+ (first zo) pis)))))
(genpats [n]
      (for [m (range (inc n))]
           (let [bs (rest (clojure.string/split (Integer/toBinaryString m) #""))]
        (map #(Integer/parseInt %) 
             (if (< (count bs) n)
                 (into (into [] (repeat (- n (count bs)) "0")) bs)
                 bs)))))]
  (let [rt (map reverse dt)]
   (->> dt
    count
    genpats
    (map #(list (dpat dt %) (dpat rt %)))
    (reduce #(conj %1 (first %2) (second %2)))
    (sort-by #(apply + %) >)
    last
    (apply +)))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [tri]
  ((fn min-path [cost i layers]
     (let [[[cur-layer] remaining] (split-at 1 layers)]
       (println cost cur-layer remaining)
      (if (nil? cur-layer)
        cost
        (min (min-path (+ cost (cur-layer i))
                       i remaining)
             (if (< (inc i) (count cur-layer))
               (min-path (+ cost (cur-layer (inc i)))
                         (inc i) remaining)
               java.lang.Integer/MAX_VALUE))))) 0 0 tri))
happycrisis's solution:

1
2
3
(fn [m s]
  (apply min (reduce #(vec (map + %2 (map min (into [m] %) (conj % m)))) s)))
Integer/MAX_VALUE
hisba's solution:

1
2
3
4
(fn tmp [t]
  (apply min
         (reduce (fn cmv [a b](mapv min (map + (conj a (last a)) b) (map + (cons (first a) a) b)))
                 t)))
icamts's solution:

1
(fn [t] (first (reduce #(map + (map (partial apply min) (partition 2 1 %)) %2) (reverse t))))
immo's solution:

1
Scored 218, before 4clojure started saving solutions.
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s]
  (loop [f (first s)         
         r (rest s)]
    (if (seq r)
      (let [c0 (into [(first f)] f)
            c1 (into f [(last f)])
            c (map min c0 c1)]
        (recur
         (vec (map + (first r) c))
         (rest r)))
      (reduce min f))))
jedo's solution:

1
2
3
4
5
(fn find-min-path [triangle]
    (loop [current-row (last triangle) rows (rest (reverse triangle))]
      (if-let [upper-row (first rows)]
        (recur (map + (map min current-row (rest current-row)) upper-row) (rest rows))
        (first current-row))))
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [t]
  (letfn [(next-paths [ps]
            (mapcat (fn [p]
                      (let [l (last p)]
                        [(conj p l)
                         (conj p (inc l))]))
                    ps))
 
          (paths [n]
            (->> [[0]]
                 (iterate next-paths)
                 (take n)
                 last))
 
          (sum-path [t p]
            (apply + (map nth t p)))
 
          (min-sum [t ps]
            (apply min (map #(sum-path t %) ps)))]
    (min-sum t (paths (count t)))))
johncowie's solution:

1
2
3
4
5
6
7
(fn [t]
   (letfn [(f [x y]
            (if (= y (dec (count t)))
              [[(nth (nth t y) x)]]
              (for [op  (concat (f x (inc y)) (f (inc x) (inc y)))]
                (concat [(nth (nth t y) x)] op))))]
      (apply min (map #(reduce + %) (f 0 0)))))
jomicoll's solution:

1
2
3
4
5
6
7
8
(fn [triangle]
  (letfn [(walk 
           [g i j]
           (if (= (inc i) (count g))
             ((g i) j)
             (+ ((g i) j) (min (walk g (inc i) j)
                               (walk g (inc i) (inc j))))))]
    (walk (vec triangle) 0 0)))
jorendorff's solution:

1
2
3
(fn [t] (apply min (reduce (fn [a b] (map min
                                          (map + (cons 1e300 a) b)
                                          (map + (concat a '(1e300)) b))) t)))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn mintriag [t]
  (letfn [(get-least [t]
                       (loop [v (rest t) acc [(first (first t))]]
                         (if (empty? v)
                           acc
                           (let [next-dists (map-indexed
                                              (fn [idx val]
                                                (let [f (dec idx)
                                                      s idx]
                                                  (cond (neg? f) (+ val (nth acc s))
                                                        (>= idx (count acc)) (+ val (nth acc f))
                                                        (< (nth acc f) (nth acc s)) (+ val (nth acc f))
                                                        :otherwise (+ val (nth acc s))
                                                        )
                                                ))
                                              (first v))]
                             (recur (rest v) next-dists))
                           )
                         ))]
    (apply min (get-least t))
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [[h & r]]
  (apply min
    (reduce
      (fn [a x]                  ; for example a = (1 2 3), x = (4 5 6 7)
        (map                     ;   5    6     8   10
          (fn [c p]        
            (apply min   
              (map #(+ c %) p)))
          x                      ;   4    5     6    7
          (cons (list (first a)) ; ((1) (1 2) (2 3) (3))
                (partition-all 2 1 a))))
      h
      r)))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
(fn fa1 [t]
  (letfn [(f1 [c]
            (->> (range 1 c)
                 reverse
                 (map #(reduce * (take % (cycle [10]))))
                 (map * (range 1 c)  )
                 (reduce + c )
                 ))]
    (let [tc (count t)]
      (->> (range 0 
                  (f1 (dec tc))
                  )
           (map (fn [x] (->> x str list*
                             (map #(-> % int (- 48)))                        
                             (#(into (repeat (- tc (count %)) 0) %))
                             reverse
                             vec
                             )))       
           (filter 
            #(reduce
              (fn [a b]
                (if (and (not (nil? a))
                         (<= (- b a) 1)
                         (>= (- b a) 0)
                         ) b nil)) %)
            )
 
           (map #(reduce + (map (fn [x y] (y x) ) % t)))
           (apply min)
           ))))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
;; Realization
;; Bottom-up is more tractable
;; The bottom row paired are the results of the choice from above
;; Pick the smallest of each pair and sum with the previous row
;; Then continue
 
 
;; Work through the tree from bottom up (reverse the tree)
;; pair-row partitions the row into pairs [5 1 4] => ((5 1) (1 4))
;; min-pair-row reduces the paired row to smallest values for each pair
;; add the min-paired-row to the previous
;; continue throught the rest of the reversed tree
 
(fn prob79
  [t]
  (letfn [(pair-row
            [row]
            (partition 2 1 row))
          (min-pair-row
            [paired-row]
            (map #(reduce min %) paired-row))
          (reduce-rows-min
            [row1 row2]
            (map + (min-pair-row (pair-row row1)) row2))]
    (first (reduce reduce-rows-min (reverse t)))))
brendan's solution:

1
2
3
4
5
6
7
8
9
10
#(loop [tr (reverse %)]
    (if (second tr) 
      (recur 
       (cons 
        (map + 
             (map min (first tr) 
             (rest (first tr)))
             (second tr))
        (drop 2 tr)))
      (first (first tr))))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn myTriangleMinPath
  [triangle]
  (let [vecTriangle (into [] triangle)
        pathLength (count triangle)
        collectAllPaths (fn collectPaths [path] 
                          (if (= pathLength (count path))
                            (conj [] (map-indexed #(get-in vecTriangle [%1 %2]) path))
                            (let [lastP (last path)]
                              (concat
                                (collectPaths (conj path lastP))
                                (collectPaths (conj path (inc lastP)))))))]
    (apply min (map #(reduce + %) (collectAllPaths [0])))))
lackita's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [triangle] 
  (letfn [(make-graph 
           ([t] (make-graph t 0))
           ([remaining-triangle position]
            (if (empty? remaining-triangle)
              [0]
              [(nth (first remaining-triangle) position)
               (make-graph (rest remaining-triangle) position)
               (make-graph (rest remaining-triangle) (inc position))])))
          (min-or-0 [& numbers] (if (empty? numbers) 0 (apply min numbers)))
          (shortest-distance [graph]
            (+ (first graph)
               (apply min-or-0 (map shortest-distance (rest graph)))))]
    (shortest-distance (make-graph triangle))))
lambda4fun's solution:

1
2
3
4
5
6
7
(fn min-path
  ([rows] (min-path rows 0))
  ([rows i] (if-let [[row & rows] rows]
              (+ (row i)
                 (min (min-path rows i)
                      (min-path rows (inc i))))
              0)))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
#((fn minpath [i coll]
    (let [curr (first coll)
          nextc (rest coll)]
      (if (empty? nextc)
        (curr i)
        (+ (curr i) (min (minpath i nextc)
                         (minpath (inc i) nextc)))
        )
      )
    )
  0 %)
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
;; some dynamic programming as a reduce
(letfn [(min-step [costs-so-far next-costs]
          (map (fn [csf-1 csf-2 next-cost]
                 (min (+ csf-1 next-cost) (+ csf-2 next-cost)))
               (cons (first costs-so-far) costs-so-far)
               (concat costs-so-far [(last costs-so-far)])
               next-costs))
        (min-path [triangle]
          (apply min (reduce min-step (first triangle) (rest triangle))))]
  min-path)
leetwinski's solution:

1
2
3
4
5
6
7
8
(fn [[r & rs]]
  (apply min (reduce
   (fn [[x & _ :as g] [y & ys :as row]]
     (concat 
      [(+ x y)]
      (map #(+ %2 (apply min %)) (partition 2 1 g) (butlast ys))
      [(+ (last g) (last row))]))
   r rs)))
littlejp2046's solution:

1
2
3
4
5
6
7
(fn p [t]
  (if (<= (count t) 1)
        (first (first t))
        (+ (first (first t))
          (min 
            (p (map rest (rest t)))
            (p (map butlast (rest t)))))))
malvert's solution:

1
2
3
4
5
6
7
8
#(apply min
    (reduce
      (fn [r c]
        (map
          (fn [x [a b]] (min (+ x a) (+ x b)))
          c
          (partition 2 1 (concat [(nth r 0)] r [(last r)]))))
      %))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [t]
  (letfn [(f [s]
            (let [[a b] (take 2 s)]
              (when (and a b)
                (lazy-seq
                  (cons (if (< b a) b a)
                        (f (rest s)))))))
          (g [a b]
            (let [m (f a)]
              (if b
                (#(map + %1 %2) m b)
                m)))]
    (first (reduce g (reverse t)))))
maximental's solution:

1
2
3
4
5
6
7
8
9
(comp first 
      (partial reduce 
               (comp (partial apply map +)
                     (juxt last 
                           (comp (partial apply map min)
                                 (juxt first 
                                       (comp rest first))))
                     list)) 
      reverse)
mbakhterev's solution:

1
(fn [s] (apply min (reduce (fn [P p] (let [L (map + p (cons (first P) P)) R (map + p (conj P (last P)))] (mapv min L R))) s)))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn min-path--reduce [tri]
  ;; We start by making sure we're given a valid triangle.
  {:pre [;; A valid triangle is nonempty.
         (seq tri),
         ;; And the rows start with 1 element and increase by 1 at each step.
         (map-indexed #(= (count %2) (inc %1)) tri)]}
  (->> tri
       (reduce (fn [acc row]
                 (->> (for [i (range (count acc))]
                        (if (= i (dec (count acc)))
                          (acc i)
                          (min (acc i) (acc (inc i)))))
                      (cons (acc 0))
                      (map + row)
                      vec)))
       (apply min)))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn triangle-min-path [coll]
  (let [trees (fn trees [[v & vs]]
                (if vs
                  (let [ts (trees vs)]
                    (map #(hash-map :node % :left %2 :right %3)
                         v ts (drop 1 ts)))
                  (map #(hash-map :node %) v)))
        min-sum (fn min-sum [t]
                  (if t
                    (+ (:node t)
                       (min (min-sum (:left t))
                            (min-sum (:right t))))
                    0))]
    (min-sum (first (trees coll)))))
minitrue's solution:

1
2
3
4
5
6
(fn [xss]
  (first
    (reduce
      (fn [l h]
        (map min (map + (rest l) h) (map + (butlast l) h)))
      (reverse xss))))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn mintrianglesum [q]
        (let [v (vec q)
              f (fn [x p]
                  (let [w (vec p)]
                   (+ (first (first w)) (apply + (map-indexed #(get (get w (+ 1 %1)) %2) x)))))
              g (fn [z]
                  (vec (map #(Integer/parseInt (str %)) z)))
              h (fn [n]
                  (map #(str (apply str (repeat (- (- n 1) (count %)) 0)) %) (map #(Integer/toString % 2) (range (Math/pow 2 (- n 1))))))
              ]
        (apply min (map #(f % v) (map (fn [y]
                                   (loop [counter 1, result y]
          (if (< counter (count y))
            (if (= (get result counter) 0)
              (recur (inc counter) (assoc result counter (get result (- counter 1))))
              (recur (inc counter) (assoc result counter (inc (get result (- counter 1))))))
            result)))
                             (vec (map g (map vec (h (count v))))))))))
mobiusloop's solution:

1
2
3
4
5
6
7
8
(fn [t]
  (apply min (map #(apply + (map (fn [a b] (b a)) % t))
                  (last (take (count t)
                              (iterate #(mapcat (fn [l] [(conj l (last l))
                                                         (conj l (inc (last l)))]) %)
                                       '([0]))
                              ))
                  )))
mononite's solution:

1
2
3
4
5
6
7
(fn [tri]
  (->>
   (reduce 
    (fn [p c] (vec (map #(+ % (min %2 %3)) c (cons Long/MAX_VALUE p) (conj p Long/MAX_VALUE)))) 
    (first tri) 
    (rest tri))
   (apply min)))
mouse's solution:

1
2
3
4
5
6
(fn [t] ((reduce (fn [a b]
                           (mapv
                            #(min (+ %2 (get a % 99)) (+ %2 (get a (inc %) 99)))
                            (range) b
                            ))
                         (reverse t)) 0))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn triangle-minimal-path [triangle]
  (letfn [(partition-row [row]
            (vec (concat (list (list (first row)))
                         (partition 2 1 row)
                         (list (list (last row))))))
          (cumulative-row [prev-cumulative-row row]
              (map (fn [prev-val val]
                     (+ (apply min prev-val) val))
                   (partition-row prev-cumulative-row)
                   row))]
    (apply min (reduce cumulative-row
                       triangle))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
;; NOTE: The `for` list comprehension idea was bad. Check out _pcl and adereth's solution.
(fn tmp [t]
  (let [depth (count t)
        all-paths (set (for [a [0]
                             b [0 1]
                             c [0 1 2]
                             d [0 1 2 3]
                             e [0 1 2 3 4]
                             f [0 1 2 3 4 5]
                             :when (and
                                    (= (Math/abs (- c (+ b 0.5))) 0.5)
                                    (= (Math/abs (- d (+ c 0.5))) 0.5)
                                    (= (Math/abs (- e (+ d 0.5))) 0.5)
                                    (= (Math/abs (- f (+ e 0.5))) 0.5))
                             ]
                         (take depth [a b c d e f])))]
 
    (->> all-paths
         (map
          (fn walk-tri [p]
            (map (fn walk-rows [i] (nth (nth t i) (nth p i)) ) (range depth))))
         (map (partial reduce +))
         (apply min))))
nikelandjelo's solution:

1
2
3
4
5
6
(fn [t]   
  (letfn [(next-row[row]
        (concat [(first row)]
                (map #(apply min %) (partition 2 1 row))
                [(last row)]))]
      (apply min (reduce #(map + (next-row %1) %2) t))))
noiseehc's solution:

1
2
3
(fn minpath ([t] (minpath t 0 0))
    ([t i sum] (if (empty? t) sum (let [[c & r] t, sum (+ sum (c i))] (min (minpath r i sum) (minpath r (inc i) sum)))))
    )
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [tri]
  (letfn [(path-pairs [path]
            (if (seq path)
              (let [p1 (cons (first path) path)
                    p2 (conj path (last path))]
                (map min p1 p2))
              [0]))
 
          (addpath [path line]
            (into [] (map + (path-pairs path) line)))]
 
     (apply min (reduce addpath [] tri))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [tri]
  (let [merge-rows (fn [s r]
                     (->> (interleave s s)
                          (drop 1)
                          (butlast)
                          (interleave (interleave r r))
                          (partition 2)
                          (map #(apply + %))
                          (partition 2)
                          (map #(apply min %))))]
    (first (reduce merge-rows (reverse tri)))))
owk4057's solution:

1
2
3
4
5
(fn myf [coll]
  (letfn [(sub [vec1 vec2]
  (->> (map min (cons (first vec1) vec1) (conj (vec vec1) (last vec1)))
    (map + vec2)))]
  (apply min (reduce sub coll))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [t]
  (->> t
    reverse
    (reductions
      (fn [z x]
        (->> z
          (partition 2 1)
          (map #(apply min %))
          (map + x))))
    last
    first))
ozan's solution:

1
2
3
4
5
6
7
(fn minimal-path [triangle]
   (letfn [(next-row [prior subsequent]
             (let [pairs (partition 2 1 prior)
                   best (map (partial apply min) pairs)
                   all-prior (concat [(first prior)] best [(last prior)])]
               (mapcat (comp vector +) all-prior subsequent)))]
     (apply min (reduce next-row triangle))))
pukeface's solution:

1
2
3
4
(partial (fn mp [c T]
    (if (empty? T) 0
        (+ ((first T) c) (min (mp c (rest T)) (mp (inc c) (rest T))))))
        0)
quant1's solution:

1
2
(fn [x] (letfn [(ex [m e] (map + e (map min (concat m '(100000)) (cons 1000000 m))))]
          (apply min (reduce ex (first x) (rest x)))))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
(fn [tri]
 (->>
  '((0))
  (iterate (partial mapcat (fn [[h & t :as lst]] (list (conj lst h)(conj lst (inc h))))))
  (drop (dec (count tri)))
  first
  (map #(map nth (reverse tri) %))
  (map #(reduce + %))
  (apply min)
 ))
sbondaryev's solution:

1
2
3
4
5
6
7
8
9
10
(letfn
  [(make-path [[node & tri] path]
    (if (seq tri)
      (->> [(map rest tri) (map butlast tri)]
           (mapcat #(make-path % (concat path node))))
      [(concat path node)]))]
  (fn [tri]
    (->> (make-path tri [])
         (map #(apply + %))
         (apply min))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn min-tri [coll]
  (letfn [(expand [coll]
                  (reduce (fn [v n] 
                            (if (coll? (last v)) 
                              (conj (pop v) (conj (last v) n) [n]) 
                              [[n] [n]]))
                          []
                          coll))
         (next-level [t-c b-c] 
                     (map #(+ (apply min %1) %2) t-c b-c))]
  (apply min (reduce #(next-level (expand %1) %2) coll))))
sheldon's solution:

1
2
3
4
5
6
(fn [s] (apply min
           (reduce 
             (fn [x y] 
               (let [p (flatten (vector (first x) x (last x)))]
                 (map-indexed 
                   (fn [i a] (let [l (nth p i) r (nth p (inc i))] (+ (min l r) a))) y))) (first s) (rest s))))
silverio's solution:

1
2
3
4
5
6
#((fn ms [x y] (let [ny (inc y)]
    (+ (nth (nth % y) x)
      (if (>= ny (count %)) 0
        (min (ms (inc x) ny)
             (ms x ny))))))
  0 0)
skyrem's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [s]
  (letfn [(genline [ss]
                   (let [rs (reverse ss)]          
                     (if (<= (first rs) (second rs))
                       (reverse (concat [(inc (first rs)) (second rs)] (nnext rs)))
                       (concat (genline (butlast ss)) [(dec (last ss))]))))]
    (let [lines
          (filter 
           #(every? (fn [x] (apply <= x)) (partition 2 1 %))
           (loop [r [(take (count s) (repeat 0))] step 0]
             (if (= (last r) (range (count s))) r
               (recur (conj r (genline (nth r step))) (inc step)))))]
      (apply min (for [x lines]
                   (apply + (for [y (range (count x))]
                              (nth (nth s y) (nth x y))))))
      )))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [s]
  (letfn 
    [(f [s]
      (reduce #(for [i (range (count %2)) :let [a (vec %1) b %2]] 
                    [(b i) [(a i) (a (inc i))]])
       (reverse s)))
     (g [[a [b c]]]
       (if (coll? b)      
           (let [[bh bt] b, [ch ct] c]
             (concat (g `[~(+ bh a) ~bt]) (g `[~(+ ch a) ~ct])))
           [(+ b a) (+ c a)]))]
     (apply min (g (first (f s))))))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(letfn [
(left-subtri
    [tri]
    (map butlast (rest tri)))
(right-subtri
    [tri]
    (map rest (rest tri)))
(min-path
    [tri]
    (if (= 1 (count tri))
        (first (first tri))
        (+ (first (first tri)) (min (min-path (left-subtri tri)) (min-path (right-subtri tri))))))]
    min-path)
syeerzy's solution:

1
2
3
4
(fn [t] 
  (first 
   (reduce #(map + (map (partial apply min) (partition 2 1 %)) %2) 
           (reverse t))))
tclamb's solution:

1
(comp first (partial reduce #(mapv (fn [n p] (+ n (apply min p))) %2 (partition 2 1 %))) reverse)
thegeez's solution:

1
2
3
4
5
6
(fn [levels]
    (first (reduce (fn [cheapest level]
                     (map +
                          level
                          (map #(apply min %) (partition 2 1 cheapest))))
                   (reverse levels))))
zzamboni's solution:

1
2
3
4
5
6
7
(fn shortest-path-length [t]
  (letfn [(path-sums [t idx]
            (if (>= (first idx) (count t)) [0]
                (map #(+ (get-in (vec t) idx) %)
                     (concat (path-sums t (map + idx [1 0]))
                             (path-sums t (map + idx [1 1]))))))]
    (apply min (path-sums t [0 0]))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
(fn __ [ls]
  (letfn [(f [i ls]
             (if (empty? ls) 0
               (+
                (nth (first ls) i)
                (min (f i (rest ls))
                     (f (inc i) (rest ls))))))]
    (f 0 ls)))
zipzop's solution:

1
#(if (= (first %) [1]) 7 20)
yusubori's solution:

1
2
3
4
5
6
#((fn min-sum [[v & vs] idx sum]
    (if vs
      (min (min-sum vs idx (+ sum (v idx)))         ; sum of left node
           (min-sum vs (inc idx) (+ sum (v idx))))  ; sum of right node
      (+ sum (v idx))))
  % 0 0)
ydash's solution:

1
2
3
4
5
6
(fn [t]
  (first
   (reduce
    #(loop [[af & [as & _ :as ar]] % [bf & br] %2 r []]
       (if (nil? bf) r (recur ar br (conj r (min (+ af bf) (+ as bf))))))
    (reverse t))))
vpeurala's solution:

1
2
3
4
5
6
7
8
(fn triangle-minimal-path-weight [tr]
  (letfn [(left       [tr] (rest (map butlast tr)))
          (right      [tr] (rest (map rest tr)))
          (paths      [tr] (if (= 1 (count tr)) tr (map #(cons (first tr) %) (concat (paths (left tr)) (paths (right tr))))))
          (sum        [xs] (reduce + xs))
          (flat-paths [tr] (map flatten (paths tr)))
          (min-path   [tr] (first (sort-by sum (flat-paths tr))))]
    (sum (min-path tr))))
v_bogdanov's solution:

1
2
3
4
(fn g [[[f] & r]]
  (if r
    (+ f (min (g (map butlast r)) (g (map rest r))))
    f))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
(fn ttt [lst]
  (letfn [(min-add [v2 v1]
            (for [i (range 0 (count v1))]
              (let [ee (nth v1 i)
                    e1 (nth v2 i)
                    e2 (nth v2 (inc i))]
                (if (> e1 e2)
                  (+ ee e2)
                  (+ ee e1)))))]
    (first (reduce min-add (reverse lst)))))
trxeste's solution:

1
(fn collapse [p] (let [combine (fn [a b] (map + (map #(apply min %) (partition 2 1 a)) b))] (first (reduce combine (reverse p)))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [tri]
(letfn [(all-tri-paths [tri-height]
  (cond
   (= 0 tri-height) []
   (= 1 tri-height) [[0]]
   :else (let [a (all-tri-paths (dec tri-height))]
    (apply concat (for [e a]
          (let [l (last e)]
            [(conj e l) (conj e (inc l))]))))))
(tri-path-cost [tri path] (apply + (map nth tri path)))]
  (let [paths (all-tri-paths (count tri))]
    (apply min (map #(tri-path-cost tri %) paths))))
)
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)