;; 69 Merge with a Function [m]

Write a function which takes a function f and a variable number of maps.
Your function should return a map that consists of the rest of the maps conj-ed onto the first. If a key occurs in more than one map, the mapping(s) from the latter (left-to-right) should be combined with the mapping in the result by calling (f val-in-result val-in-latter)

(= (__ * {:a 2, :b 3, :c 4} {:a 2} {:b 2} {:c 5})
   {:a 4, :b 6, :c 20})
(= (__ - {1 10, 2 20} {1 3, 2 10, 3 15})
   {1 7, 2 10, 3 15})
(= (__ concat {:a [3], :b [6]} {:a [4 5], :c [8 9]} {:b [7]})
   {:a [3 4 5], :b [6 7], :c [8 9]})
Special Restrictions: merge-with

(fn [f & args]
  (reduce (fn[map1 map2]
            (reduce (fn [m [k v]]
                      (if-let [vv (m k)]
                        (assoc m k (f vv v))
                        (assoc m k v)))
                    map1 map2))
args))

(fn [op & maps]
  (let [upd-val #(fn [v] (if (nil? v) % (op v %)))
        upd #(update-in %1 [%2] (upd-val %3))
        join #(reduce-kv upd %1 %2)]
    (reduce join {} maps)))

(fn [f & s] (apply hash-map (interleave (keys (apply conj (seq s))) (map #(reduce f %) (map #(filter (comp not nil?) %) (map #(map (fn [m] (get m %)) (seq s)) (keys (apply conj (seq s)))))))))

(fn myMergeWith
  ([f m1 m2]
   (loop[result m1, remaining m2]
     (if-let [[k v] (first remaining)]
       (if (contains? result k)
         (recur (assoc result k (f (result k) v)) (rest remaining))
         (recur (assoc result k v) (rest remaining)))
       result)))
  ([f m1 m2 & ms]
   (apply myMergeWith f (myMergeWith f m1 m2) (seq ms))))

(fn [f x & xs]
  (reduce
    (fn [rm sm]
      (reduce
        (fn [m [k v]]
          (if (contains? m k)
            (assoc m k (f (m k) v))
            (assoc m k v)))
        rm sm))
    x xs))
aceeca1's solution:
1
(fn [f & x] ((comp #(zipmap (keys %) (map (comp (partial reduce f) (partial map last)) (vals %))) (partial group-by first) (partial apply concat)) x))
adereth's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [op & maps]
  (reduce
    (fn [m1 m2]
      (let [keys1 (set (keys m1))
            keys2 (set (keys m2))
            shared (clojure.set/intersection keys1 keys2)
            unchanged-part (conj
              (select-keys m1 keys1)
              (select-keys m2 keys2))
          ]
          (reduce (fn [m k] 
            (assoc m k (op (m1 k) (m2 k))))
            unchanged-part
            shared)))
    maps))
aferrandi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn mergeXB [op & x] 
 
 
    ((fn mergeV [op x]
 
 
 
(if (= 1 (count x)) (first x)
    ((fn [op x y]
 
 
(let [ks (distinct (concat (keys x) (keys y)))]
(apply merge (map (fn [k] (if (and (contains? x k)(contains? y k))
     { k (op (get x k) (get y k) )}
     (if (contains? x k)
        {k (get x k)  }
        {k (get y k)  }
     )
     )
)  ks))
)) op (first x)(mergeV op (rest x)))
)) op x)
 
 
)
aguirre's solution:
1
2
3
4
5
6
7
8
(fn [f & maps]
     (letfn [(mergeWith [m1 m2]
                (let [filterFunction #(contains? m1 (first %))
                      newItems (remove filterFunction m2)
                      toMergedKeys (keys (filter filterFunction m2))
                      mergeItems (into {} (map (fn [x] [x (f (m1 x) (m2 x))]) toMergedKeys))]
                  (into m1 [newItems mergeItems])))]
     (reduce mergeWith maps)))
alanforr's solution:
1
2
3
4
5
6
7
8
(fn [f & ms]
  (letfn [(map-over-map-vals [m f] (zipmap (keys m) (map f (vals m))))
          (maps-with-key [maps k] (filter #(contains? % k) maps))
          (map-vals-for-key [maps k] (vector k (map #(% k) (maps-with-key ms k))))
          (comb [& maps]
            (let [ks (distinct (mapcat keys maps))]
              (into {} (map #(map-vals-for-key maps %) ks))))]
    (map-over-map-vals (apply comb ms) #(reduce f %))))
allenl's solution:
1
2
3
4
5
6
7
8
(fn my-merge-with
  [op a & b]
  (let [kv (mapcat seq b)]
    (reduce (fn [a x]
              (if (contains? a (first x))
                (update-in a [(first x)] op (second x))
                (assoc a (first x) (second x))))
            a kv)))
andthorn's solution:
1
2
3
(fn [f & l]
  (let [g (group-by first (apply concat (map #(apply list %) l)))]
    (zipmap (keys g) (map #(reduce f (map second %)) (vals g)))))
anjensan's solution:
1
2
3
4
5
(fn [f & m]
  (reduce
    (fn [m [k v]] (conj m [k (if (m k) (f (m k) v) v)]))
    {}
    (apply concat (map seq m))))
astangl's solution:
1
2
3
4
5
6
7
8
(fn
  [f & maps]
  (letfn [(step
            [m [k v]] 
            (if (contains? m k)
              (assoc m k (f (get m k) v))
              (assoc m k v)))]
    (reduce #(reduce step %1 %2) maps)))
austintaylor's solution:
1
2
3
4
5
6
(fn [f & args]
  (reduce (fn [out in]
    (reduce (fn [out [k v]]
      (if (contains? out k)
        (assoc out k (f (get out k) v))
        (assoc out k v))) out in)) {} args))
awebb's solution:
1
2
3
(fn mw [f m1 m2 & mr]
  (let [mu (reduce #( if (%1 (key %2)) (update-in %1 [(key %2)] f (val %2)) (conj %1 %2) ) m1 m2)]
    (if mr (recur f mu (first mr) (next mr)) mu)))
bendykst's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn
 [f & maps]
 (into
  {}
  (for 
    [[k vs]
    (reduce
     (fn [m s]
      (reduce
       (fn [ma itm]
        (assoc
         ma
         (first itm)
         (concat (ma (first itm)) [(second itm)])))
       m s))
     {} (map (partial into []) maps))]
   [k (reduce f vs)])))
benhammond's solution:
1
2
3
4
5
6
7
(fn [f m & ms]
  (reduce (fn [mo mi]
            (reduce-kv
              (fn [m k v1]
                (assoc m k (if-let [v0 (get m k)] (f v0 v1) v1)))
              mo mi))
          m ms))
benizi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [f & maps]
  (reduce
   (fn [sofar m]
     (reduce
      (fn [m' [k v]]
        (assoc m' k
          (if (contains? m' k)
            (f (m' k) v)
            v)))
      sofar
      m))
   {}
   maps))
bobuhiro11's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn mymerge
  ([f col1 col2]
  (reduce (fn [col ele]
            (let [k (first ele)
                  v (second ele)]
              (if (get col k)
                (assoc-in col [k] (f (get col k) v))
                (assoc-in col [k] v))
              )
            ) col1 col2))
  ([f col1 col2 & more]
   (apply mymerge f (mymerge f col1 col2) more)))
burner's solution:
1
2
3
4
5
6
7
8
9
(fn [f & seqs]
        (reduce (fn [s1 s2]
                  (merge s2 (apply hash-map 
                                   (mapcat (fn [[key value]] 
                                             (if (contains? s2 key) 
                                               [key (f value (s2 key))] 
                                               [key value]))
                                           s1))))
                seqs))
caterpillar's solution:
1
2
3
4
5
6
(fn my-merge-with [f m & ms]
  (reduce (fn [m1 m2]
            (reduce (fn [cm [k v]]
                      (if (cm k) (assoc cm k (f (cm k) v))
                        (assoc cm k v))) m1 m2))
            m ms))
cc787's solution:
1
2
3
4
5
6
7
8
9
10
11
12
#(loop [result %2
        xs %&]
   (print xs result)
   (if (empty? xs)
     result
     (recur (reduce-kv (fn [acc k v] (assoc acc k (if (acc k) (%1 (acc k) v) v))) result (first xs)) (rest xs))))
;for clojure version of 1.7
;#(loop [result %2
;        xs %&]
;   (if (empty? xs)
;     result
;     (recur (reduce-kv (fn [acc k v] (update acc k %1 v)) result (first xs)) (rest xs))))
chunchangshao's solution:
1
2
3
#(->> (group-by first (apply concat [] %&))
      (map (fn [[k v]] [k (reduce % (map second v))]))
      (into {}))
ctzsm's solution:
1
2
3
4
(fn [f & coll]
   (apply merge 
          (for [x (group-by #(first %) (reduce into [] coll))]
            {(first x) (let [[c & ls] (map second (second x))] (if (> (count ls) 0) (apply f c ls) c))})))
dan7es's solution:
1
2
3
4
5
6
7
8
9
10
(fn merge-by [f & maps]
  (reduce
   (fn [acc maps]
     (reduce-kv
      (fn [m k v]
        (assoc m k
          (if (contains? m k)
            (f (m k) v) v)))
      acc maps))
   {} maps))
daniels's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [o r & m] 
  (reduce #(let [a (first %2) b (last %2) c assoc]
            (if 
             (nil? (% a)) 
             (c % a b) 
             (c % a (o (% a) b))))
          r
          (reduce concat (map (partial into []) m)) 
  )
)
 
;(fn [op result & maps] 
;  (reduce #(if 
;             (nil? (% (first %2))) 
;             (assoc % (first %2) (last %2)) 
;             (assoc % (first %2) (op (% (first %2)) (last %2)))) 
;          result
;          (reduce concat (map (partial into []) maps)) 
;  )
;)
daowen's solution:
1
2
3
4
(fn [f & ms]
  (->> ms (apply concat) (group-by key)
       (map (fn [[k vs]] [k (reduce f (map val vs))]))
       (into {})))
del680202's solution:
1
2
3
4
5
6
7
8
(fn [f mr & ms]
  (let [_merge (fn _merge [f r m](loop [r r ks (keys m)](let [k (first ks)] (if (empty? ks) r(recur (merge r {k (if (contains? r k)(f (r k) (m k)) (m k))}) (rest ks))))))] 
  (loop [r mr ms ms]
     (if (empty? ms) r
       (recur (_merge f r (first ms)) (rest ms))
     )
  ))
)
deping's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn ! [op & ss]
  (do (println op)
      (println ss)
  (if (= 1 (count ss)) (first ss) 
    (let [fs (first ss)
          s2 (do (println fs (second ss)) (second ss))
          r (into {}
              (map 
               #(if (contains? fs %) 
                  (if (contains? s2 %) [% (op (fs %) (s2 %))] 
                                       [% (fs %)])
                  [% (s2 %)])
             (clojure.set/union (set (keys fs)) (set (keys s2)))
             ))
          ]
      (apply ! (concat [op] [r] (drop 2 ss))))))
)
devm33's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [f m0 & maps]
  (reduce
    (fn [m1 m2]
      (reduce
        (fn [m [k v]]
          (if (contains? m k)
            (assoc m k (f (get m k) v))
            (assoc m k v)))
        m1
        m2))
    m0
    maps
    ))
dwelte's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn f [combiner initial & others]
  (if (empty? others)
    initial
    (let [[addee & remainder] others
          keys-in-both (filter #(contains? addee %) (keys initial))]
      (recur
        combiner
        (merge
          (apply dissoc initial (keys addee))
          (apply dissoc addee (keys initial))
          (apply hash-map (mapcat #(list % (combiner (initial %) (addee %))) keys-in-both)))
        remainder))))
dzholev's solution:
1
2
3
(fn [f & s]
  (into {} (for [[k v] (group-by first (apply concat (map vec s)))]
              [k (reduce f (map second v))])))
echevarria's solution:
1
2
3
4
5
6
7
8
9
(fn my-merge-with [ f m & ee ]
 (if (empty? ee)
  m
  (recur f 
   (reduce 
    (fn[m [k kv]] 
     (assoc m k (if (m k) (f (m k) kv) kv)))
    m (first ee))
   (rest ee))))
ericw's solution:
1
2
3
4
5
6
7
(fn [f & ms]                                                                                                                    
    (reduce                                                                                                                                             
        #(into                                                                                                                  
            %1                                                                                                                                          
            (map (fn [[k v]] (if (contains? %1 k) {k (f (%1 k) v)} {k v})) (seq %2)))                                                                   
        {}                                                                                                                                              
        ms))
featalion's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [f m & ms]
  (reduce (fn [res m-n]
            (reduce (fn [r_ m-e]
                      (let [mk (key m-e)
                            mv (val m-e)]
                        (if (contains? r_ mk)
                          (assoc r_ mk (f (get r_ mk) mv))
                          (assoc r_ mk mv))))
                    res
                    (seq m-n)))
          m
          ms))
finsternis's solution:
1
2
3
4
(fn [f & [m & ms]]
  (letfn [(mf [f m1 m2] 
              (into m1 (for [[k v] m2] [k (if (contains? m1 k) (f (m1 k) v) v)])))]
    (reduce #(mf f %1 %2) m ms)))
flububb's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn
  [f & m]
  (into {}
    (map
      (fn [[k v]] 
        (vector k (reduce f (map last v)))) 
      (group-by first
        (reduce
          #(concat %1 (map identity %2))
          []
          m)))))
garyxia's solution:
1
2
3
4
5
6
7
8
(fn [f & args]
  (reduce (fn[map1 map2]
            (reduce (fn [m [k v]]
                      (if-let [vv (m k)]
                        (assoc m k (f vv v))
                        (assoc m k v)))
                    map1 map2))
          args))
geekerzp's solution:
1
2
3
4
5
6
7
8
(fn [f & maps]
    (reduce
     (fn [m1 m2]
       (reduce
        (fn [m [k v]]
          (assoc m k (if (m1 k) (f (m1 k) v) v)))
        m1 m2))
     (first maps) (rest maps)))
glchapman's solution:
1
2
3
4
5
6
7
8
(letfn [(mymerge-with
    ([f m1 m2]
        (reduce (fn [res [k v]] (if-let [rv (res k)] (assoc res k (f rv v)) (assoc res k v)))
                m1 m2))
    ([f m1 m2 & maps]
        (reduce #(mymerge-with f %1 %2) m1 (cons m2 maps)))
  )]
 mymerge-with)
goaranger's solution:
1
2
3
4
5
6
7
8
(fn necro [f l & ol]
  (let [result 
   (for [a ol]
    (for [b a]
      (if (contains? l (key b))
        (hash-map (key b) (f (get l (key b)) (val b)))
        (hash-map (key b) (val b)))))]
    (apply conj (flatten result))))
gpittarelli's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn merge-with' [op & maps]
  (reduce 
    (fn [acc m]
      (apply assoc acc
             (mapcat (fn [k]
                    (list k 
                          (if (acc k)
                            (op (acc k) (m k))
                            (m k))))
                  (keys m))))
    maps))
happycrisis's solution:
1
2
3
4
(fn [f & s] 
  (reduce (fn [m [k v]] 
            (assoc m k (if (m k) (f (m k) v) v))) 
          {} (mapcat seq s)))
hisba's solution:
1
2
3
4
5
6
7
8
9
(fn [f & maps]
(let [mm2
  (fn [a b]
    (let [bm (merge a b)
          ak (set (keys bm))
          ck (set (keys (select-keys a (keys b))))
          uk (clojure.set/difference ak ck)]
      (merge (select-keys bm uk) (zipmap ck (map #(f (a %) (b %)) ck)))))]
  (reduce mm2 maps)))
icamts's solution:
1
2
3
4
5
6
7
8
9
(fn [f & args] (->> 
                args 
                (apply concat) 
                (group-by key) 
                (map (fn [e] 
                       (vector (key e) 
                               (->> e val (map second) 
                                    (#(reduce f (first %) (rest %))))))) 
                (into {})))
immo's solution:
1
Scored 102, before 4clojure started saving solutions.
jarlax's solution:
1
2
3
4
5
6
7
8
9
(fn [f m & maps]
  (->
    (fn [m1 m2]
      (-> (fn [m k]
            (assoc m k (if (m k)
                         (f (m k) (m2 k))
                         (m2 k))))
          (reduce m1 (keys m2))))
   (reduce m maps)))
jedo's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn mwith [f o & m]
  (loop [origin o more m]
          (cond (empty? more) 
                origin
                :else (recur (merge (first more) (zipmap (keys origin) 
                                     (for [k (keys origin)] 
                                          (cond (contains? (first more) k) 
                                          (f (get origin k) (get (first more) k))
                                          :else 
                                          (get origin k))
                                      )
                              )) 
                              (rest more)
                      )
          )
    )
)
jeff_terrell's solution:
1
2
3
4
5
6
7
8
9
(fn [f & ms]
  (reduce
    (fn [m [k v]]
      (assoc m k
             (if (contains? m k)
               (f (get m k) v)
               v)))
    {}
    (mapcat seq ms)))
johncowie's solution:
1
2
3
4
5
6
7
8
(fn [f & args]
   (into {}
      (map (fn [e] [(e 0)
         (let [s (map (fn [v] (v 1)) (e 1))]
             (if (<= (count s) 1)
                 (first s)
                 (apply f s)))])
             (group-by key (apply concat (map (fn [m] (into [] m)) args))))))
jomicoll's solution:
1
2
3
4
5
6
7
8
9
10
(fn [f & ms]
  (reduce
   (fn walk [res [[k v] & xs]]
     (if k
      (if (res k)
        (recur (assoc res k (f (res k) v)) xs)
        (recur (assoc res k v) xs))
       res))
   (first ms)
   (map vec (rest ms))))
jorendorff's solution:
1
(fn [f & m] (into {} (for [[k e] (group-by key (apply concat m))] [k (reduce f (map val e))])))
jslavin's solution:
1
2
3
4
5
6
7
8
9
(fn mymerge [f m & args]
  (merge m (into {}
                 (for [x args]
                   (into {} (map #(let [k (first %)
                               v (second %)]
                          (vector k (if (contains? m k) (f (get m k) v) v)))
                        x)))
         )
  ))
kohyama's solution:
1
2
3
4
5
6
(fn mw [f m & [h & r]]
  (if h
    (apply mw f
      (reduce (fn [a [k v]] (assoc a k (if-let [av (a k)] (f av v) v))) m h)
      r)
    m))
kopychenko's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn merge-with-a-function [f & sqs]
  (reduce 
 
   (fn [a x]
     (reduce
     
      (fn [a k] 
        (let [v (a k)]
          (if (nil? v)
            (assoc a k (x k))
            (assoc a k (f v (x k))))))
     
      a                   
      (keys x)))
   
   {}
   sqs))
blucas's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn prob69 [f & maps]
  (reduce
   (fn [m1 maps]
     (reduce
      (fn [map [key val]]
        (println map key val)
        (assoc map key (if (maps key) (f val (maps key)) val))
        )
      maps m1
      ))
   (first maps) (rest maps)))
brendan's solution:
1
2
3
4
5
6
(fn [f & cs]
  (reduce 
   #(reduce 
     (fn [c [k v]] (assoc c k (if-let [v2 (c k)] (f v2 v) v)))  
     % %2)
   cs))
kuze's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn myMergeWith
  [fun & colls]
  (let [result (first colls) toProcess (rest colls)]
    (reduce 
      (fn [result other]
        (reduce 
          #(let [element (get %1 (first %2))]
             (if (nil? element)
               (assoc %1 (first %2) (second %2))
               (assoc %1 (first %2) (fun element (second %2))))) 
          result other)) 
      result toProcess)))
lackita's solution:
1
2
3
4
5
6
7
8
9
(fn [fun & sets] 
  (reduce (fn [acc c]
           (apply conj (cons acc 
                             (map (fn [[k v]]
                                    (if (contains? acc k)
                                      [k (fun (acc k) v)]
                                      [k v]))
                                  c))))
          sets))
lambda4fun's solution:
1
2
3
4
5
6
7
8
9
10
(fn [f & ms]
  (let [ks (distinct (mapcat keys ms))]
    (into {} (map
              (fn [k]
                (->> ms
                     (map #(% k))
                     (remove nil?)
                     (#(if (> (count %) 1) (apply f %) (first %)))
                     (vector k)))
              ks))))
lasthemy's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [f & maps]
  (reduce #(reduce
            (fn [out [k v]]
              (if (contains? out k)
                (assoc out k (f (out k) v))
                (assoc out k v)
                )
              ) %1 %2
            ) {} maps
          )
  )
lbarrett's solution:
1
2
3
4
5
6
7
8
9
10
(fn [f & ms]
  (reduce
    (fn [m1 m2]
      (into {} (for [k (set (mapcat keys [m1 m2]))]
                 [k
                  (cond
                    (not (contains? m2 k)) (m1 k)
                    (not (contains? m1 k)) (m2 k)
                    :else (f (m1 k) (m2 k)))])))
    ms))
leetwinski's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [f & ls]
  (letfn [(rdc [b r]
            (if (empty? r) b
              (recur
                (reduce 
                  #(let [[k v] %2]
                    (assoc 
                      %1
                      k
                      (if (contains? %1 k)
                        (f (%1 k) v)
                        v))) 
                  b 
                  (first r))
                (rest r))))]
    (rdc (first ls) (rest ls))))
littlejp2046's solution:
1
2
3
4
5
6
7
8
9
(fn [f & m] 
  (reduce
    (partial reduce 
        #(conj %1
          (let [k (first %2)]
          (if (contains? %1 k)
              [k (f (get %1 k) (last %2))]
              %2))))
    m))
malvert's solution:
1
2
3
4
5
(fn [f & a]
  (into {}
    (map 
      (fn [k] [k (reduce f (keep #(% k) a))])
      (keys (apply merge a)))))
matiasl's solution:
1
2
3
4
5
6
7
8
9
(fn [f m & maps] 
  (into 
   {} 
   (for [mp maps 
         [k v] mp 
         :let [nv (if (contains? m k) 
                    (f (get m k) v) 
                    v)]] 
     [k nv])))
maximental's solution:
1
2
3
4
5
6
7
8
(fn [f & s]
  (reduce 
    #(reduce 
      (fn [a [k v]]
        (assoc a k (if (a k) (f (a k) v) v)))        
      %
      %2)
    s))
mbakhterev's solution:
1
(fn [f & M] (reduce (fn [R m] (reduce-kv (fn [r k v] (assoc r k (if-let [u (r k)] (f u v) v))) R m)) {} M))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn merge--listcomp
  [f & maps] {:pre [(ifn? f), (every? map? maps)]}
  (let [;; This is the set of keys that appear in any of the maps.
        keyset (set (mapcat keys maps)),
 
        ;; This is a function wrapping f so that we don't have to separately
        ;; handle the case where a key only appears in one map.
        smoosh (fn [x & etc] (if (seq etc) (apply f (cons x etc)) x)),
 
        ;; This function takes in a key k and provides the value it should have
        ;; in the output map.
        update-key (fn [k]
                     (->> maps
                          (filter #(contains? % k))
                          (map #(% k))
                          (apply smoosh)))]
 
    ;; To get the output map, we just apply update-key to each key in the key
    ;; set, and stick all of the resulting pairs in a map.
    (into {} (for [k keyset] [k (update-key k)]))))
mfikes's solution:
1
2
3
4
5
6
7
(fn [f & ms]
  (reduce (fn [am m]
            (into am (for [[k v] m]
                       (if (contains? am k)
                         [k (f (am k) v)]
                         [k v]))))
          ms))
minitrue's solution:
1
2
3
4
5
6
7
8
9
(fn [f v0 & vs]
  (reduce
    (fn [so-far m]
      (reduce
        (fn [now [k v]]
          (assoc now k (if (now k) (f (now k) v) v)))
        so-far m))
    v0
    vs))
mkahn's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn newmergewith [f & x]
  (let [fchecker (fn [dict entry]
                   (if (contains? dict (first entry))
                     (assoc dict (first entry) (f (get dict (first entry)) (peek entry)))
                     (assoc dict (first entry) (peek entry))))
        combine (fn [dict otherdict]
                  (reduce fchecker dict otherdict))]
    (if (seq x)
      (if (seq (rest x))
        (reduce combine (first x) (rest x))
        (first x))
      '())))
mobiusloop's solution:
1
2
3
4
5
(fn [f & ms]
   (reduce (fn [a m] (reduce
                     #(let [[k v] %2 x (%1 k)] (if (nil? x) (assoc %1 k v) (assoc %1 k (f x v))))
                     a m)) {}  ms)
  )
mononite's solution:
1
2
3
4
5
6
7
8
9
10
(fn [f & ms]
  (reduce 
   (fn [acc m] 
     (reduce 
      #(let [k (key %2) v (val %2)]
          (if (contains? % k) 
            (update-in % [k] f v) 
            (assoc-in % [k] v)))
      acc m))
   ms))
mouse's solution:
1
2
3
#(into {}
        (map (fn [[k a]] [k (reduce % (map second a))])
             (group-by first (mapcat seq %&))))
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [f & maps]
  (letfn [(merge-maps [m1 m2]
            (loop [dest m1 r m2]
              (if-let [[k v] (first r)]
                (if-let [dv (get dest k)]
                  (recur (assoc dest k (f dv v)) (next r))
                  (recur (assoc dest k v) (next r)))
                dest)))]
    (reduce merge-maps
            (first maps)
            (rest maps))))
nagi's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn mf [f & maps]
  (let [ks (distinct (flatten (map keys maps)))]
    (reduce (fn [memo key]
              (let [args (filterv identity (map #(% key) maps))]
                (if (= 1 (count args))
                  (assoc memo key (first args))
                  (assoc memo key (apply f args)))
                )
              )
            {}
            ks)))
nikelandjelo's solution:
1
2
3
4
5
6
(fn my-merge-with [f & a]
  (letfn [(b [d [e v]]
               (update-in d [e] #(if (nil? %) v (f % v))))
        (c [d e]
        (reduce #(b %1 %2) d e))]
  (reduce c {} a)))
noiseehc's solution:
1
2
3
4
5
6
7
(fn [f & args] 
  (reduce 
    (fn [r, a] 
      (reduce 
        #(let [[k v] %2] (if (contains? r k) (conj %1 [k (f (r k) v)]) (conj %1 %2)))
        r a)) 
    {} args))
norman's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn mw [merge-function & maps]
  (let [ymerge (fn [f m1 m2]
                 (into m1
           (loop [ks (keys m2) acc {}]
                         (if (seq ks)
                           (let [fk (first ks)
                                 rk (rest ks)]
                             (if (m1 fk)
                               (recur rk (into acc {fk (f (m1 fk) (m2 fk))}))
                               (recur rk (into acc {fk (m2 fk)}))))
                           acc))))]
    (reduce #(ymerge merge-function %1 %2) {} maps)))
nothsaevets's solution:
1
2
3
4
5
6
7
8
(fn [f & maps]
           (reduce (fn [acc curr]
                     (let [base (conj acc curr)
                           conflicts (into {} (for [[k v] curr]
                                                (when-let [acc-v (get acc k)]
                                                  [k (f acc-v v)])))]
                       (conj base conflicts))) 
                   {} maps))
owk4057's solution:
1
2
3
4
5
6
7
8
9
(fn [f m & ms]
  (let [mymerge
        (fn [m1 m2]
          (reduce #(if (contains? %1 (key %2))
                     (->> (f (%1 (key %2)) (val %2))
                          (hash-map (key %2))
                          (merge %1))
                     (merge %1 %2)) m1 m2))]
    (reduce mymerge m ms)))
ownwaterloo's solution:
1
2
3
4
5
6
7
(fn [f & xs]
  (->> xs
       (apply concat)
       (group-by first)
       (reduce-kv
        (fn [acc k v] (assoc acc k (reduce f (map second v))))
        {})))
ozan's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn merg-with [f m & maps]
  (if (empty? maps)
    m
    (let [n (first maps)]
      (apply merg-with
             (concat [f
                      (into {}
                            (for [k (concat (keys m) (keys n))]
                              (let [vm (get m k)
                                    vn (get n k)]
                                (if (nil? vm) [k vn]
                                    (if (nil? vn) [k vm]
                                        [k (f vm vn)])))))]
                     (rest maps))))))
pukeface's solution:
1
2
3
4
5
6
(fn [f & m]
    (into {}
    (for [[k v]
           (group-by key (apply concat m))
          ] 
      [k (reduce f (map val v))])))
quant1's solution:
1
2
3
4
5
6
(fn [f m & es] 
  (reduce 
   (fn m1 [c e] 
     (reduce #(let [[k v] %2 o (%1 k)] (assoc %1 k (if o (f o v) v)))
             c e))
    m es))
rodmax's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [fcn x & xs ]
  (reduce 
   (fn [result [k v]]
     (assoc result k
       (if-let 
           [v1 (result k)]
         (fcn v1 v)
         v
         )))
   x
   (apply concat xs)
   )
)
sbondaryev's solution:
1
2
3
4
5
(fn g [f & xs]
    (->> (apply concat xs)
         (group-by first)
         (map (fn [[k v]] [k (reduce f (map second v))]))
         (into {})))
shiro's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn cust-merge-with [f m & args]
  (reduce
    (fn merge-map [m t]
      (let [pairs (seq t)]
        (reduce
          (fn m-single [m t]
            (let [v-in-m (get m (first t))]
              (if (= nil v-in-m)
                (conj m t)
              (conj m {(first t) (f v-in-m (second t))}))))
          m
          t)))
    m
    args))
sheldon's solution:
1
(fn g [f r & m] (if (empty? m) r (apply g f (reduce #(let [[k v] %2] (conj %1 (if (%1 k) {k (f (%1 k) v)} %2))) r (first m)) (rest m))))
silverio's solution:
1
2
3
(fn [op & s] (reduce
   #(into (conj % %2) (for [[k1 v1] % [k2 v2] %2]
          (if (= k1 k2) [k1 (op v1 v2)]))) s))
skyrem's solution:
1
2
3
4
5
6
7
(fn [f p & args]
  (apply merge 
         (flatten 
          (for [a args]
            (for [k (keys a)]
              (if (nil? (find p k)) (assoc {} k (get a k))
                (assoc {} k (f (get p k) (get a k)))))))))
soul_awaker's solution:
1
2
3
4
5
6
(fn g [f i h & t]
  (let [[k & v] (vec h)]
    (if (coll? k)
        (g f (g f i k) (if v `[~@v ~@t] t))
        (let [y #(apply identity %)]
          (if k (assoc i k (if (i k) (f (i k) (y v)) (y v))) i)))))
staafl2's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [f & ms]
  (let [all-keys         (keys (apply merge ms))
        count-containing (fn [k] (count (filter #(contains? % k) ms)))
        count-per-key    (into {} (map (fn [k] [k (count-containing k)]) all-keys))]
    (into {} 
        (map
            (fn [k]
                (if (= 1 (count-per-key k))
                    [k (some #(get % k) ms)]
                    [k (reduce f (filter #(not (nil? %)) (map #(get % k) ms)))]))
            all-keys))
  ))
syeerzy's solution:
1
2
3
4
5
6
7
(fn [func & maps]
  (->> maps 
       (apply concat) 
       (group-by key)
       (map (fn [[k vs]] 
              [k (reduce func (map val vs))]))
       (into {})))
tclamb's solution:
1
2
3
4
5
6
7
8
(fn [f & ms]
  (letfn[(m [acc m]
           (let [to-merge (select-keys m (keys acc))
                 to-assoc (apply disj (set (keys m)) to-merge)
                 merged   (map (fn [[k v]] [k (f (get acc k) v)]) to-merge)
                 assoced  (reduce #(assoc %1 %2 (get m %2)) acc to-assoc)]
             (into assoced merged)))]
    (reduce m ms)))
thegeez's solution:
1
2
3
4
5
6
7
(fn [f & ms]
    (reduce (fn [acc m]
              (reduce (fn [acc [k v]]
                        (assoc acc k (if-let [e (acc k)]
                                       (f e v)
                                       v))) acc m))
            ms))
zzamboni's solution:
1
2
3
4
5
6
7
8
(fn my-merge-with [fun & maps]
  (reduce (fn [m1 m2]
            (reduce (fn [m1 [k v]]
                      (if (contains? m1 k)
                        (assoc m1 k (fun (m1 k) v))
                        (assoc m1 k v)))
                    m1 m2))
          maps))
zoltanjarai's solution:
1
2
3
4
5
6
7
8
9
10
(fn __ [f & ms]
  (->> (for [m ms
             k (keys m)]
         [k (get m k)])
       (group-by first)
       (map (fn [entry]
              [(first entry)
               (reduce f
                       (map second (second entry)))]))
       (into {})))
zipzop's solution:
1
2
3
4
5
6
7
8
(fn [f & ms]
  (reduce (fn [m1 m2]
            (reduce (fn [m [k v]]
                      (if (contains? m k)
                        (update-in m [k] f v)
                        (assoc m k v)))
                    m1 m2))
          ms))
yusubori's solution:
1
2
3
4
(fn [f m & ms]
  (into {} 
        (for [e ms [k v] e]
          (if (contains? m k) [k (f (m k) v)] [k v]))))
ydash's solution:
1

(fn [f & args]
  (loop [l (rest args), acc (first args)]
    (if-let [h (first l)]
      (recur (rest l) (reduce
                       #(let [[k v] %2]
                          (conj % [k (if-let [x (% k)] (f x v) v)]))
                       acc
                       h))
      acc)))
vpeurala's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [f & ms] (letfn [
(common-keys [m1 m2] (clojure.set/intersection (set (keys m1)) (set (keys m2))))
(unique-keys [m1 m2] (clojure.set/difference (clojure.set/union (set (keys m1)) (set (keys m2))) (clojure.set/intersection (set (keys m1)) (set (keys m2)))))
(merge-2-with-a-function [f m1 m2]
    (reduce #(assoc %1 %2 (f (get m1 %2) (get m2 %2))) (merge m1 m2) (common-keys m1 m2))
)
(merge-with-a-function [f & ms]
    (cond
        (empty? ms)
        {}
        :else
        (merge-2-with-a-function
            f
            (first ms)
            (apply merge-with-a-function f (rest ms))
        )
    )
)
] (apply merge-with-a-function f ms)))
v_bogdanov's solution:
1
2
3
4
5
(fn f1 [f m1 & maps]
  (let [m2 (reduce into {} maps)]
    (reduce #(if (not (nil? (get % (key %2)))) 
               (assoc % (key %2) (f (get % (key %2)) (val %2)))
               (conj % %2)) m1 m2)))
unionx's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn umerge [f & args]
  (let [arg1 (first args)
        arg2 (second args)
        rst (drop 2 args)
        mrg (loop [ret arg1 x arg2]
              (if (empty? x)
                ret
                (let [elt (first x)
                      m-v (ret (key elt) nil)]
                  (recur (assoc ret (key elt) (if (nil? m-v)
                                                (val elt)
                                                (f m-v (val elt))))
                         (rest x)))))]                  
    (if (= 2 (count args))
      mrg
      (apply umerge f mrg rst))))
trxeste's solution:
1
2
3
4
5
6
7
8
(fn [f & ms]
  (reduce (fn [m1 m2]
            (reduce (fn [m [k v]]
                      (if (contains? m k)
                        (update-in m [k] f v)
                        (assoc m k v)))
                    m1 m2))
          ms))
transfinite's solution:
1
2
3
4
5
6
7
8
9
10
(fn [f & ms]
  (loop [ks (seq (set (apply concat (map keys ms))))
         ms ms
         vs (for [k ks] (remove nil? (for [m ms] (m k))))
         m {}]
    (if (empty? ks) m
        (let [k (first ks)
              v (first vs)
              v (if (= 1 (count v)) (first v) (apply f v))]
          (recur (rest ks) ms (rest vs) (assoc m k v))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)