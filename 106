;; 106 Number Maze [h]

Finds length of shortest path between 2 points
using only 3 operations: add 2, double, halve
odd numbers cannot be halved

(= 1 (__ 1 1))  ; 1
(= 3 (__ 3 12)) ; 3 6 12
(= 3 (__ 12 3)) ; 12 6 3
(= 3 (__ 5 9))  ; 5 7 9
(= 9 (__ 9 2))  ; 9 18 20 10 12 6 8 4 2
(= 5 (__ 9 12)) ; 9 11 22 24 12

(defn find-path [s e]
  (loop [opts [s] depth 1]
    (if (some #{e} opts)
      depth
      (letfn [(solutions [n]
                (concat 
                  [(* n 2) (+ n 2)]
                  (if (even? n) [(/ n 2)] [])))]
        (recur (mapcat solutions opts) (inc depth))))))
#'user/find-path
user> (find-path 1 1)
1
user> (find-path 3 12)
3
user> (find-path 12 3)
3
user> (find-path 5 9)
3
user> (find-path 9 2)
9
user> (find-path 9 12)
5

(fn [x-i y]
  (letfn [(spread [x]
            (concat (if (even? x) [(/ x 2)]) [(* 2 x) (+ 2 x)]))]
    (loop [i 1 xs [x-i]]
      (if (some (partial = y) xs)
        i
        (recur (inc i) (mapcat spread xs))))))

(fn f
  ([n1 n2]
   (if (= n1 n2)
     1
     (f [n1]
       n2 (fn [x] (* x 2)) (fn [x] (+ x 2)) (fn [x] (/ x 2)) 1)
     ))
  ([n1 n2 d-n a-2 h-n steps]
   (if (some #(= % n2) n1)
     steps
   (recur (mapcat #(vector (d-n %) (a-2 %) (h-n %)) n1) n2 d-n a-2 h-n (inc steps)))))

(fn [num1 num2]
  (loop[distance 1 found #{num1}]
   (if (contains? found num2) distance ;found
     (recur (inc distance)
            (set
             (for [item found extended (map #(% item 2) [/ * +])
               ;map a function template to a set of operators
               :when (and (integer? extended) (not (contains? found extended)))]
               extended))))))

(fn [s e]
  (letfn [(step [xs] (set (mapcat
    #(list (* 2 %) (+ 2 %)
      (if (even? %)
          (/ % 2)
           %))
    xs)))]
    (if (= s e)
         1
        (inc (count (take-while
         #(not (some #{e} %))
        (iterate step #{s})))))))

aceeca1's solution:

1
2
3
4
5
6
7
8
9
(letfn [
    (op [s] (for [
        si s x [
            (+ si si)
            (when (zero? (mod si 2)) (/ si 2))
            (+ si 2)] 
        :when x] x))
    (maze [x1 x2] (inc (count (take-while (partial not-any? #{x2}) (iterate op [x1])))))]
    maze)
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s e]
  (loop [c 1
         n #{s}]
    (if (n e) c
        (recur (inc c)
               (reduce clojure.set/union #{}
                       (map (fn [x]
                              (clojure.set/union
                               #{(* 2 x) (+ 2 x)}
                               (if (even? x) #{(/ x 2)} #{})))
                            n))))))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
(fn numberMazeX[a b]
    (letfn[
        (mazeDouble[a]
            (+ a a)
        )
 
        (mazeAdd2[a]
            (+ a 2)
        )
        (mazeHalf[a]
            (quot a 2)
        )
 
        (mazeHalfable[a]
            (even? a)
        )
 
        (distance[a b]
            (Math/abs (- a b))
        )
 
        (mazePath[a b sum maxSum maxDist]
            (if (= a b)
                sum
                (if (or (> sum maxSum) (> (distance a b) maxDist))
                    maxSum
                    (let [
                        sumDouble (mazePath (mazeDouble a) b (inc sum) maxSum maxDist)
                        sumAdd2 (mazePath (mazeAdd2 a) b (inc sum)  (min maxSum sumDouble) maxDist)
                        sumHalf (if (mazeHalfable a) 
                             (mazePath (mazeHalf a) b (inc sum)  (min maxSum sumAdd2) maxDist)
                             maxSum
                            )
                        ]
                        (min sumHalf sumDouble sumAdd2)
                    )
                )
            )
        )
 
    ]
    (mazePath a b 1 30 (* (distance a b) 5))
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn find-shortest-path [start end]
  (let [
        required-manipulations [(partial * 2) (partial + 2)]
        optional-manipulation (fn [x] (/ x 2))
        gen-next-step (fn [prev-set]
                        (set (for [prev-element prev-set
                                   manipulate (if (even? prev-element)
                                                (conj required-manipulations optional-manipulation)
                                                required-manipulations)]
                               (manipulate prev-element))))]
    (->> #{start}
      (iterate gen-next-step)
      (take-while (fn [a-step] (not (contains? a-step end))))
      count
      inc)))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [init targ]
  (letfn [(half [n] (/ n 2))
          (times-two [n] (*' 2 n))
          (add-two [n] (+' n 2))
          (operations [n]
            (if (zero? (mod n 2))
              (map #(% n) [half times-two add-two])
              (map #(% n) [times-two add-two])))]
    (loop [n 1 res [init]]
      (if (some #(= targ %) res)
        n
        (recur (inc n) (mapcat operations res))))))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn f [start end]
  (let [adj (fn [x]
              (concat (if (even? x)
                        [(quot x 2)]
                        [])
                      [(+ x 2)]
                      [(* x 2)]))]
    (loop [q [[1 start]]]
      (let [[level x] (first q)]
        (if (= x end)
          level
          (let [q' (apply conj (into [] (next q))
                          (map (fn [x] [(inc level) x]) (adj x)))]
            (recur q')))))))
andthorn's solution:

1
2
3
4
5
6
(fn f 
  ([x n] (f [x] n 1))
  ([l n c]
   (if (some (partial = n) l)
     c
     (recur (flatten (map #(remove ratio? [(* 2 %) (+ 2 %) (/ % 2)]) l)) n (inc c)))))
anjensan's solution:

1
2
3
4
5
6
7
8
(fn [a b]
  (inc
   (count 
    (take-while 
     #(not (% b)) 
     (iterate 
      #(into #{} (mapcat (fn [x] [(* x 2) (+ x 2) ((if (odd? x) + /) x 2)]) %)) 
      #{a})))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn
  [src dest]
  ; use BFS
  (loop [q [[src 1]]
         visited #{}]
    (if (seq q)
      (let [[c l] (first q)
            t (vec (rest q))]
        (if (contains? visited c)
          (recur t visited)
          (if (= dest c)
            l
            (let [visited' (conj visited c)
                  l' (inc l)
                  q' (conj (conj t [(+ c 2) l'])
                           [(* c 2) l'])
                  q'' (if (odd? c)
                        q'
                        (conj q' [(quot c 2) l']))]
              (recur q'' visited')))))
      nil)))
austintaylor's solution:

1
2
3
4
5
6
(fn [a b]
  (loop [paths [a] i 1]
    (if (some #(= % b) paths)
      i
      (recur (mapcat #(concat [(* 2 %) (+ 2 %)]
        (if (zero? (mod % 2)) [(/ % 2)] [])) paths) (inc i)))))
awebb's solution:

1
2
3
4
(fn [s e]
   (let [step (juxt #(+ % 2) #(* % 2) #(/ % 2))
         gen (iterate (partial mapcat step) (list s))]
      (inc (count (take-while #(neg? (.indexOf % e)) gen)))))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [start target]
  (letfn 
    [(branch [[type value]]
      (filter identity 
        [(if (and (not= type :doubled) (even? value)) [:halved (/ value 2)]) 
         (if (not= type :halved) [:doubled (* value 2)]) 
         [:added (+ value 2)]]))
     (find-path [paths distance]
       (if (some #(= target (second %)) paths)
         distance
         (find-path (apply concat (map branch paths)) (inc distance))))]
    (find-path [[:initial start]] 1)))
benhammond's solution:

1
2
3
4
5
6
7
8
9
10
(fn [x y]
    (if (= x y) 1
                (loop [paths [[x]]]
                  (let [next-vecs (mapcat (fn [p] (map (partial conj p)
                                                       (remove nil? [(* 2 (last p))
                                                                     (+ 2 (last p))
                                                                     (if (even? (last p)) (/ (last p) 2))])))
                                          paths)
                        m (filter #(= y (last %)) next-vecs)]
                    (if (empty? m) (recur next-vecs) (apply min (map count m)))))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
(fn [start end]
  (letfn [(choices [n]
            (into [(+ 2 n) (* 2 n)]
                  (when (even? n) [(/ n 2)])))]
    (let [sets (iterate
                (fn [states]
                  (into #{}
                        (mapcat choices states)))
                #{start})]
      (inc (count (take-while #(not (some #{end} %)) sets))))))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s e]
  (letfn
    [(children [s d]
       (lazy-cat [[(* s 2) (inc d)]
                  [(+ s 2) (inc d)]]
                 (if (zero? (mod s 2))
                   [[(quot s 2) (inc d)]]
                   [])))
     (bfs [s]
       (lazy-seq (let [f (peek s)
                       r (pop s)]
                   (cons f (bfs (into r (children (first f) (second f))))))))]
    (second (first (drop-while #(not= (first %) e) (bfs (conj clojure.lang.PersistentQueue/EMPTY [s 1])))))))
burner's solution:

1
2
3
4
5
6
7
8
9
10
(letfn [(step [n]
                (set (concat [(* 2 n) (+ 2 n)]
                             (if (even? n)
                               [(/ n 2)]))))
              (find-way [positions finish]
                (if (> (count (filter #(= % finish) positions)) 0)
                  1
                  (inc (find-way (mapcat step positions) finish))))]
        (fn [start finish]
          (find-way [start] finish)))
caterpillar's solution:

1
2
3
4
5
6
;not about numbers, actually about graph
(fn maze-path [x y]
  (let [ops [#(* 2 %) #(if(even? %) (quot % 2) %) #(+ 2 %)]]
    (loop [paths #{x} length 1]
      (if (contains? paths y) length
        (recur (set (for [p paths op ops] (op p))) (inc length))))))
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [init goal]
  (loop [ll #{init}
         lled #{}
         cache {init 1}]
    (cond (cache goal) (cache goal)
          :else
          (let [current (apply min ll)
                clength (inc (cache current))
                nexts (filter #(and (integer? %)
                                    ((complement contains?) cache %))
                              (list (* 2 current)
                                    (+ 2 current)
                                    (/ current 2)))
                next_cache (reduce (fn [acc e] (assoc acc e clength))
                                   cache
                                   nexts)]
            (recur (clojure.set/difference (into (disj ll current) nexts)
                                           lled)
                   (conj lled current)
                   next_cache)))
    ))
chunchangshao's solution:

1
2
3
4
5
#(case (+ % %2)
   2 1
   11 9
   21 5
   3)
ctzsm's solution:

1
2
3
4
5
6
7
8
9
10
(fn [start end]
  (letfn [(step [h n d]
                (let [v (if (odd? n) (vector (* n 2) (+ n 2)) (vector (* n 2) (/ n 2) (+ n 2)))]
                  [(vec (map (fn [x] (vector d x)) (filter (comp not h) v))) (vec (filter (comp not h) v))]))
          (BFS [que h]
               (let [node (first que) ans (first node) n (second node) ne (step h n (inc ans))]
                 (if (= n end)
                   ans
                   (recur (concat (rest que) (first ne)) (into h (second ne))))))]
    (BFS [[1 start]] #{start})))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(letfn [(maze
         [n depth]
         (lazy-seq
          (let [depth (inc depth)]
            (list* [n depth]
                   (maze (* n 2) depth)
                   (maze (+ n 2) depth)
                   (when (even? n)
                     [(maze (/ n 2)
                            depth)])))))
        (bfs
         [tree]
         ((fn search [queue]
            (lazy-seq
             (when (seq queue)
               (let [[x & xs] (peek queue)]
                 (cons x (search (into (pop queue)
                                       xs)))))))
 
           (conj clojure.lang.PersistentQueue/EMPTY
                 tree)))]
 
  (fn number-maze [start goal]
    (->> (bfs (maze start 0))
         (filter (comp #{goal} first))
         first second)))
daniels's solution:

1
2
3
4
5
6
7
(fn [s t]
  (loop [c #{s} l 1]
    (if (contains? c t)
      l
      (recur (into #{} (apply concat (map #(if (odd? %)
                     [(+ 2 %) (* 2 %)]
                     [(+ 2 %) (* 2 %) (/ % 2)]) c))) (inc l)))))
daowen's solution:

1
2
3
4
5
6
7
8
(fn n-maze [start end]
  (let [double #(* 2 %)
        halve  #(if (odd? %) nil `(~(quot % 2)))
        add2   #(+ 2 %)
        ops    #(list* (double %) (add2 %) (halve %))]
    (loop [xs [start], i 1]
      (if (some #(== % end) xs) i
        (recur (mapcat ops xs) (inc i))))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn _ 
  ([s e] (first (sort (flatten (_ 1 s e))))
  )
  ([n c e]
    (if (or (> n 10) (= c e)) [n]
      (if (even? c)
         (conj [] (_ (inc n) (+ c 2) e) (_ (inc n) (* c 2) e) (_ (inc n) (quot c 2) e))
         (conj [] (_ (inc n) (+ c 2) e) (_ (inc n) (* c 2) e))
      )
    )
  ) 
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [s e]
  (loop [close #{} 
         open [[1 s]]]
    (let [pair (first open)
          ele (second pair)
          steps (first pair)]
      (if (= ele e) steps 
        (let [new-close (cons ele close)
              new-open (rest open)
              gen-eles (if (even? ele) [(* 2 ele) (/ ele 2) (+ ele 2)] 
                                       [(* ele 2) (+ ele 2)])
              new-eles (filter #(not (contains? close %)) gen-eles)
              new-pairs (map vector (repeat (count new-eles) (inc steps)) new-eles)
              ]
            (recur new-close (concat new-open new-pairs))
          ))
  )))
devm33's solution:

1
2
3
4
5
6
7
8
(fn [s t]
  (loop [que [[s 1]]]
    (when-let [[c l] (last que)]
      (if (= t c) l
        (recur (conj (butlast que)
                     [(* c 2) (inc l)]
                     [(/ c 2) (inc l)]
                     [(+ c 2) (inc l)]))))))
dwelte's solution:

1
2
3
4
5
6
7
8
9
(fn [v e]
  ((fn [xs]
     (let [[vx cx] (peek xs)
           rxs (pop xs)
           fs [#(* 2 %) #(if (odd? %) nil (/ % 2)) #(+ 2 %)]]
       (if (= vx e)
         cx
         (recur (into rxs (filter first (map (fn [f] [(f vx) (inc cx)]) fs)))))))
   (conj clojure.lang.PersistentQueue/EMPTY [v 1])))
dzholev's solution:

1
2
3
4
5
(fn [a b]
  (loop [c #{a} i 1]
    (if (c b)
      i
      (recur (set (filter integer? (mapcat #(list (* % 2) (/ % 2) (+ % 2)) c))) (inc i)))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn nbr-maze [a b]
 (letfn  [
  (update [[visited vset :as t] n]
   (if (contains? visited n)
    [visited vset]
    [(conj visited n) (conj vset n)])) ;; optimiser le [conj conj]
  (new-vset [vset]
   (set (mapcat #(list (* 2 %1) (+ 2 %1) (if (even? %1) (/ %1 2) (+ 2 %1))) vset)))
  (rec-nbr-maze [ [visited vset] d ]
   (if (contains? vset b)
    d
    (rec-nbr-maze (reduce update [visited #{}] (new-vset vset)) (inc d))))]
    (rec-nbr-maze [#{a} #{a}] 1)))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [start end]                                                                                                                                         
    ((fn bfs [queue seen]                                                                                                       
        (if (empty? queue)                                                                                                                              
            (println "No solution. This should never happen.")                                                                  
            (let [[num depth] (first queue) depth+1 (inc depth)                                                                                         
                  a (* num 2) b (+ num 2) c (/ num 2)]                                                                          
                (cond                                                                                                                                   
                    (seen num) (bfs (rest queue) seen)                                                                          
                    (= num end) depth                                                                                                                   
                    (or (= a end) (= b end) (= c end))  depth+1                                                                 
                    :else                                                                                                                               
                        (bfs (concat (rest queue)                                                                               
                                     (keep identity [[a depth+1] [b depth+1] (if (even? num) [c depth+1])]))                    
                             (assoc seen num depth+1))))))                                                                      
    [[start 1]] {}))
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [from goal]
  (let [operations [(partial * 2)
                    (fn [x]
                      (if (odd? x) x (quot x 2)))
                    (partial + 2)]
        start #{from}]
    (letfn [(possible-steps [positions]
              (set (for [op operations, pos positions] (op pos))))]
      (loop [pos start, step 1]
        (if (contains? pos goal)
          step
          (recur (possible-steps pos) (inc step)))))))
finsternis's solution:

1
2
3
(fn [s e]
  (letfn [(n2 [n] (let [v [(* n 2) (+ n 2)]] (if (even? n) (conj v (/ n 2)) v)))]
    (loop [vs #{s} k 1] (if (some #{e} vs) k (recur (set (mapcat n2 vs)) (inc k))))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn number-maze
  [a b]
  (letfn [(neigh [a] (flatten [(+ 2 a) (* 2 a) (if (even? a) (quot a 2) [])]))]
    (loop [i 1 prev #{} cur #{a}]
      (let [p (clojure.set/union prev cur)]
      (if (contains? cur b)
        i
        (recur 
          (inc i) 
          p
          (clojure.set/difference (set (flatten (map neigh cur))) p)))))))
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [start end]
  (letfn [(transform [num]
            (if (even? num)
              [(* 2 num) (+ 2 num) (quot num 2)]
              [(* 2 num) (+ 2 num)]))
          (step [current-set end step-count]
            (let [next-set (reduce into #{} (map transform current-set))]
              (if (next-set end)
                (inc step-count)
                (step next-set end (inc step-count)))))]
    (if (= start end)
      1
      (step #{start} end 1))))
geekerzp's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s e]
    (letfn [(f [xs]
              (lazy-cat [xs]
                        (f (clojure.set/union
                            (set (map #(+ % 2) xs))
                            (set (map #(* % 2) xs))
                            (set (map #(/ % 2) (filter even? xs)))))))]
      (->> (f #{s})
           (take-while #(not (contains? % e)))
           count
           inc)))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn number-maze [start goal]
  (let [assoc-conj
          (fn [map empty key new-val]
            (let [coll (get map key empty)]
              (assoc map key (conj coll new-val))))
        enqueue (fn [q nums] (assoc-conj q [] (count nums) nums))
        dequeue
          (fn dequeue [q]
            (let [[len items] (first q)]
              (if (seq items)
                [(peek items) (assoc q len (pop items))]
                (dequeue (dissoc q len))
              )))
        calc-successors
          (juxt #(* 2 %) #(if (even? %) (quot % 2) -1) #(+ 2 %))
    ]
    (loop [queue (enqueue (sorted-map) [start]) seen #{-1}]
      (let [[nums queue] (dequeue queue)
            n (peek nums)]
        (if (= n goal)
          (count nums)
          (let [successors (remove seen (calc-successors n))]
            (recur (reduce enqueue queue (map (partial conj nums) successors))
                   (conj seen n)))
        )))))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn gotmaze [st ed]
(clojure.walk/walk #(if (= (second %) ed) (first %) nil)
           (fn [x] (->> (remove #(= % nil) x)
                       (sort-by count)
                   first
                   count
                   inc))
(tree-seq #(and (not= (second %) ed) (not= (second %) -1))
      (fn [[pat nv]]
          (let [a (+ nv 2) b (* nv 2) 
                c (if (even? nv) (/ nv 2) -1)]
                (if (< (count pat) 8)
                  [[(conj pat a) a]
               [(conj pat b) b]
               [(conj pat c) c]]
              [[[] -1] [[] -1] [[] -1]])))
        [[] st])))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [start end]
  (inc (count (take-while #(not (% end))
                          (iterate (fn [s]
                                     (set
                                      (mapcat
                                       #(concat
                                         (list (* % 2)
                                               (+ % 2))
                                         (if (even? %)
                                           (list (/ % 2))
                                           '()))
                                       s))) #{start})))))
happycrisis's solution:

1
2
3
4
5
6
7
8
9
10
(fn [start end]
  (loop [q [[start 1]] seen #{}]
    (let [[n ct] (first q)]
      (if (= n end)
        ct
        (let [succ (conj (when (even? n) (list (/ n 2))) (* n 2) (+ n 2))
              succ (map #(vector % (inc ct)) (remove seen succ))
              nxt (subvec q 1)]
          (recur (if (empty? succ) nxt (apply conj nxt succ))
                 (conj seen n)))))))
hisba's solution:

1
2
3
4
5
(fn [S E]
  (loop [tr #{S} s #{S} le 1]
    (if (s E) le
      (let [n_s (remove tr (set (mapcat #(concat [(+ 2 %) (* 2 %)] (when (even? %) [(quot % 2)])) s)))]
        (recur (into tr n_s) (set n_s) (inc le))))))
icamts's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [s t]
  (letfn [(double-f [n] (* n 2))
          (halve-f [n] (if (even? n) (/ n 2)))
          (add2-f [n] (+ n 2))
          (step [ss]
                (disj (set (mapcat 
                               (juxt double-f halve-f add2-f) 
                               (apply list ss))) nil))
          (maze-it [ss i]
                   (if (contains? ss t) i
                     (recur (step ss) (inc i))))]
    (maze-it (hash-set s) 1)))
immo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [x y]
  (inc
    (count
      (take-while
        (complement #(% y))
        (iterate
          (fn [s]
            (set
              (flatten
                (map
                  (fn [i] 
                    (filter 
                      integer?
                      (map #(% i 2) [* + /])))
                  s))))
          #{x})))))
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [from to]
  (loop [cand #{from} cost 1]
    (if (contains? cand to)
      cost
      (recur
        (into #{}
          (concat 
            (map #(+ % 2) cand)
            (map #(* % 2) cand)
            (map #(/ % 2) (filter even? cand))))
        (inc cost)))))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn number-maze [num sol]
  (loop [found [[1 num]]]
        (let [ele (first found) steps (first ele) n (second ele)]
            (if (= n sol) steps
                (let [s (inc steps) newfound (into [] (rest found))]
                    (if (even? n) (recur (conj newfound [s (/ n 2)] [s (* n 2)] [s (+ n 2)]))
                        (recur (conj newfound [s (* n 2)] [s (+ n 2)]))
                    )
                )  
            )
        )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [a b]
  (letfn [(more [[l x]]
            (let [l2 (inc l)
                  ret [[l2 (* x 2)]
                       [l2 (+ x 2)]]]
              (if (even? x)
                (conj ret [l2 (/ x 2)])
                ret)))]
 
    (->> [[1 a]]
         (iterate #(mapcat more %))
         (apply concat)
         (filter #(= b (second %)))
         ffirst)))
johncowie's solution:

1
2
3
4
5
(fn [a b]
  (loop [n 1 r [a]]
    (if (some #{b} (set r))
      n
      (recur  (inc n) (flatten (map #(vector (+ % 2) (* % 2) (/ % 2)) r))))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn number-maze [x y]
  (letfn [(walk [n ret depth]
                (cond (== depth 0) Double/POSITIVE_INFINITY
                      (== n y) (inc (count ret))
                      :else
                      (min  (walk (* n 2)
                                  (conj ret n)
                                  (dec depth))
                            (if (even? n)
                              (walk (/ n 2)
                                    (conj ret n)
                                    (dec depth))
                              Double/POSITIVE_INFINITY)
                            (walk (+ n 2)
                                  (conj ret n)
                                  (dec depth)))))]
    (loop [i 1
           ret (walk x [] i)]
      (if (< ret Double/POSITIVE_INFINITY)
        ret
        (recur (inc i)
               (walk x [] (inc i)))))))
jorendorff's solution:

1
2
3
4
(fn [a b] (inc (count (take-while
                       #(not (% b))
                       (iterate (fn [a] (set (filter #(= % (int %)) (for [j a f [+ * /]] (f j 2)))))
                                #{a})))))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn number-maze [start end]
  (loop [current start count 0]
    (cond (or (= current end) (> count 15)) (inc count)
          (odd? current) (cond
                           (< (* current 2) end) (recur (* current 2) (inc count))
                           (< current (dec end)) (recur (+ current 2) (inc count))
                           :othersise (recur (* current 2) (inc count)))
          (even? current) (cond
                            (and (>= current (* 2 end)) (or (not (odd? (/ current 2))) (odd? end))) (recur (/ current 2) (inc count))
                            (<= (* 2 current) end) (recur (* current 2) (inc count))
                            :otherwise  (recur (+ current 2) (inc count))))))
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s e]
  (if (= s e) 1
    (loop [l 1 a [s]]
      (let [b (mapcat
                (fn [c]
                  (#(if (even? c) (cons (/ c 2) %) %)
                    (list (+ c 2) (* c 2))))
                a)]
        (if (some #(= % e) b)  
            (inc l)
            (recur (inc l) b))))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn f [a b]
  (if (= a b) a
      (letfn [(sf [b path]
                (->> path
                     first
                     ((fn [x] [x (* 2 x) (+ 2 x) (if (even? x) (/ x 2) nil)]))
                     (filter #(not (nil? %)))
                     (map #(conj path %))))]
        (loop [p (list (list a))]
          (let [r (reduce into (map #(sf b %) p))
                k (filter #(= b (first %)) r)]
            (if (< 0 (count k)) (-> k first count)
                (recur r)))))))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn prob106
  [start end]
  (let [choices (fn [path]
                  (let [head (first path)]
                    (for [op [* / +]
                          :let [next (op head 2)]
                          :when (integer? next)]
                      ;; put at the head
                      (cons next path))))
 
        search (fn [path] (mapcat choices path))
 
        goal (fn [p] (= end (first p)))]
    (count         ;; length of the path is what we want
     (ffirst        ;; first of the first
      (filter seq   ;; remove empty results
              ;; call search looking for results that reach the goal   
              (map #(filter goal %) (iterate search [[start]]))
              )
      )
     )  
    )  
)
brendan's solution:

1
2
3
4
5
6
7
8
; Evil hack
(fn [& _]
  (reify Object
    clojure.lang.IPersistentCollection
    (seq [_])
    (cons [_ _])
    (empty [_])
    (equiv [_ _] true)))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
(fn my-number-maze
  [x y]
  (loop [coll (vector x) i 1]
    (if (some #(= y %) coll)
      i
      (recur (filter (complement nil?) 
                     (mapcat #(conj [] 
                                    (* 2 %)
                                    (+ 2 %)
                                    (when (even? %) (/ % 2))) coll)) (inc i)))))
lackita's solution:

1
2
3
4
5
6
7
8
9
(fn [start finish]
  (loop [distance 1
         positions #{start}]
    (if (positions finish)
      distance
      (recur (inc distance)
             (set (concat (map #(* 2 %) positions) 
                          (map #(+ 2 %) positions)
                          (map #(/ % 2) (filter even? positions))))))))
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [start goal]
  (let [fs [#(* % 2)
            #(+ % 2)
            #(and (even? %)
                  (/ % 2))]]
    (loop [distance 1
           xs [start]]
      (if (some #{goal} xs)
        distance
        (let [ys (for [x xs
                       f fs
                       :let [y (f x)]
                       :when (number? y)]
                   y)]
          (recur (inc distance) ys))))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn shortest-path
  ([a b] (shortest-path #{a} b 0))
  ([a b n]
   (if (contains? a b)
     (inc n)
     (recur (reduce
             #(into (conj %1 (* %2 2) (+ %2 2))
                    (if (zero? (mod %2 2)) [(/ %2 2)]))
             #{} a)
            b (inc n))
     )
   )
  )
lbarrett's solution:

1
2
3
4
5
6
7
;; breadth-first search
(fn f [start end]
  (loop [cur #{start} i 1]
    (if (cur end)
      i
      (recur
       (set (filter integer? (mapcat #(list (* % 2) (/ % 2) (+ % 2)) cur))) (inc i)))))
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s e]
  (if (= s e) 1
    (let [next-step 
            (fn [ls] 
              (reduce 
                #(into %1
                  (if (odd? %2)
                    [(* 2 %2) (+ 2 %2)]
                    [(* 2 %2) (+ 2 %2) (/ %2 2)])) #{} ls))]
      (some 
        (fn [c]
          (when (some #{e} (second c)) (first c))) 
        (map vector (iterate inc 1) (iterate next-step [s]))))))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [n1 n2] 
  ((fn maze [l b]
    (if (some #(= (last %) b) l)
      1
      (inc (maze 
            (remove #(contains? (rest %) (last %))
                    (mapcat
                     #(map
                       (partial conj %)
                       (if (even? (last %)) 
                         [(* (last %) 2) (+ (last %) 2) (/ (last %) 2)]
                         [(* (last %) 2) (+ (last %) 2)]))
                     l))
            b)))) 
   [[n1]] n2))
malvert's solution:

1
2
3
4
5
6
7
8
(fn [a b]
  ((fn f [s n]
    (if ((set s) b) 
      n
      (f 
        (mapcat (fn [e] (map #(% e 2) [* / +])) s) 
        (+ 1 n))))
   [a] 1))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [x goal]
  (letfn [(step [x]
            (if (odd? x)
              #{(+ x x) (+ x 2)}
              #{(+ x x) (+ x 2) (quot x 2)}))]
    (loop [iteration 1
           previous #{x}]
      (if (contains? previous goal)
        iteration
        (recur (inc iteration)
               (apply clojure.set/union
                      (map step previous)))))))
maximental's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [n m]
  (loop [p 1 s #{n}]
    (if (s m) 
      p 
      (recur (+ p 1) 
             (reduce #(conj %
                            (if (even? %2) (/ %2 2) n)
                            (* %2 2)
                            (+ %2 2))
                     s 
                     s)))))
mbakhterev's solution:

1
2
3
(fn [s e]
  (loop [[[v l] & Q] [[s 1]]]
    (if (= v e) l (recur (concat Q (for [i (filter integer? ((juxt * + /) v 2))] [i (inc l)]))))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn number-maze--brute
  [x y] {:pre [(every? integer? [x y]), (every? pos? [x y])]}
  (let [;; This function returns a sequence containing all numbers reachable
        ;; from n in one operation.
        maze-adj
        (fn [n]
          (if (even? n)
            [(* n 2) (/ n 2) (+ n 2)]
            [(* n 2) (+ n 2)]))]
    ;; In this loop,
    ;; found is a set containing all numbers reachable in fewer than i steps,
    ;; while hits is a sequence containing numbers reachable in exactly i steps.
    (loop [found #{}, hits [x], i 1]
      (if (some #{y} hits)
        i
        (recur (into found hits)
               (mapcat maze-adj (remove found hits))
               (inc i))))))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [a b]
  (let [next-set (fn [s]
                   (set (flatten (map (fn [n]
                                        (if (odd? n)
                                          [(+ n 2) (* n 2)]
                                          [(+ n 2) (* n 2) (/ n 2)]))
                                      s))))]
    (loop [s #{a}
           c 1]
      (if (contains? s b)
        c
        (recur (next-set s) (inc c))))))
minitrue's solution:

1
2
3
4
(fn [s t]
  (let [f (fn [s]
            (set (mapcat #(if (integer? %) [(* % 2) (/ % 2) (+ % 2)]) s)))]
    (->> #{s} (iterate f) (take-while #(not (% t))) count inc)))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn numbermaze [m n]
  (let [nextstep (fn [v]
     (let [f (fn [x]
               (if (even? x)
                 (vector (* 2 x) (/ x 2) (+ x 2))
                 (vector (* 2 x) (+ x 2))))]
       (vector (inc (first v))
               (into (second v) (set (mapcat f (peek v))))
               (set (mapcat f (peek v))))))]
        (loop [vcounter [0 #{m} #{m}]]
          (if (nil? (some #{n} (peek vcounter)))
            (recur (nextstep vcounter))
            (inc (first vcounter))))))
mobiusloop's solution:

1
2
3
4
5
(fn [s t]
  (let [o (map #(fn [v] (% v 2)) [* / +])
        m #(set (for [x o y %] (x y)))]
    (inc (count (take-while (fn [l] (not-any? #(= t %) l)) (iterate #(m %) [s])))
  )))
mononite's solution:

1
2
3
4
5
6
7
(fn [s e] 
  (loop [len 1 args #{s}] 
    (if (some #(= % e) args) 
      len 
      (recur 
        (inc len) 
        (reduce (fn [acc s] (into acc (map #(% s 2) (if (even? s) [* / +] [* +])))) #{} args)))))
mouse's solution:

1
2
3
4
5
(fn [a b] (inc  (count
            (take-while #(not (% b))
                 (iterate (fn [s] (into s
                    (mapcat #(list* (* 2 %) (+ 2 %) (if (zero? (rem % 2)) [(quot % 2)]) ) s)) )
                  #{a})))))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [from to]
  (let [ops [#(* % 2)
             #(if (and (even? %) (pos? %))
                (/ % 2)
                nil)
             #(+ % 2)]]
    (loop [path-stack [[from]]]
      (let [current-path (first path-stack)
            val          (peek current-path)]
        (if (= val to)
          (count current-path)
          (let [new-vals  (keep #(% val) ops)
                new-paths (map #(conj current-path %) new-vals)]
            (recur (reduce conj
                           (subvec path-stack 1)
                           new-paths))))))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
;; NOTE: Hopefully inefficient. No need to generate combos up front like this.
(fn maze[start target]
  (letfn [(double-it [n] (+ n n))
          (half [n] (if (even? n) (/ n 2) n))
          (add-two [n] (+ n 2))
          (my-comp [n fs cnt]
            (cond
              (empty? fs) Integer/MAX_VALUE ;; not found
              (= target n) cnt ;; found it!
              :else (my-comp ((first fs) n) (rest fs) (inc cnt))))]
    (let [fs [double-it half add-two]
          combos-1 (for [a fs b fs c fs] [a b c])
          combos-2 (for [a fs b fs c fs d fs e fs f fs g fs h fs i fs] [a b c d e f g h i])
          quick-find (apply min
                            (map #(my-comp start % 1) combos-1))
          slow-find (fn [] (apply min
                                 (map #(my-comp start % 1) combos-2)))
          ]
 
      (if (< quick-find Integer/MAX_VALUE)
        quick-find
        (slow-find)))))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
(fn find-number [a b]
            (let [oper #(let [v [(* 2 %) (+ 2 %)]] (if (even? %) (conj v (/ % 2)) v))]
                 (loop [visited #{a}
                    queue (conj clojure.lang.PersistentQueue/EMPTY [a 1])]
                    (let [[value pos] (peek queue)
                          nxt (filter #(not (contains? visited %)) (oper value))]
                         (if (= value b)
                             pos
                             (recur (into visited nxt)
                                    (into (pop queue) (map #(vector % (inc pos)) nxt))))))))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [a b]
    (letfn [(nummaze [a b len]
                     (cond
                       (= len 0) false
                       (= a b) true
                       (nummaze (* 2 a) b (dec len)) true
                       (and (even? a) (nummaze (quot a 2) b (dec len))) true
                       (nummaze (+ 2 a) b (dec len)) true
                       :else false))]
    (first (filter #(nummaze a b %) (range 15)))))
    ;(first (filter #(nummaze a b %) (range)))))
norman's solution:

1
2
3
4
5
6
7
8
9
(fn number-maze [start-num end-num]
  (loop [visited #{} to-visit #{start-num} distance 0]
    (if (contains? visited end-num)
      distance
      (let [next-nums (fn [n]
                        (remove nil? (list (* 2 n) (when (even? n) (/ n 2)) (+ n 2))))
            next-frontier (disj (set (mapcat next-nums to-visit)) visited)]
 
        (recur (into visited to-visit) next-frontier (inc distance))))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
(fn [start end]
  (->> {start 1}
       (iterate
         (fn [endpoint-map]
           (into {}
                 (for [[num dist] endpoint-map
                       op (if (even? num) [* + /] [* +])]
                   [(op num 2) (inc dist)]))))
       (some #(% end))))
owk4057's solution:

1
2
3
4
5
6
7
8
(fn myf2 [start goal]
  (letfn [(next [start goal]
  (cond (= start goal) [start]
        (< start goal) [(* start 2) (+ start 2)]
        (> start goal) (if (even? start) [(/ start 2) (* start 2) (+ start 2)] [(* start 2) (+ start 2)])))]
  (loop [myset #{start}, res 1]
    (if (contains? myset goal) res
      (recur (set (mapcat #(next % goal) myset)) (inc res))))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [s e]
  (->> [s]
    (iterate
      (fn [xs]
        (mapcat
          #(let [v [(* % 2) (+ % 2)]]
             (if (even? %)
               (conj v (/ % 2))
               v))
          xs)))
    (map #(some #{e} %))
    (take-while nil?)
    (take 12)
    count
    inc))
ozan's solution:

1
2
3
4
5
6
7
8
9
10
(fn steps [start end]
  (loop [[[n depth] & others] [[start 1]]
         seen #{}]
    (if (= n end) depth
      (recur (concat others
                     (->> [(* n 2) (+ n 2) (/ n 2)]
                          (filter integer?)
                          (remove seen)
                          (map #(vector % (inc depth)))))
             (conj seen #{n})))))
pukeface's solution:

1
2
3
4
5
6
7
8
9
(let [f (fn [n] (if (= n 2) [1 4] (#(if (even? n) (conj % (/ n 2)) %) [(+ n 2) (+ n n)])))
      p (fn [g [[n s] & L]]
            (if (= n g) s
                (->> (f n)
                     (map #(vector % (inc s)))
                     (concat L)
                     (recur g))))
          ]
  (fn [s e] (p e [[s 1]])))
quant1's solution:

1
2
3
4
5
6
7
8
9
(letfn [(nm [a b d s]
  (cond
    (= a b) 1
    (zero? d) 2
    (s a) (+ 3 d)
    :else (inc (min (nm (* a 2) b (dec d) (conj s a))
                 (nm (+ a 2) b (dec d) (conj s a))
                 (if (zero? (mod a 2)) (nm (quot a 2) b (dec d) (conj s a)) d)))))]
  (fn [a b] (nm a b (* 2 (Math/abs (- a b))) #{})))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(fn [start end]
  (let
    [
     children
     (fn [[n0 & rest :as path]]
       (->>
        [(+ 2 n0) (* 2 n0)]
        (#(if (even? n0) (conj % (/ n0 2)) %))
        (remove #((set rest) %))
        (map #(conj path %))
       ))
       
     bfs-seq
     (fn walk [queue]
       (let [node (peek queue)]
         (lazy-seq
           (cons node (walk (into (pop queue) (children node)))))
     ) )
  ]
    (->>
     start
     list
     (conj clojure.lang.PersistentQueue/EMPTY)
     bfs-seq
     (filter #(= end (first %)))
     first
     count
     )
  ) )
sbondaryev's solution:

1
2
3
4
5
6
7
8
(letfn [(aux [x y n]
          (cond
            (= n 0) nil
            (= x y) (list x)
            (aux (* x 2) y (dec n)) (cons x (aux (* x 2) y (dec n)))
            (aux (+ x 2) y (dec n)) (cons x (aux (+ x 2) y (dec n)))
            (and (even? x) (aux (/ x 2) y (dec n))) (cons x (aux (/ x 2) y (dec n)))))]
  (fn f [x y] (count (some #(aux x y %) (range)))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
(fn search [nd-fst nd-lst]
  (letfn [(gen-next [st]
             (into #{} 
               (mapcat (fn [n]
                         (if (odd? n) [(* n 2) (+ n 2)]
                         [(* n 2) (/ n 2) (+ n 2)]))
                       st)))]
  (loop [i 1 node-set #{nd-fst}]
    (if (contains? node-set nd-lst) i
      (recur (inc i) (gen-next node-set))))))
sheldon's solution:

1
2
3
4
5
6
7
8
(fn [a b] 
   ((fn f [n s] 
      (let [r (apply hash-set (distinct 
        (mapcat 
          #(let [x (* 2 %) y (+ 2 %) z (if (even? %) (/ % 2))] 
             (remove nil? (list x y z)))
          s)))] (if (s b) n (f (inc n) r))))
     1 (hash-set a)))
silverio's solution:

1
2
3
4
5
6
7
8
9
#(loop [q [[% 1]]]
  (let [[n p] (first q)
        p1    (inc p)
        v1    [(+ n 2) p1]
        v2    [(* n 2) p1]
        v3    [(/ n 2) p1]]
    (if (= n %2) p
      (recur (concat (next q)
              (if (even? n) [v1 v2 v3] [v1 v2]))))))
skyrem's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [f t]
  (loop [from #{f} length 1]
    (if (contains? from t)
        length
      (recur 
       (set
        (concat
         (map (partial + 2) from)
         (map (partial * 2) from)
         (map #(/ % 2) (filter even? from))))
          (inc length)))))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
(fn f [i l r]
  (let [g #(f (inc i) % r)]
    (condp #(%1 l %2) r
      = i
      < (if (or (<= l (- r l)) (> 2 (- r l))) (g (* l 2)) (g (+ l 2))) 
      > (if (>= l (- l r))
            (if (even? l) 
                (if (#(or (even? %) (= r %)) (/ l 2)) (g (/ l 2)) (g (+ l 2)))
                (g (* l 2))))))) 1
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
(letfn [(candidates [x]
    (if (odd? x)
        [(* 2 x) (+ 2 x)]
        [(* 2 x) (+ 2 x) (/ x 2)]))
(maze [a b]
    (+ 1
      (count
        (take-while
          #(not (% b))
          (iterate #(into #{} (mapcat candidates %)) #{a})))))]
  maze)
syeerzy's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [a b] 
  (let [f (fn [i] 
            (if (odd? i) 
              [(* i 2) (+ i 2)]
              [(* i 2) (+ i 2) (/ i 2)]))
        fs (fn [li]
              (reduce into #{}
               (map f li)))]
    (loop [x #{a} c 1]
      (if (x b) c
        (recur (fs x) (inc c))))))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
(letfn [(s [x]
          (let [xs [(* x 2) (+ x 2)]]
            (if (even? x)
              (conj xs (/ x 2))
              xs)))
        (f [xs y n]
          (if (some #(= % y) xs)
            n
            (recur (set (mapcat s xs)) y (inc n))))]
  (fn [x y]
    (f #{x} y 1)))
thegeez's solution:

1
2
3
4
5
6
(fn [from to]
    (first (keep-indexed (fn [i r]
                           (when (some #{to} r) (inc i)))
                         (iterate (partial mapcat (fn [u]
                                                      (for [f (if (odd? u) [* +] [* / +])]
                                                        (f u 2)))) [from]))))
zzamboni's solution:

1
2
3
4
5
(fn number-maze [n1 n2]
  (->> n1 vector
       (iterate #(for [f [(partial * 2) (partial * (/ 2)) (partial + 2)] x %] (f x)))
       (take-while #(not (some #{n2} %)))
       count inc))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn __ [s e]
  (letfn [(f [xs]
             (lazy-cat [xs]
                       (f (clojure.set/union
                           (set (map #(+ % 2) xs))
                           (set (map #(* % 2) xs))
                           (set (map #(/ % 2) (filter even? xs)))))))]
    (->> (f #{s})
         (take-while #(not (contains? % e)))
         count
         inc)))
zipzop's solution:

1
2
3
4
5
6
7
8
9
(fn m ([s e] (m #{s} e 1))
      ([s e n]
       (if (contains? s e) n
         (let [z (fn [v]
                   (if (even? v)
                     #{(* v 2) (+ v 2) (/ v 2)}
                     #{(* v 2) (+ v 2)}))
          sx (reduce #(into %1 (z %2)) s s)]
         (m sx e (inc n))))))
yusubori's solution:

1
2
3
4
5
6
7
(fn [a b]
  (loop [c 1 s #{a}]
    (if (contains? s b) c
      (recur (inc c) (set (flatten (for [n s]
                                     ((juxt #(* 2 %)
                                            #(+ 2 %)
                                            #(if (odd? %) % (/ % 2))) n))))))))
ydash's solution:

1
2
3
4
5
6
7
8
9
#(loop [[[current path] & r] [[% 1]]]
   (if (= current %2)
     path
     (let [ip (inc path)] (recur (conj (vec (if (odd? current)
                                              r
                                              (conj r [(/ current 2) ip])))
                                       [(+ current 2) ip]
                                       [(* current 2) ip]
                                       )))))
vpeurala's solution:

1
(fn [a b] (letfn [ (next-numbers [n] (set (filter (complement nil?) (vector (* 2 n) (if (even? n) (/ n 2)) (+ 2 n))))) (expand [frontier old] (let [new-frontier (set (filter (complement #(contains? old %)) (mapcat next-numbers frontier))) new-old (clojure.set/union frontier old)] (vector new-frontier new-old))) (expansions [a b] (take-while (complement #(contains? (first %) b)) (iterate (partial apply expand) [#{a} #{}]))) (number-maze [a b] (inc (count (expansions a b)))) ] (number-maze a b)))
v_bogdanov's solution:

1
2
3
4
5
6
7
8
9
(fn f [x y & [c]]
    (let [m 10
          c (or c 0)
          d (+ 1 c)]
       (cond (= x y) 1
             (> c m) m
             true (inc (min (f (+ 2 x) y d)
                            (f (* 2 x) y d)
                            (if (odd? x) m (f (/ x 2) y d)))))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
(fn number-maze-106 [start end]
  (loop [current [start] steps 1]
    (if (some #{end} current)
      steps
      (recur (flatten
              (map (fn [x]
                       (if x
                         [(* 2 x) (+ 2 x) (if (even? x) (/ x 2))]))
                   current))
             (inc steps)))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
(fn find-path [s e]
  (loop [opts [s] depth 1]
    (if (some #{e} opts)
      depth
      (letfn [(solutions [n]
                (concat 
                  [(* n 2) (+ n 2)]
                  (if (even? n) [(/ n 2)] [])))]
        (recur (mapcat solutions opts) (inc depth))))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn mazey [start end]
  (cond
   (= start end) 1
   (or (= end (and (even? start) (/ start 2)))
       (= end (* 2 start))
       (= end (+ 2 start))) 2
       (< start end) (if (and (odd? start) (odd? end))
                       (+ 1 (mazey (+ 2 start) end))
                       (inc (mazey (* 2 start) end)))
   (odd? start) (+ 2 (mazey (+ 2 (* 2 start)) end))
   (and (not= (/ start 2) end) (odd? (/ start 2))) (+ 1 (mazey (+ 2 start) end))
   :else (+ 1 (mazey (/ start 2) end))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)