;; 121 Universal Computation Engine [m]

Takes mathematical formula in prefix notation,
returns a function that calculates the value of the formula.
The formula can contain nested calculations
using the four basic mathematical operators,
numeric constants, and symbols representing variables.
The returned function has to accept a single parameter
containing the map of variable names to their values. 
Special Restrictions: eval, resolve

(= 2 ((__ '(/ a b))
      '{b 8 a 16}))
(= 8 ((__ '(+ a b 2))
      '{a 2 b 4}))
(= [6 0 -4]
     (map (__ '(* (+ 2 a)
                  (- 10 b)))
            '[{a 1 b 8}
              {b 5 a -2}
              {a 2 b 11}]))
(= 1 ((__ '(/ (+ x 2)
              (* 3 (+ y 1))))
      '{x 4 y 1}))
 
(fn [form]
  (fn [values]
    (let [env (merge {'+ + '- - '* * '/ /} values)] 
     ((fn eval- [f]
        (if (seq? f)
            (let [[op & args] f] (apply (env op) (map eval- args)))
            (get env f f)))
       form))))

#(-> (fn my-eval [ops form bindings]
         (if (sequential? form)
           (let [[op & args] form]
             (->> args (map (fn [v] (my-eval ops v bindings)))
                 (apply (ops op))))
           (get bindings form form)))
   (partial {'/ / '* * '+ + '- -} %))

(fn mf
  [[f & args]]
  (fn
    [m]
    (let [fs {'* `~* '/ `~/ '- `~- '+ `~+}]
    (apply (get fs f) (map #(if (seq? %) ((mf %) m) (if (symbol? %) (get m %) %)) args)))))

(fn compute 
  ([formula]
   (fn bindCompute [symbolMap];bind symbol map
     (compute (into {'+ + '- - '* * '/ /} symbolMap) formula)));add operator symbols
  ([symbolMap formula];with binded symbols
   (if (seq? formula)
     (apply (compute symbolMap (first formula))
            (for [sym (rest formula)];generate binded values
              (compute symbolMap sym)))
     (symbolMap formula formula))));take operators or symbol values

(fn [f] (fn [w] (letfn [(evil [v s]
  (cond (coll? s)
    (apply (evil v (first s)) (map #(evil v %) (rest s)))
    (v s) (v s)
     true s))]
  (evil (merge w {'+ + '/ / '* * '- -}) f))))
aceeca1's solution:

1
2
3
4
5
partial (fn compute-with [x env] (letfn [
    (compute [x] (if (list? x) 
        (#(apply (first %) (rest %)) (map compute x))
        (or (env x) ({'+ + '- - '* * '/ /} x) x)))]
    (compute x)))
adereth's solution:

1
2
3
4
5
#(fn [m] ((fn v [x] (if (number? x) x
                        (let [[op & r] x]
                          (apply ({'/ / '* * '+ + '- -} op)
                                 (map v r)))))
           (clojure.walk/prewalk-replace m %)))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn calcX [f]
    (letfn [
        (calcRec[f v]
            (cond 
                (symbol? f) (get v f)
                (number? f) f
                :else (case (first f)
                        / (apply / (map #(calcRec % v) (rest f))) 
                        +  (apply + (map #(calcRec % v)  (rest f)))
                        -  (apply - (map #(calcRec % v)  (rest f)))
                        *  (apply * (map #(calcRec % v)  (rest f)))             
                    )
            )
        )
        ]
        (partial calcRec f)
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn calculate [formula]
  (fn [parameters]
    (let [[op & pars] formula
          opf ({(symbol "+") +
                (symbol "-") -
                (symbol "*") *
                (symbol "/") /} op)
          eval-par (fn [par] (cond (coll? par) ((calculate par) parameters)
                                   (nil? (parameters par)) par
                                   :else (parameters par)))
          evaled-pars (map eval-par pars)]
      (apply opf evaled-pars))))
alanforr's solution:

1
2
3
4
5
6
7
(fn [formula]
  (letfn [(ev [v f]
              (cond
               (number? f) f
               (symbol? f) (v f)
               :else  (apply ({'* * '/ / '+ + '- -} (first f)) (map #(ev v %) (rest f)))))]
    (fn [x] (ev x formula))))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn f [exprs]
  (fn f' [m]
    (letfn [(g' [exprs]
               (println "going in for" exprs)
               (let [m' (merge m {'+ +, '- -, '/ /, '* *})
                     expanded (map (fn [expr]
                                     (if (coll? expr)
                                       (g' expr)
                                       (get m' expr expr)))
                                   exprs)]
                 (apply (first expanded) (rest expanded))))]
      (g' exprs))))
andthorn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [l]
   (let [me (fn me [l m]
              (let [f (first l)
                    g #(if (coll? %)
                         (me % m)
                         (if (symbol? %)
                           (get m %)
                           %))
                    xs (map g (next l))]
                (apply (get {'+ + '- - '* * '/ /} f) xs) ))]
     (fn [m] (me l m) )
     ))
anjensan's solution:

1
2
3
4
5
6
7
(fn [v] 
  (fn [m] 
    (let [r (fn r [a]
              (if (seq? a)
                (apply ({'+ + '- - '* * '/ /} (first a)) (map r (rest a)))
                (m a a)))]
      (r v))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn
  [exp]
  (fn [env]
    (letfn [(myeval [x]
              (cond
                (list? x) (apply (myeval (first x)) (vec (map myeval (rest x))))
                (symbol? x) (cond
                             (= x '*) *
                             (= x '+) +
                             (= x '/) /
                             (= x '-) -
                             :else (env x))
                (number? x) x))]
      (myeval exp))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [body]
  (fn [bindings]
    (letfn [(evaluate [expr]
      (cond
        (sequential? expr)
          (apply ({'/ / '* * '+ + '- -} (first expr)) (map evaluate (rest expr)))
        (integer? expr)
          expr
        true
          (bindings expr)))]
      (evaluate body))))
awebb's solution:

1
2
3
4
5
6
7
8
(fn ucr [expr]
  (fn ret [dict]
    ((fn evl [[op & args]]
      (apply ( { '+ + '- - '* * '/ / } op )
        (map #(cond (number? %) % 
                    (symbol? %) (dict %) 
                    :else (evl %)
               ) args))) expr )))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [xp]
  (fn [m]
    (letfn
      [(replace [[k v] itm]
         (cond
           (coll? itm) (map (partial replace [k v]) itm)
           (= itm k) v
           :else itm))
       (pseudo-eval [[head & tail]]
         (let 
           [f (condp = head '+ + '- - '* * '/ /)]
           (apply f (map (fn [itm] (if (coll? itm) (pseudo-eval itm) itm)) tail))))]                    
      (pseudo-eval (reduce (fn [acc kv] (map (partial replace kv) acc)) xp m)))))
benhammond's solution:

1
2
3
4
5
(fn uce [f]
  (fn [env]
    (cond (seq? f) (apply (case (first f) + + - - * * / /) ((apply juxt (map uce (rest f))) env))
          (number? f) f
          (symbol? f) (get env f))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
#(partial
  (fn evl [expr bindings]
    (or (bindings expr)
        (if (sequential? expr)
          (let [[op & args] expr
                evaled (map (fn [x] (evl x bindings)) args)
                op ({'+ + '- - '* * '/ /} op)]
            (apply op evaled))
          expr)))
  %)
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [formula]
  (fn [bind]
    (let [rename (fn rename [lst m]
                   (map (fn [ele]
                          (cond (list? ele)
                                (rename ele m)
                                (or (= '+ ele)
                                    (= '- ele)
                                    (= '/ ele)
                                    (= '* ele))
                                ele
                                (number? ele)
                                ele
                                :else
                                (get m ele)))
                        lst))
          calc (fn calc [f]
                 (if (not (seq? f)) f
                   (let [fi (first f)
                         res (map calc (rest f))]
                     (cond (= fi '+) (apply + res)
                           (= fi '-) (apply - res)
                           (= fi '/) (apply / res)
                           (= fi '*) (apply * res)))))]
      (calc (rename formula bind)))))
burner's solution:

1
2
3
4
5
6
7
8
9
10
(fn compute [expr]
          (fn [m]
            (if (seq? expr)
              (let [op (first expr)
                    ops (map #((compute %) m) (rest expr))]
                (cond (= op '+) (apply + ops)
                      (= op '-) (apply - ops)
                      (= op '*) (apply * ops)
                      (= op '/) (apply / ops)))
              (if (contains? m expr) (m expr) expr))))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn univCompEng [formula]
  (letfn[(getSymMap[symVal]
                   (apply assoc {} 
                          (mapcat 
                           (fn[[sym val]] [(keyword (str sym)) val])
                           (vec symVal))))
         (evalFormula[[op & nums] symMap]
                       (apply
                        (case (str op)
                          "/" /
                          "+" +
                          "-" -
                          "*" *)
                        (map 
                         (fn [x]
                           (cond
                            (symbol? x) (symMap (keyword (str x)))
                            (coll? x) (evalFormula x symMap)
                            :else x))
                         nums)))]
    (fn [symbolValue]
      (evalFormula formula (getSymMap symbolValue)))))
cc787's solution:

1
2
3
4
5
6
7
8
(fn f [xs]
    (fn [m]
      (let [m (merge m {'+ + '- - '* * '/ /})]
        (if (coll? xs)
          (#(apply (first %) (rest %)) (map #((f %) m) xs))
          (m xs xs)))
      )
    )
chunchangshao's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn
  [str-fn]
  (fn
  [x]
  (letfn [(sym-2-str [[k v]] {(str k) v})
          (fn-choose [f-sym] (case (str f-sym) "+" + "-" - "*" * "/" /))
          (eval-fn [f m] (if ((complement seq?) f)
                           (if (number? f) f (m (str f)))
                           (apply (fn-choose (first f)) (map eval-fn (next f) (repeat m)))
               ))]
          (eval-fn str-fn (into {} (map sym-2-str x))))))
ctzsm's solution:

1
2
3
4
5
6
7
(fn [f]  (fn [m] ((fn X [t] (apply (cond (= '+ (first t)) +
                                           (= '- (first t)) -
                                           (= '* (first t)) *
                                           (= '/ (first t)) /)
  (map #(cond (coll? %) (X %)
              (contains? m %) (m %)
              :else %) (rest t)))) f)))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(letfn [(calc
         [vars expr]
         (if (seq? expr)
           (let [[op & args]
                 (map (partial calc vars)
                      expr)]
             (apply op args))
           (if-let [bind (vars expr)]
             bind
             (condp = expr
              '+ +
              '- -
              '* *
              '/ /
              expr))))]
  
  (fn solve [expr]
    #(calc % expr)))
daniels's solution:

1
2
3
4
5
6
7
(fn [a] 
  (fn [b] 
    (clojure.walk/postwalk 
     #(if (seq? %) (apply (first %) (rest %)) %)
     (clojure.walk/postwalk-replace (assoc b '+ + '- - '* * '/ /) a))
  )
)
daowen's solution:

1
2
3
4
5
6
7
8
9
(fn calc [expr]
  (let [ops {'+ + '- - '* * '/ /}]
    (letfn [(solve [expr bindings]
                   (cond
                     (coll? expr) (apply (ops (first expr))
                                         (map #(solve % bindings) (rest expr)))
                     (symbol? expr) (bindings expr)
                     (number? expr) expr))]
      (fn [bindings] (solve expr bindings)))))
del680202's solution:

1
2
3
4
5
6
7
(fn [formal]
  (fn [v_map]
    ((fn _exec [expr] (let [[f & args] expr]
      (apply ({"+" + "-" - "*" * "/" /} (str f)) (for [arg args](if (contains? v_map arg) (v_map arg) (if (seq? arg) (_exec arg) arg) ) ))
    ))  formal)
  )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [form] 
  (fn ! [params] 
    (letfn [(compe [tree]
        (if (seq? tree) 
          (let [valsl (map #(compe %) (rest tree))
                re (case (first tree) 
                     / (reduce / valsl)
                     * (reduce * valsl)
                     + (reduce + valsl)
                     - (reduce - valsl))]
                re)
            (let [valme (if (number? tree) tree (params tree))]
            (do (println valme)
              valme))
          )
                   )]
      (compe form))))
devm33's solution:

1
2
3
4
5
(fn [s]
  (let [fmap {'/ / '* * '+ + '- -}]
    (fn [v]
      ((fn call [[o & a]]
         (apply (fmap o) (map #(if (coll? %) (call %) (get v % %)) a))) s))))
dwelte's solution:

1
2
3
4
5
6
7
8
9
10
(fn o [v]
  (fn e [m]
    (cond
     (list? v)
     (let [op ({'+ +, '- -, '* *, '/ /} (first v))]
       (apply op (map #((o %) m) (rest v))))
     (symbol? v)
     (m v)
     :else
     v)))
dzholev's solution:

1
2
3
4
5
6
(fn uce [[op & params]]
  (fn [m]
    (apply ({'+ + '- - '* * '/ /} op) (map #(cond
                                             (seq? %) ((uce %) m)
                                             (symbol? %) (m %)
                                             :else %) params))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
partial (fn rec-eval [ expr bind-map ]
        (cond 
            (symbol? expr) 
                (do
                    ;(println ";; symbol " (str expr) " = " (bind-map expr))
                    (bind-map expr) ; get value from map
                    )
            (sequential? expr)
                (let [[op & exprs] expr
                      rs (map #(rec-eval %1 bind-map) exprs)
                      rop (cond
                            (= '/ op) /
                            (= '* op) *
                            (= '+ op) +
                            (= '- op) -)
                    ]
                    ;(println ";; sequence " (str expr) "=> " (str op) " " (map #(str " " %) rs) " = " (apply rop rs))
                    (apply rop rs))
            :else expr ))
ericw's solution:

1
2
3
4
5
6
7
(letfn [                                                                                                                                                
    (op-table [c] ({'/ / '* * '+ + '- -} c))                                                                                    
    (calc ([formula table]                                                                                                                                      (if (coll? formula)                                                                                                     
            (let [[op & args] formula] (apply (op-table op) (map #(calc % table) args)))                                                                
            (get table formula formula))))                                                                                      
    (make-calc [formula] (fn [table] (calc formula table)))]                                                                                            
            make-calc)
featalion's solution:

1
2
3
4
5
6
7
8
9
10
(letfn [(calc
         [args f]
         (if (seq? f)
           (let [[op & vs] f]
             (apply ({'+ + '/ / '- - '* *} op)
                    (map (partial calc args) vs)))
           (get args f f)))]
  (fn [f]
    (fn [args]
      (calc args f))))
finsternis's solution:

1
2
3
4
5
6
7
8
(fn [f]
  (letfn [(ev [e m]
              (cond
               (number? e) e
               (symbol? e) (m e)
               :else (apply ({'+ + '- - '* * '/ /} (first e))
                            (map #(ev % m) (rest e)))))]
    (fn [m] (ev f m))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
(fn uce [f]
  (fn [m]
    (clojure.walk/postwalk 
      (fn [s] 
        (if (list? s)
          (apply 
            ((first s) {'+ + '- - '/ / '* *})
            (map #(if (symbol? %) (% m) %) (rest s)))
          s))
      f)))
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [form]
  (letfn [(step [s]
            (let [formulars (re-seq #"\([^\(\)]*\)" s)]
              (if (seq formulars)
                (let [formulars-results (map
                                          (fn [formular]
                                            (let [formular-seq (re-seq #"[\+\-\*/0-9]+" formular)]
                                              (apply
                                                (case (first formular-seq)
                                                  "+" +
                                                  "-" -
                                                  "*" *
                                                  "/" /)
                                                (map #(Integer/parseInt %) (rest formular-seq)))
                                              ))
                                          formulars)]
                  (step (reduce #(.replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))
                (Integer/parseInt s))))]
    (fn [m]
      (let [form-str (str form)]
        (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))
geekerzp's solution:

1
2
3
4
5
6
(fn [s]
    (fn [m]
      (letfn [(calc [[op & args]]
                (apply ({'+ + '- - '* * '/ /} op)
                       (map #(if (coll? %) (calc %) (m % %)) args)))]
        (calc s))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn ucomp [expr]
    (let [opmap {'+ + '- - '* * '/ /}
          operate 
            (fn [fop foperands]
                (let [foperjuxt (apply juxt foperands)]
                    (fn [env] (apply fop (foperjuxt env)))
                ))
          compile 
            (fn compile [[op & operands]]
                (let [compfoper
                        (fn [operand]
                            (cond
                                (sequential? operand) (compile operand)
                                (symbol? operand) (fn [env] (get env operand))
                                :else (constantly operand)
                            ))]
                (operate (opmap op) (map compfoper operands))))
        ]
        (compile expr)
    ))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn uce [formula]
  (fn [arg]
    (let [m (clojure.walk/prewalk-replace arg formula)
                myeval (fn myeval [l]
              (if (coll? l)
              (condp = (first l)
                '* (apply * (myeval (rest l)))
                '/ (apply / (myeval (rest l)))
                '+ (apply + (myeval (rest l)))
                '- (apply - (myeval (rest l)))
                 (map myeval l))
                l))]
    (myeval m))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
;; 4clojure says no to eval, otherwise I had this cute
;; solution:
;(fn [form]
;  (fn [syms]
;    (eval 
;     `(let ~(vec (apply interleave ((juxt keys vals) syms)))
;        ~form))))
 
(fn [form]
  (fn [syms]
    ((fn eval' [a]
       (println a (coll? a) (symbol? a))
       (if (coll? a)
         (let [[op & args] a]
           (apply ({'+ + '- - '/ / '* *} op)
                  (map eval' args)))
         (if (symbol? a) (syms a) a)))
     form)))
happycrisis's solution:

1
2
3
4
5
6
(fn [sexp] (let [ops {'+ + '- - '* * '/ /}]
             (fn [tbl]
               (letfn [(evl [[op & args]]
                         (apply (ops op)
                                (map #(if (coll? %) (evl %) (tbl % %)) args)))]
                 (evl sexp)))))
hisba's solution:

1
2
3
4
5
6
7
(fn [formula]
  (fn [m]
    ((fn calc [[o & opr]]
       (apply ({'/ / '- - '+ + '* *} o)
        (map #(if (coll? %) (calc %) (get m % %)) opr)
        ))
     formula)))
icamts's solution:

1
2
3
4
5
6
(fn [op]
  (fn calc ([m] (calc m op))
    ([m expr] (let [om (merge {'+ + '- - '* * '/ /} m)
                   [o & as] (replace om expr)]
               (cond (not-any? seq? as) (apply o as)
                     :else (apply o (map #(if (seq? %) (calc m %) %) as)))))))
immo's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s] 
  (fn [m] 
    (let [o {'/ / '* * '+ + '- -}
          _   (fn f [x]
                (if (seq? x)
                  (apply 
                    (o (first x))
                    (map f (rest x)))
                  (m x x)))]
      (_ s))))
jarlax's solution:

1
2
3
4
5
6
7
8
(fn [op]
  (fn [par]
    (let [ops {'+ + '- - '* * '/ /}
          v (fn ! [expr]
                (if (coll? expr)
                  (apply (ops (first expr)) (map ! (rest expr)))
                  (par expr expr)))]      
      (v op))))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn uce [coll]
   (fn [m]
    (letfn [(mval [x] (if (nil? (get m x)) x (get m x)))
                (get-symbol [s] (cond (= (symbol "+") s) +
                                      (= (symbol "/") s) /
                                      (= (symbol "*") s) *
                                      :else -)
                )
                (applier [[f & args]]
                    (apply (get-symbol f) (for [a args] (if (coll? a) (applier a) (mval a))))
                )]
        (applier coll)
        )
   )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
(fn [exprs]
  (fn [var-map]
    (let [exprs (clojure.walk/postwalk-replace var-map exprs)
          ev (fn ev [expr]
               (let [[op & es] expr
                     es (map #(if (list? %) (ev %) %) es)]
                 (apply ({'+ +, '- -, '* *, '/ /} op) es)))]
      (ev exprs))))
johncowie's solution:

1
2
3
4
5
6
7
(fn [s]
  (letfn ([f [c m]
           (let [o {'/ / '* * '+ + '- -}]
             (cond (coll? c)  (apply (get o (first c)) (map #(f % m) (rest c)) )
                   (symbol? c) (get m c)
                   :else c))])
    (fn [m] (f s m))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn f [form]
  (fn [m]
    (letfn [(evaluate 
              [form]
              (cond
                (number? form) form
                (list? form)        
                (let [op (first form)]
                  (cond
                    (= op '/) (apply / (map evaluate (next form))) 
                    (= op '*) (apply * (map evaluate (next form)))
                    (= op '+) (apply + (map evaluate (next form)))
                    (= op '-) (apply - (map evaluate (next form)))))
                :else
                (m form)))]
      (evaluate form))))
jorendorff's solution:

1
2
3
4
5
6
7
(fn evol [x]
  (fn [env]
    (cond
      (list? x) (let [fn-table {'+ + '- - '* * '/ /}]
                  (apply (fn-table (first x)) (map #((evol %) env) (rest x))))
      (symbol? x) (env x)
      :else x)))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn gen [form]
  (fn myfunc [m]
    (let [f (fn inter [form]
      (let [vals (into {} m)]
        (if (list? form)
          (let [evals (map inter (rest form))]
            (cond
              (= (first form) '/) (apply / evals)
              (= (first form) '+) (apply + evals)
              (= (first form) '-) (apply - evals)
              (= (first form) '*) (apply * evals)
              ))
          (if (contains? vals form) (get vals form) form)
          )))]
      (f form)
    )))
kohyama's solution:

1
2
3
4
5
6
(fn [s]
  (fn [m]
    ((fn ev [[f & args]]
       (apply ({'/ / '+ + '* * '- -} f)
              (map #(if (coll? %) (ev %) (m % %)) args)))
     s)))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn universal-Computation-Engine [expr]
  (fn [ar-map]
    (letfn [(rpl [a e] 
              (map 
               (fn [x] 
                 (if (coll? x) (rpl a x)
                     (let [v (a x)]
                       (if (nil? v) x v)))) 
               e))
 
            (evalate [e] (apply (first e)
                                (map  
                                 
                                 #(if (coll? %) (evalate %) %)
                                 
                                 (rest e))))]
      
      (evalate (rpl (assoc ar-map '/ / '+ + '* * '- -  ) expr))
 
      )))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn prob121
  [function]
  (fn [values]
    ;; apply the values to the function
    ((fn compute [s] 
       (if (seq? s)
         (let [[ op & args] s
               ;;  four basic mathematical operators
               fncs {'+ + '- - '/ / '* *}
               function (fncs op)]
           (apply function (map compute args)))
         (get values s s)))
     function)))
brendan's solution:

1
2
3
4
5
6
7
8
; Evil hack
(fn [& _]
  (reify nil
    clojure.lang.IPersistentCollection
    (seq [_])
    (cons [_ _])
    (empty [_])
    (equiv [_ _] true)))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
(fn my-universal-computation-engine
  [formula]
  (fn [values]
    (let [argsAndFunctions (merge values {'+ + '- - '* * '/ /})]
      (letfn [(calculate-function [function]
                                  (if (seq? function)
                                    (let [[operator & args] function]
                                      (apply (argsAndFunctions operator) (map calculate-function args)))
                                    (get argsAndFunctions function function)))]
         (calculate-function formula)))))
lackita's solution:

1
2
3
4
5
6
7
8
9
(fn [expression]
  (fn [vars]
     ((fn evl [e]
        (apply ({'/ / '+ + '- - '* *} (first e)) 
               (map #(if (coll? %)
                       (evl %)
                       (or (vars %) %))
                    (rest e))))
      expression)))
lambda4fun's solution:

1
2
3
4
5
6
7
8
(fn solve [exp]
  (fn [vars]
    (let [op ((first exp) {'+ + '- - '* * '/ /})
          xs (->> (rest exp)
                  (map #(if (coll? %)
                          ((solve %) vars)
                          (vars % %))))]
      (apply op xs))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn compute [expr]
  (fn [vs]
    (apply ({'+ +, '- -, '* *, '/ /} (first expr))
           (map
            #(cond
              (coll? %) ((compute %) vs)
              (vs %) (vs %)
              :else %
              )
            (rest expr)
            ))
    )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
(let [opmap {'+ + '- - '* * '/ /}
      m (fn m [e vs]
          (cond
            (symbol? e) (vs e)
            (not (coll? e)) e
 
            (opmap (first e))
            (apply (opmap (first e)) (map #(m % vs) (rest e)))))]
  (fn f [e] (fn [vs] (m e vs))))
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn cnt [f-la]
  (fn [a]
    (let [
      args 
        (merge a {'+ + '- - '* * '/ /}) 
      new-f-la 
        (map 
          #(cond
            (number? %) %
            (seq? %) ((cnt %) args)
            :else (args %)) f-la)]
        (apply (first new-f-la) (rest new-f-la)))))
littlejp2046's solution:

1
2
3
4
5
(fn f [op] (fn [mp]
  (cond
   (number? op) op
   (symbol? op) (get mp op)
   :else (apply (get {'+ + '* * '/ / '- -} (first op)) (map #((f %) mp) (rest op))))))
malvert's solution:

1
2
3
4
5
6
7
8
9
(letfn [(e [x v] 
  (cond 
    (list? x)
    (apply 
      ({'/ / '* * '+ + '- -} (first x)) 
      (map #(e % v) (rest x)))
    (number? x) x
    1 (v x)))]
  #(partial e %))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn f [e]
  (let [ops {'+ +
             '- -
             '/ /
             '* *}
        [s & args] e]
    (fn [m]
      (let [g (fn [a]
                (cond
                  (symbol? a) (m a)
                  (seq? a) ((f a) m)
                  :else a))]
        (apply (ops s) (map g args))))))
maximental's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(let [y (fn [f]
          ((fn [u] (u u))
             (fn [u] (f (fn [v] ((u u) v))))))
      m {'+ + '- - '* * '/ /}]
  (fn [e] 
    (fn [b]
      ((y (fn [c]  
            (fn [x]
              (if (seq? x)
                (let [[h & t] x] 
                  (apply (m h) (map c t)))
                (b x x))))) 
         e))))
mbakhterev's solution:

1
(fn R [E] (fn [M] (cond (seq? E) (let [[f & X] E O {'/ / '+ + '* * '- -}] (apply (O f) (map #((R %) M) X))) (symbol? E) (M E) :else E)))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
(let [;; If this function is given a valid formula, it will return the set of
        ;; free variables in that formula. Otherwise it returns nil.
        check-formula
        (fn check-formula [f]
          (cond
            (number? f)                    #{}
            (symbol? f)                    (hash-set f)
            (not (sequential? f))          nil
            (not ('#{+ - * /} (first f)))  nil
 
            ;; Once we've dealt with the above special cases, we have to
            ;; recur. We can't just take the union of (map check-formula (rest
            ;; f)), because this will discard nil results, and we need those to
            ;; bubble up to signal an invalid formula. In the following code, we
            ;; obtain this by using keep rather than map, then count to see if
            ;; we discarded any nil results.
            :else (let [arg-check (keep check-formula (rest f))]
                    (if (= (count (rest f)) (count arg-check))
                      (apply clojure.set/union arg-check)))))
 
        ;; This function takes a map associating symbols to numbers and a
        ;; formula f, and returns the new formula obtained by substituting (m x)
        ;; for each variable x appearing both as a key in m and as a variable in
        ;; f.
        substitute
        (fn substitute [m f]
          (cond
            (number? f)  f
            (symbol? f)  (if (contains? m f) (m f) f)
            :else        (map (partial substitute m) f)))
 
        ;; This function evaluates a valid formula with no free variables.
        eval-formula
        (fn eval-formula [f]
          (let [op-map {'+ +, '- -, '* *, '/ /}]
            (if (number? f)
              f
              (apply (op-map (first f))
                     (map eval-formula (rest f))))))]
 
    ;; If the map m passed to the result of this function does not contain a
    ;; value for every free variable in the formula f, then we still perform all
    ;; possible substitutions and return the resulting formula rather than
    ;; evaluating it.
    (fn formula-calculator [f]
      {:pre [(check-formula f)]}
      (fn [m]
        {:pre [(associative? m),
               (every? symbol? (keys m)),
               (every? number? (vals m))]}
        (let [new-formula (substitute m f)]
          (if (= #{} (check-formula new-formula))
            (eval-formula new-formula)
            new-formula)))))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [symbolic-expression]
  (fn [values-map]
    (let [
          ops-map {'+ + '- - '* * '/ /}
          substitute (fn [coll] (map #(get values-map % %) coll))
          evaluate (fn evaluate [expression]
                     (if (number? expression)
                       expression
                       (let [[op & args] (substitute expression)]
                         (apply (ops-map op) (map evaluate args)))))]
      (evaluate symbolic-expression))))
minitrue's solution:

1
2
3
4
5
6
7
8
9
10
(fn [code]
  (fn [m]
    (letfn [(exe [c]
              (cond
                (coll? c) (let [[op' & code] c
                                op ({'+ + '- - '* * '/ /} op')]
                            (apply op (map exe code)))
                (symbol? c) (m c)
                :else c))]
      (exe code))))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(fn calculator [s]
              (let [toyeval (fn f [c]
                              (if (seq? c)
                                (if (reduce #(or %1 %2) (map seq? c))
                                  (f (map f c))
                                  (if (= (first c) :add)
                                    (apply + (rest c))
                                    (if (= (first c) :subtract)
                                      (apply - (rest c))
                                      (if (= (first c) :divide)
                                        (apply / (rest c))
                                        (if (= (first c) :multiply)
                                          (apply * (rest c))
                                          nil)))))
                                                    c))
                    toyreader (fn g [n t]
                    (let [dictionary {'+ :add '- :subtract '/ :divide '* :multiply}]
                      (if (seq? t)
                        (if (reduce #(or %1 %2) (map seq? t))
                          (map (partial g n) t)
                          (loop [init (vec t) result '()]
                            (if (empty? init)
                              result
                              (if (nil? (get dictionary (peek init)))
                                (if (nil? (get n (peek init)))
                                  (recur (pop init) (cons (peek init) result))
                                  (recur (pop init) (cons (get n (peek init)) result)))
                                (recur (pop init) (cons (get dictionary (peek init)) result))))))
                        (if (nil? (get dictionary  t))
                          (if (nil? (get n t))
                            t
                            (get n t))
                          (get dictionary t))
                        )))]
                 (fn f [m]
                   (toyeval (toyreader m s)))))
mobiusloop's solution:

1
2
3
4
5
(fn m [s]
  (fn [v]
    ((fn x [[o & l]]
       (apply (o {'+ + '- - '/ / '* *}) (map #(cond (seq? %1) (x %1) :else (v %1 %1)) l))
       ) s)))
mononite's solution:

1
2
3
4
5
6
7
8
9
(fn [form]
  (fn [m]
    (let [m (merge m {'/ / '* * '+ + '- -})]
      (clojure.walk/postwalk 
        #(cond 
          (contains? m %) (% m)
          (list? %) (apply (first %) (rest %))
          :else %)
        form))))
mouse's solution:

1
2
3
4
5
partial
  (fn e [c v]
    (if (seq? c)
        (apply ({'+ + '- - '* * '/ /} (first c)) (map #(e % v) (rest c)))
        (v c c)))
mwaldowski's solution:

1
2
3
4
5
6
7
8
(fn uce [elist]
  (fn [params]
    (let [lookup #(cond (symbol? %) (get params %)
                        (list? %) ((uce %) params)
                        :else %)
          f      ((first elist) {'/ / '+ + '- - '* *})
          args   (rest elist)]
      (apply f (map lookup args)))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
(fn __
  ([formula]
       (fn [m] (__ formula m)))
  ([formula m]
   (let [ops (hash-map '+ + '- - '* * '/ /)
         op (ops (first formula))
         args (rest formula)]
     (letfn [(get-args [as m] (map #(get-arg % m) as))
             (get-arg [a m] (if (list? a) (__ a m) (get m a a)))]
       (apply op (get-args args m))))))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn calc
  ([form]
    (fn [vars] (calc form vars)))
  ([form vars]
    (cond (number? form) form
      (symbol? form) (vars form)
      :else (let [[op & args] form]
              (apply (cond
                       (= op '+) +
                       (= op '-) -
                       (= op '/) /
                       (= op '*) *)
                (map #(calc % vars) args))))))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
(fn gen [x]
    (fn [v] ((fn calc [x v]
                 (if (sequential? x)
                   (let [[f & args] x
                         f2 ({'+ + '- - '* * '/ /} f)]
                     (apply f2 (map #(calc % v) args)))
                   (if (symbol? x) 
                     (v x x)
                     x))) x v)))
norman's solution:

1
2
3
4
5
6
7
8
(fn [expr]
  (letfn [(find-op [op-symbol] ({'+ + '- - '* * '/ /} op-symbol))
          (realcalc [expr varmap]
            (cond
             (symbol? expr) (varmap expr)
             (number? expr) expr
             :else (apply (find-op (first expr)) (map #(realcalc % varmap) (rest expr)))))]
    (fn [varmap] (realcalc expr varmap))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
(fn [expr]
  (let [ops {'/ / '* * '+ + '- -}
        my-eval (fn my-eval [node vars]
                  (if (coll? node)
                    (let [[op & args] node
                          args (map #(my-eval % vars) args)
                          op-fn (ops op)]
                      (apply op-fn args))
                    (get vars node node)))]
    (fn [vars] (my-eval expr vars))))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [m]
  (fn [n]
    (letfn [(sub [m n] 
                (cond 
                    (empty? m) nil
                    (= '+ (first m)) (apply + (sub (rest m) n))
                    (= '/ (first m)) (apply / (sub (rest m) n))
                    (= '- (first m)) (apply - (sub (rest m) n))
                    (= '* (first m)) (apply * (sub (rest m) n))
                    (coll? (first m)) (cons (sub (first m) n) (sub (rest m) n))
                    (number? (first m)) (cons (first m) (sub (rest m) n))
                    :else (cons (second (find n (first m))) (sub (rest m) n))))]
      (sub m n))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(letfn [(i [e x]
          (cond
           (list? e)
           (apply ((apply hash-map (mapcat #(-> %
                                                str
                                                (clojure.string/split #"/" 2)
                                                (get 1)
                                                symbol
                                                (list %))
                                           [#'+ #'- #'* #'/]))
                   (first e))
                  (map (fn [c] (i c x)) (rest e)))
           (symbol? e) (x e)
           :else e))]
  (fn [f] (fn [x] (i f x))))
ozan's solution:

1
2
3
4
5
6
7
8
(fn uct [[op-sym & args]]
  (let [operator (get {'/ / '* * '+ + '- -} op-sym)]
    (fn [vars]
      (let [calculate (fn [exp]
                        (if (seq? exp) ((uct exp) vars)
                          (or (vars exp) exp)))]
        (apply operator (map calculate args)))
      )))
pukeface's solution:

1
2
3
4
5
(fn e [f] 
   (fn [b]
    (cond (list? f) (apply ({'+ + '* * '/ / '- -} (first f)) (map #((e %) b) (rest f)))
          (b f) (b f)
          :else f)))
quant1's solution:

1
2
3
4
5
6
7
8
(fn [expr]
  (letfn [(calc [expr ctx]
            (let [ops {'+ + '- - '* * '/ /}]
              (cond
                (coll? expr) (apply (ops (first expr)) (map #(calc % ctx) (rest expr)))
                (ctx expr) (ctx expr)
                :else expr)))]
    (fn [ctx] (calc expr ctx))))
rodmax's solution:

1
2
3
4
5
6
7
#(fn [m] (
     (fn f[e]
        (if (coll? e)
          (apply (case (first e) + + - - * * / /) (map f (rest e)))
          (m e e)
        ))
      %))
sbondaryev's solution:

1
2
3
4
5
6
7
8
(fn evl
  ([exp] (fn [env] (evl exp env))) 
  ([exp env]
   (let [rslv (fn[exp env] (get (merge {'+ + '- - '/ / '* *} env) exp exp))]
     (cond
       (symbol? exp) (rslv exp env)
       (list? exp) (apply (evl (first exp) env) (map #(evl % env) (rest exp)))
       :else exp))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn return-eval [l]
  (fn e-map [m]
    (letfn [(e-p [p]
              (cond
                (list? p) (e p)
                (number? p) p
                :else (m p)))
            (e [[op & args]]
              (let [e-args (map e-p args)]
                (cond
                  (= op '*) (apply * e-args)
                  (= op '+) (apply + e-args)
                  (= op '-) (apply - e-args)
                  (= op '/) (apply / e-args))))]
      (e l))))
sheldon's solution:

1
2
3
4
5
6
7
(fn [x] 
  (fn [y] 
    (let [m (zipmap '(+ - * /) [+ - * /]) 
          l #(if (symbol? %) (y %) %)] 
      (apply (fn f [o & a] 
        (apply (m o) 
          (map #(if (coll? %) (apply f %) (l %)) a))) x))))
silverio's solution:

1
2
3
4
5
6
7
#(fn [bnd]
   ((fn evl [expr]
      (cond
        (coll? expr) (apply ({'/ /, '+ +, '- -, '* *} (first expr)) (map evl (next expr)))
        (number? expr) expr
        :else (bnd expr)))
  %))
skyrem's solution:

1
2
3
4
5
6
7
(fn uce [formula]
  (fn [args]
    (let [[f & rs]
          (map #(if (coll? %) 
                  ((uce %) args)
                  (if (nil? (args %)) % (args %))) formula)]
      (apply  ({'/ / '+ + '- - '* *} f) rs))))
soul_awaker's solution:

1
2
3
4
5
6
7
(fn [f]
  (fn [s]
    ((fn g [[h & t]]
      (let [op {'+ +, '- -, '* *, '/ /}
            [c l] ((juxt filter remove) coll? t)]
        (apply (op h)
          (concat (map #(get s % %) l) (map g c))))) f)))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
(let [pattern #"\(([^()]+)\)"]
(letfn
[
(eval-op [x [op & xs]] 
  (str
    (apply ({"+" +
             "-" -
             "*" *
             "/" /} op)
      (map #(or (x (str %)) (Integer. %)) xs))))
(eval-inner [s x]
  (clojure.string/replace 
    (str s)
    pattern
    (fn [xs]
      (eval-op
        x
        (clojure.string/split
          (second xs)
          #" ")))
    ))
  (itus [s f]   ; iterate until same
    (loop [s s]
      (let [s1 (f s)]
        (if (= s s1) s1 (recur s1)))))
  (stm [s] ; symbol to map
    (let [s (str s)
          s (subs s 1 (dec (count s)))
          s (clojure.string/replace s #"," "")]
      (into {} (map (fn [[x y]] [x (Integer. y)]) (partition 2 (clojure.string/split s #" "))))
    ))]
  (fn [s] (fn [x] (Integer. (itus s #(eval-inner % (stm x))))))
  ))
syeerzy's solution:

1
2
3
4
5
6
7
8
9
(fn calc [expr]
  (let [ops {'+ + '- - '* * '/ /}]
    (letfn [(solve [expr bindings] 
                   (cond
                     (coll? expr) (apply (ops (first expr))
                                         (map #(solve % bindings) (rest expr)))
                     (symbol? expr) (bindings expr)
                     (number? expr) expr))]
      (fn [bindings] (solve expr bindings)))))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
(fn [form]
  (fn [bindings]
    (let [bindings (into {'+ + '- - '* * '/ /} bindings)]
      (letfn [(resolve' [form] (cond
                                 (seq? form) (eval' form)
                                 (symbol? form) (get bindings form)
                                 :else form))
              (eval' [[op & args]]
                (reduce (resolve' op) (map resolve' args)))]
        (resolve' form)))))
thegeez's solution:

1
2
3
4
5
6
(fn [expr]
    (fn [bs]
      ((fn u [e]
         (if (seq? e)
           (apply ({'+ + '- - '/ / '* *} (first e)) (map u (rest e)))
           (bs e e))) expr)))
zzamboni's solution:

1
2
3
(fn ucc [form]
  (fn [args] (clojure.walk/postwalk #(if (seq? %) (apply ({'+ + '- - '/ / '* *} (first %)) (rest %)) %)
                                    (clojure.walk/postwalk-replace args form))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn __ [x]
  (fn f [m]
    (letfn [(e [x]
               (if (coll? x)
                 (case (first x)
                   + (apply + (map e (rest x)))
                   - (apply - (map e (rest x)))
                   * (apply * (map e (rest x)))
                   / (apply / (map e (rest x)))
                   nil)
                 (let [y (get m x)]
                   (if (nil? y) x
                     y))))]
      (e x))))
zipzop's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn
  [e]
  (fn [vars]
    (letfn [(myeval [x]
              (cond
                (list? x) (apply (myeval (first x)) (vec (map myeval (rest x))))
                (symbol? x) (cond
                             (= x '*) *
                             (= x '+) +
                             (= x '/) /
                             (= x '-) -
                             :else (vars x))
                (number? x) x))]
      (myeval e))))
yusubori's solution:

1
2
3
4
5
6
(fn [s]
  (fn [m]
    (let [calc (fn calc [[op & args]]
                 (apply ({'+ + '- - '* * '/ /} op)
                        (map #(if (coll? %) (calc %) (m % %)) args)))]
      (calc s))))
ydash's solution:

1
2
3
4
5
(fn [a]
  #((fn aux [x]
      (if (seq? x)
        (apply ({'+ + '- - '* * '/ /} (first x)) (map aux (rest x)))
        (% x x))) a))
vpeurala's solution:

1
2
3
4
5
(fn [tree] (letfn [
(operator [sym] (get {'+ + '- - '* * '/ /} sym))
(tree-reduce [branch? child? leaf-reduce tree] (if (branch? tree) (leaf-reduce (map #(if (child? %) (tree-reduce branch? child? leaf-reduce %) %) tree)) (leaf-reduce tree)))
(calculate-formula-value [tree] (fn [argmap] (tree-reduce #(some sequential? %) sequential? #(apply (operator (first %)) (replace argmap (rest %))) tree)))
] (calculate-formula-value tree)))
v_bogdanov's solution:

1
2
3
4
5
6
(fn g [[f & p]]
  #(apply ({'- - '+ + '* * '/ /} f)
          (for [a p]
             (cond (symbol? a) (% a)
                   (seq? a) ((g a) %)
                   1 a))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [l]
    (fn [m]
      (let [schema {'+ + '- - '* * '/ /}]
        (letfn [(fff [v]
                     (apply (schema (first v))
                            (map #(if (coll? %)
                                    (fff %)
                                    (if (some #{%} (keys m))
                                      (get m %)
                                      %))
                                 (rest v))))]
          (fff l)))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
(fn [form]
  (fn [values]
    (let [env (merge {'+ + '- - '* * '/ /} values)]
      ((fn eval- [f]
         (if (seq? f)
           (let [[op & args] f]
             (apply (env op) (map eval- args)))
           (get env f f)))
         form))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn chomp [exp]
  (fn [valmap]
    (let [  op (first exp)
          args (rest  exp)
          opsmap {'+ + '- - '* * '/ /}]
      (apply (get opsmap op)
             (for [arg args]
               (cond
                   (seq? arg) ((chomp arg) valmap)
                (number? arg) arg
                        :else (get valmap arg)))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)