;; 112 Sequs Horribilis [m]

Takes an int and a nested coll of ints
Returns a seq which maintains the nested structure,
and which includes all elements starting from the head
whose sum is less than or equal to the input integer.

(=  (__ 10 [1 2 [3 [4 5] 6] 7])
   '(1 2 (3 (4))))
(=  (__ 30 [1 2 [3 [4 [5 [6 [7 8]] 9]] 10] 11])
   '(1 2 (3 (4 (5 (6 (7)))))))
(=  (__ 9 (range))
   '(0 1 2 3))
(=  (__ 1 [[[[[1]]]]])
   '(((((1))))))
(=  (__ 0 [1 2 [3 [4 5] 6] 7])
   '())
(=  (__ 0 [0 0 [0 [0]]])
   '(0 0 (0 (0))))
(=  (__ 1 [-10 [1 [2 3 [4 5 [6 7 [8]]]]]])
   '(-10 (1 (2 3 (4)))))

(fn [n s]
  (second ((fn sequs [n s]
    (loop [cnt 0 acc [] [x & xs] s]
      (cond (or (nil? x) (< n cnt)) [cnt acc]
        (coll? x) (let [[c r] (sequs (- n cnt) x)
                     coll (if (empty? r) acc (conj acc r))]
                    (recur (+ c cnt) coll xs))
         :else (recur (+ x cnt) (if (< n (+ cnt x))
                                  acc (conj acc x)) xs)))) 
    n s)))

(fn ff [sum [h & tail :as col]]
    (cond (or (empty? col)
              (and (integer? h) (< (- sum h) 0))) ()
          (sequential? h) (let [x (ff sum h)]
                            (cons x (ff (- sum (apply + (flatten x))) tail)))
          :else (cons h (ff (- sum h) tail))))

(fn [n l]
  (first
    ((fn sequs-horribilis
       [n [x & xs]]
       (cond
         (nil? x) [x n]
         (coll? x) (let [[y m] (sequs-horribilis n x)
                         [z l] (sequs-horribilis m xs)]
                     [(cons y z) l])
         :else    (if (<= x n)
                    (let [[y m] (sequs-horribilis (- n x) xs)]
                      [(cons x y) m])
                    ['() n]))) n l)))

#(letfn [(sequs [bound coll]
           (loop [result [0 []] remaining coll
;initially sum is zero and structure is empty
             (if-let [item (first remaining)]
               (if (coll? item)
                 (let [[subSum subSeq]
                       (sequs (- bound (first result)) item)]
;if one item is a coll, compute then sum from that coll
                   (recur [(+ (first result)
                               subSum)
                           (conj (second result) subSeq)]
;and go onto the next item
                     (rest remaining)))
                 (if (> (+ item (first result)) bound)
                   result
;if sum exceeds the bound then return
                   (recur [(+ item (first result))
                           (conj (second result) item)]
;else continue the loop
                     (rest remaining))))
               result)))]
  (second (sequs %1 %2)))

(fn f [n xs]
  (letfn [(step [n xs sum]
    (reduce
      (fn [[s r] i]
        (if (coll? i)
          (let [sr (step n i s)]
            (if (= [] (last sr))
              [s r]
              [(first sr) (conj r (last sr))]))
          (if (> (+ s i) n)
            [s r]
            [(+ s i) (conj r i)]))) [sum []] xs))]
  (last (step n (take 100 xs) 0))))
aceeca1's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(letfn [
    (horribili [x t] (cond 
        (number? t) (cond 
            (>= x t) [(- x t) [t]] 
            true     [nil []])
        (empty? t)  [x [[]]]
        true        (let 
            [[xf tf] (horribili x (first t))]
            (cond 
                (nil? xf) [nil [tf]] 
                true      (let 
                    [[xn tn] (horribili xf (rest t))]
                    [xn [(concat tf (first tn))]])))))]
    (comp first second horribili))
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [n s]
  (let [b (fn b [v]
              (let [l (last v)]
                (if (vector? l)
                  (if (= (count l) 1)
                    (apply vector (butlast v))
                    (conj (apply vector (butlast v)) (b l)))
                  (apply vector (butlast v)))))
        t (fn s [v] (reduce + (map #(if (vector? %)
                                       (s %) %) v)))
        ]
    (loop [s (take 100 s)]
      (if (< n (t s))
        (recur (b s))
        s))
    ))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn horribilisX[m x]
    (letfn [
        (horribilisRec [m x sum]
            (if (empty? x)
                x
                (let [n (first x)]
                    (if (number? n)
                        (let [newSum (+ sum n)]
                            (if (<=  newSum m)
                                (cons n (horribilisRec m (rest x) newSum))
                                (list)
                            )
                        )
                        (list (horribilisRec m n sum))
                    )
                )
            )    
        )
 
        ]
        (horribilisRec m x 0)
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
(fn [limit tree]
  (second
  ((fn iter [limit tree]
     (loop [l limit
            t tree
            result []]
       (if
         (empty? t)
         [l result]
         (let [[t-head & t-tail] t]
           (if
             (coll? t-head)
             (let [[new-l t-head-processed] (iter l t-head)
                   new-result (if
                                (empty? t-head-processed)
                                result
                                (conj result t-head-processed))]
               (recur 
                 new-l
                 t-tail
                 new-result))
             (let [new-l (- l t-head)]
               (if 
                 (< new-l 0)
                 (recur 
                   new-l
                   []
                   result)
                 (recur
                   new-l
                   t-tail
                   (conj result t-head)))))))))
   limit tree)))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
(fn [n a]
  (letfn [(next-thing [cnt b]
            (loop [ct cnt res [] leftover b]
              (let [head (first leftover)]
                (cond
                  (= head nil) res
                  (coll? head) (conj res (next-thing ct head))
                  (> (+ ct head) n) res
                  :else (recur (+ ct head) (conj res head) (rest leftover))))))]
    (next-thing 0 a)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn tree-replace [n root]
  (->>
   ((fn tree-replace' [sum n root]
      (if (= sum :done)
        (do #_(println "early exiting!")
            [sum root])
        (cond (nil? root) nil
              (coll? root) (loop [sum' sum
                                  root' ()
                                  [child & next-children] root]
                             #_(println "loop:" sum' root' child)
                             (if child
                               (let [[sum'' child'] (tree-replace' sum' n child)]
                                 #_(println "sum''=" sum'')
                                 (if (and (not= sum'' :done)
                                          (<= sum'' n))
                                   (recur sum'' (concat root' child') next-children)
                                   (do #_(println "exiting!!") [sum' [root']])))
                               (do #_(println "exiting") [sum' [root']])))
              :otherwise (let [sum' (+ sum root)]
                           (if (> sum' n)
                             (do #_(println "otherwise - done!")
                                 [:done []])
                             [sum' [root]])))))
    0 n root)
   second
   first))
andthorn's solution:

1
2
3
4
5
6
7
8
9
10
(fn f [n l]
  (if (empty? l)
    '()
    (if (coll? (first l))
      (let [ret (f n (first l))
            sum (reduce (fn g [r e] (if (coll? e) (+ r (reduce g 0 e)) (+ r e) )) 0 ret)]
        (cons ret (f (- n sum) (next l))))
      (if (neg? (- n (first l)))
        '()
        (cons (first l) (f (- n (first l)) (next l)))))))
anjensan's solution:

1
2
3
4
5
6
7
8
9
10
(fn [x t]
  (or
    ((fn f [x t]
       (if (sequential? t)
         (when-first [a t]
           (when-let [g (f x a)]      
          (cons g (f (- x (reduce + (flatten [a]))) (rest t)))))
         (when (<= t x) t)))
      x t)
    []))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn
  [n coll]
  (letfn [(r [residue a coll]
            (if (nil? residue)
              [residue a]
              (if (seq coll)
                (let [h (first coll)
                      t (rest coll)]
                  (if (coll? h)
                    (let [[residue' coll] (r residue [] h)]
                      (recur residue' (conj a coll) t))
                    (if (<= h residue)
                      (recur (- residue h) (conj a h) t)
                      (recur nil a t))))
                [residue a])))]
    (let [[_ coll'] (r n [] coll)]
      coll')))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [n s]
  (letfn [(op [n s]
    (cond (empty? s) '()
          (sequential? (first s))
            (let [it (op n (first s))]
              (if (= it (first s))
                (cons it (op (- n (reduce + (flatten s))) (rest s)))
                (list it)))
          (> (first s) n) '()
          true (cons (first s)
                  (op (- n (first s)) (rest s)))))]
    (op n s)))
awebb's solution:

1
2
3
4
5
6
(fn [n e]
   (let [c (atom n)]
     (clojure.walk/postwalk 
       (fn [x] (cond 
         (coll? x) (remove #(or (nil? %) (and (seq? %) (empty? %)))  x)
         (number? x) (when (<= 0 (swap! c  - x)) x))) (take 42 e))))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [n tree]
  (letfn
    [(process-row [n [head & tail] subrow]
      (let [[newn elem] (if (coll? head) 
                            (process-row n head [])
                            [(- n head) head])]
        (cond
          (> 0 newn) [n subrow]
          (empty? tail) [newn (conj subrow elem)]
          :else (process-row newn tail (conj subrow elem)))))]         
    (second (process-row n tree []))))
benhammond's solution:

1
2
3
4
5
6
(fn [& rgs]
    (let [zh (fn zh [acc o [s & ss]]
               (cond (nil? s) [acc o]
                     (number? s) (if (<= s o) (zh (conj acc s) (- o s) ss) [acc 0])
                     (coll? s) (let [[acc2 o2] (zh [] o s)] (zh (conj acc acc2) o2 ss))))]
      (first (apply zh [] rgs))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn horribilis [target s]
  (last (take-while #(<= (-> % meta :sum) target)
                    (reductions
                     (fn [sq el]
                       (let [sum (-> sq meta :sum)]
                         (if (sequential? el)
                           (let [ss (horribilis (- target sum) el)]
                             (with-meta (conj sq ss) {:sum (+ sum (-> ss meta :sum))}))
                           (with-meta (conj sq el) {:sum (+ sum el)}))))
                     (with-meta [] {:sum 0})
                     s))))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [max-sum coll]
(letfn [(step [coll current-sum max-sum]
(if (seq coll)
(let [head (first coll)]
(if (coll? head)
(let [sub (step head current-sum max-sum)
next-sum (+ current-sum (reduce + (flatten sub)))]
(if (<= next-sum max-sum)
(cons sub (step (next coll) next-sum max-sum))
sub))
(let [next-sum (+ head current-sum)]
(if (<= next-sum max-sum)
(cons head (step (next coll) next-sum max-sum))
[]))))))]
(step coll 0 max-sum)))
burner's solution:

1
2
3
4
5
6
7
8
9
10
11
(letfn [(update [n s]
                 (if (sequential? s)
                   (if (empty? s)
                     [n s]
                     (let [[n f] (update n (first s))]
                       (if (>= n 0) 
                         (let [[n r] (update n (rest s))]
                           [n (cons f r)])
                         [n (if (sequential? f) [f] [])])))
                   [(- n s) s]))]
         (fn [n s] (second (update n s))))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
#(let [rRemove (fn recursiveRemove[inputVec sum bound]
                 (if (> sum bound) [sum []];just return an empty vector if the accumulated sum exceeds the bound
                   (loop [v inputVec s sum r []]
                     (if (seq v)
                       (let [fv (first v)]
                         (if (coll? fv)
                           (let [[ss sr] (recursiveRemove fv s bound)]
                             (recur (rest v) (+ s ss) (conj r sr)))
                           (if (<= (+ s fv) bound)
                             (recur (rest v) (+ s fv) (conj r fv))
                             [s r])))
                       [s r]))))
       [s r] (rRemove %2 0 %1)]
   r)
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn [floor xs]
   (second
    ((fn f [start xs]
       (cond (and (coll? xs) (empty? xs)) [start nil]
             (coll? xs)
             (loop [xs xs
                    result []
                    start start]
               (if (empty? xs)
                 [start result]
                 (let [ff (f start (first xs))]
                   (cond
                     (#(or (and (coll? %) (empty? %))
                           (nil? %)) (second ff)) [(first ff) result]
                     (> (first ff) floor)
                     [(first ff) (conj result (second ff))]
                     :else (recur (rest xs)
                                  (conj result (second ff))
                                  (first ff)))
                   ))
               )
             (> (+ start xs) floor) [(+ start xs) nil]
             :else [(+ start xs) xs]
             ))
     0 xs))
   )
chunchangshao's solution:

1
(fn [s xs] ((fn a [xs n] (loop [xs xs h (first xs) res [],n n] (if h (if (sequential? h) (conj res (a h n)) (if (>= s (+ n h)) (recur (next xs) (second xs) (conj res h) (+ n h)) res)) res))) xs 0))
ctzsm's solution:

1
2
3
4
5
6
(fn d [n [h & t]]
   (cond
    (nil? h) []
    (coll? h)  [(d n h)]
    (>= n h) (concat [h] (d (- n h) t))
    :else []))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn sequs [n xs]
  (lazy-seq
   (when-let [[x & xs] (seq xs)]
     (if (number? x)
       (when (>= n x)
         (cons x (sequs (- n x) xs)))
       (let [h (sequs n x)
             n (->> (flatten h)
                    (apply +)
                    (- n))]
         (cons h (sequs n xs)))))))
daniels's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [l x]
  ((fn f [i s]
     (if (number? (first i))                   
       (if (<= (+ (first i) s) l)
         (cons (first i) (f (rest i) (+ (first i) s)))
         '())                   
       (if (nil? (first i))
         '()
         [(f (first i) s)])))
   x 0))
 
;; this would fail for the first testcase if we were to count to 21
daowen's solution:

1
2
3
4
5
6
(fn horrible [x node]
  (if-let [h (first node)]
    (cond
      (coll? h) (if-let [t (horrible x h)] (list t))
      (<= h x) (cons h (horrible (- x h) (rest node)))
      :else '())))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [n colls]
     (let [_myfn 
          (fn myfn  [n sum colls]
      (let [e (first colls)]
        (if (sequential? e)
           [(myfn n sum e)]
         (let [sum (+ sum e)] (if (> sum n) '()
            (if (empty? (rest colls)) colls
              (cons e (lazy-seq (myfn n sum (rest colls))) ))
            )
         ))
        )
      )
       ] 
       (_myfn n 0 colls)
      )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
(fn [n l]
  (letfn 
    ; give a tree, find total number of each node 
    [(lagua 
      [tree] 
      (if (not (sequential? tree)) [tree tree]
        (let [mp (map lagua tree)
              tot (reduce + (map second mp))]
          [mp tot])
        ))
     
     ; get list prefix so that the tot does not exceed the tot
     (subtree 
      [tree tot]
      (loop [curt tree
             curtot tot
             acc []]
        (if (or (empty? curt) (< curtot 0)) acc
          (let [lg (lagua (first curt))]
            (recur (rest curt) (- curtot (second lg)) (concat acc [(first curt)]))
            ))))
     
     ; positions of set pred in coll
     (positions
     [pred coll]
     (keep-indexed (fn [idx x]
                  (when (pred x)
                    idx))
                coll))
     
     ; give a numbered list and remaining, return the first x elements that adds up to >= remaining
     ; each element has its quota (last is not full, before that it's the total)
     (pucho 
      [treex tot]
      (let [len  (count treex)
            tots (map second treex)
            sums (reverse (map #(reduce + (drop-last % tots)) (range len)))
            nquota (map - (repeat len tot) sums)
            quota (concat [tot] (drop-last nquota)) 
            adjq (map min tots quota) 
            ok   (map #(or %1 %2) (map #(> % 0) adjq) (map #(>= % 0) nquota))
            posq (positions #{true} ok)
            cutn (if (empty? posq) -1 (apply max posq))]
        (if (< cutn 0) [-1 nil]
          (let [nquot (nth adjq cutn)
                nele (first (nth treex cutn))
                ncutn (if (and (not (sequential? nele)) (< nquot nele)) (dec cutn) cutn)]
            [ncutn (nth adjq ncutn)]))
            ))
 
     ; give a numbered tree (puhcoed), give the results)     
     (guagua 
      [tree ltree quota]
      (if (not (sequential? tree)) tree
        (let [x (pucho ltree quota)
              cutn (first x)
              lq (second x)]
          (if (< cutn 0) []
            (let [qnode (nth tree cutn)]
              (concat (take cutn tree) 
                      [(guagua qnode (first (lagua qnode)) lq)])
              ))
          )))]  
    
    (let [stree (subtree l n)]    
      (guagua stree (first (lagua stree)) n)
      )))
devm33's solution:

1
2
3
4
5
6
7
(fn __ [m xs]
  (loop [sum 0 s (seq xs) r []]
    (if (empty? s) r
      (let [f (first s) fret (if (coll? f) (__ (- m sum) f) f)
            fval (if (coll? fret) (reduce + (flatten fret)) fret)]
        (if (> (+ fval sum) m) r
          (recur (+ fval sum) (next s) (conj r fret)))))))
dwelte's solution:

1
2
3
4
5
6
7
8
9
(fn [v xs]
(second ((fn g [v xs]
  (if (empty? xs)
    [v '()]
    (let [[x & rxs] xs]
      (cond 
        (coll? x) (let [[nv nx] (g v x)] (if nv (let [[mv mxs] (g nv rxs)] [mv (cons nx mxs)]) [nil (list nx)]))
        (> x v) [nil '()]
        :else (let [[mv mxs] (g (- v x) rxs)] [mv (cons x mxs)]))))) v xs)))
dzholev's solution:

1
2
3
4
5
6
(fn sh [n [h & t]]
   (cond
    (nil? h) []
    (coll? h)  [(sh n h)]
    (>= n h) (concat [h] (sh (- n h) t))
    :else []))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [n s]
  (first 
   ((fn rec-sequs-horribilis [r c n [ x & xs]]
    ;; (println "r=" r " ;c= " c " ;n= " n " ;x= " x " ;xs=" (take 3 xs))
    (cond 
     (nil? x) [r c ]
     (sequential? x) 
     (let [[nr nc] (rec-sequs-horribilis [] c n x)]
      (rec-sequs-horribilis (conj r nr) nc n xs))
     :else
     (let [ nc (+ c x)
      nr (if (>= n nc) (vec (conj r x)) r)]
      ;; (println "nr=" nr " ;nc= " nc " ;n= " n " ;x= " x " ;xs=" (take 3 xs))
      (if (< n nc)
        [ r c]
        (rec-sequs-horribilis nr nc n xs)))
    ))
   [] 0 n s)))
ericw's solution:

1
2
3
4
5
6
7
8
9
(fn f                                                                                                                                                   
    ([limit s] (f limit s 0))                                                                                                   
    ([limit s cur]                                                                                                                                      
        (let [n (first s)]                                                                                                      
            (cond                                                                                                                                       
                (nil? n) '()                                                                                                    
                (coll? n) (vector (f limit n cur))                                                                                                      
                (<= (+ n cur) limit) (cons n (f limit (rest s) (+ n cur)))                                                      
                :else '()))))
featalion's solution:

1
2
3
4
5
6
7
8
9
10
(fn to-sum [n coll]
  (lazy-seq
   (when (and (>= n 0) (not (empty? coll)))
     (let [[x & rst] coll]
       (if (coll? x)
         (let [sq (to-sum n x)
               sum (apply + (flatten sq))]
           (cons sq (to-sum (- n sum) rst)))
         (when (>= n x)
           (cons x (to-sum (- n x) rst))))))))
finsternis's solution:

1
2
3
4
5
6
7
8
(fn sh [n [s & ss]]
  (when s
    (if (integer? s)
      (if (<= s n)
        (lazy-seq (cons s (sh (- n s) ss)))
        '())
      (let [hd (sh n s) sum (apply + (flatten hd))]
        (lazy-seq (cons hd (sh (- n sum) ss)))))))
flububb's solution:

1
2
3
4
5
6
7
8
9
(fn seqs-horr
  [i [a & r]]
  (if a
    (if (coll? a)
      (list (seqs-horr i a))
      (if (<= a i)
        (conj (seqs-horr (- i a) r) a)
        '()))
    nil))
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [max-sum coll]
  (letfn [(step [coll current-sum max-sum]
            (if (seq coll)
              (let [head (first coll)]
                (if (coll? head)
                  (let [sub (step head current-sum max-sum)
                        next-sum (+ current-sum (reduce + (flatten sub)))]
                    (if (<= next-sum max-sum)
                      (cons sub (step (next coll) next-sum max-sum))
                      sub))
                  (let [next-sum (+ head current-sum)]
                    (if (<= next-sum max-sum)
                      (cons head (step (next coll) next-sum max-sum))
                      []))))))]
    (step coll 0 max-sum)))
geekerzp's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn _ [n coll]
    (letfn [(cost [coll]
              (if (sequential? coll)
                (apply + (flatten coll))
                coll))
            (fit [n coll]
              (if (sequential? coll)
                (_ n coll)
                (when (<= coll n) coll)))]
      (let [allowances (reductions #(- % (cost %2)) n coll)
            pruned (map fit allowances coll)]
        (take-while #(or (number? %) (not (empty? %))) pruned))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
(fn [tot tree]
    (let [zipper clojure.zip/zipper
          root clojure.zip/root
          up clojure.zip/up
          end? clojure.zip/end?
          node clojure.zip/node
          remove clojure.zip/remove
          next clojure.zip/next
          
          trim-tail
            (fn [[node path :as loc]]
                (with-meta [node (assoc path :r nil :changed? true)] (meta loc)))
          root? (fn [[node path]] (nil? path))
          coll-zip
            (fn [root]
                (zipper coll? seq (fn [node children] (with-meta (or children ()) (meta node)))
                        root))
        ]
        (loop [runsum 0, loc (coll-zip tree)]
            (cond
                (> runsum tot)
                    (if (root? loc)
                        (node loc)
                        (recur runsum (-> loc trim-tail up)))
                (end? loc)
                    (root loc)
                :else
                    (let [n (node loc)
                          runsum* (+ runsum (if (number? n) n 0))]
                        (if (> runsum* tot)
                            (recur runsum* (-> loc trim-tail remove))
                            (recur runsum* (next loc))))
            ))))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn __ [a b]
(letfn [(___  
([tl dl tally acc]
  (if (or (empty? dl) (> tally tl)) acc
    (if (number? (first dl))
      (if (<= (+ tally (first dl)) tl) 
          (___ tl (rest dl) (+ tally (first dl)) (conj acc (first dl)))
          acc)
      (let [[nv nl] (___ tl (first dl) tally [] true)]
        (___ tl (rest dl) nv (conj acc nl))))))
([tl dl tally acc ret]
  (if (or (empty? dl) (> tally tl)) [tally acc]
    (if (number? (first dl)) 
      (if (<= (+ tally (first dl)) tl) 
          (___ tl (rest dl) (+ tally (first dl)) (conj acc (first dl)) true)
          [tally acc])
      (let [[nv nl] (___ tl (first dl) tally [] true)]
        (___ tl (rest dl) nv (conj acc nl) true))))))]
(___ a b 0 [])))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn f [n s]
  (cond (< n 0)
        (list)
 
        (coll? (first s))
        (list (f n (first s)))
 
        (number? (first s))
        (let [x (first s)]
          (if (> x n)
            (list)
            (cons (first s) (f (- n (first s))
                               (rest s)))))
  ))
happycrisis's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [m s]
      (letfn [(f [acc [x & ss] c]
            (if (nil? x)
              [acc c nil]
              (if (coll? x)
            (let [[nx nc done] (f [] x c)]
              (if (= done :done)
                [(conj acc nx) 0 :done]
                (f (conj acc nx) ss nc)))
            (if (< m (+ x c))
              [acc 0 :done]
              (f (conj acc x) ss (+ x c))))))]
        (first (f [] s 0))))
hisba's solution:

1
2
3
4
5
6
7
(fn sh [lim s]
  (loop [[fi & re] s
         l lim
         acc []]
    (if (coll? fi) (conj acc (sh l fi))
      (if (or (nil? fi) (neg? (- l fi))) acc
        (recur re (- l fi) (conj acc fi))))))
icamts's solution:

1
2
3
4
5
6
7
8
9
10
(fn sequs [l t]
  (lazy-seq
    (when-first [e t]
      (cond 
        (sequential? e) 
        (let [sle (sequs l e)
              nl (- l (reduce + (flatten sle)))] 
          (cons sle (sequs nl (rest t))))
        (<= e l) (cons e (sequs (- l e) (rest t)))
        :else '()))))
immo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [n t]
  (letfn [
    (p [v] (apply + (flatten v)))
    (z [m s]
      (loop [r [] l s]
        (let [i (first l)]
          (if (or (nil? i) (> (p (conj r i)) (- n m)))
            (if (coll? i)
              (conj r (z (+ m (p r)) i))
              r)
            (recur (conj r i) (next l))))))]
      (z 0 t)))
jarlax's solution:

1
2
3
4
5
6
(fn sequs [n [x & xs]]
  (cond
    (coll? x) (list (sequs n x))
    (nil? x) ()
    (< n x) ()
    :else (conj (sequs (- n x) xs) x)))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn seqhorror [n coll]
  (let [totake (count (take-while #(>= n %) (reductions + (flatten coll))))
          build-res-seq (fn appender [coll] 
                                (cond (empty? coll) coll
                                      (= () (first coll)) (list (appender (rest coll)))
                                      :else (cons (first coll) (appender (rest coll)))
                            ))]
        (build-res-seq
        (loop [coll coll res [] taken 0]
            (cond (= totake taken) res
                  (coll? (first coll)) (recur (concat (first coll) (rest coll)) (conj res ()) taken) 
                  :else (recur (rest coll) (conj res (first coll)) (inc taken))
            )
        )
        )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
(fn g [s is]
  (if (empty? is)
    ()
    (let [[f & r] is]
      (cond
        (sequential? f)
          (cons (g s f)
                (g (- s (->> is first flatten (apply +))) r))
        (<= f s) (cons f (g (- s f) r))
        :else ()))))
johncowie's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn f ([n v r]
        (if (empty? v)
           r
           (let [c (first v)]
             (if (coll? c)
               (let [q (f n c [])]
                 (if (empty? q)
                    r
                    (concat r [q])))
               (if (< (- n c) 0)
                 r
                 (f (- n c) (rest v) (concat r [c])))))))
  ([n v] (f n v [])))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
;; Sadly seeems to be horrendously dificult to preserve 
;; arbitrarily nested collection types.
(fn sequs-horribilis [n coll]
  (letfn [(walk 
            [sum ret coll]
            (let [x (first coll)]
              (cond
                (or (empty? coll)
                    (and (number? x)
                         (> (+ sum x) n))) 
                [sum ret]
                
                (number? x)
                (recur (+ sum x)
                       (conj ret x)
                       (next coll))
                 
                :else
                (let [[new-sum result] (walk sum [] x)]
                  (recur new-sum
                         (conj ret result)
                         (next coll))))))]
    (second (walk 0 [] coll))))
jorendorff's solution:

1
2
3
4
5
6
7
8
9
10
11
(comp second
      (fn drive [gas road]
        (cond
         (< gas 0) [gas '()]
         (not (coll? road)) [(- gas road) (when (<= road gas) road)]
         (seq road) (let [[g1 r1] (drive gas (first road))
                          [g2 r2] (drive g1 (or (next road) '()))]
                      [g2 (if (nil? r1)
                            '()
                            (cons r1 r2))])
         :else [gas road])))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn upto [n coll]
  (reverse
    (loop [x coll remaining n result '()]
      (if (empty? x)
        result
        (let [val (first x)]
          (if (coll? val)
            (conj result (upto remaining val))
            (if (>= (- remaining val) 0)
              (recur (rest x) (- remaining val) (conj result val))
              result
              )
            )
          )
        )
      )
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [n coll]
  (second
    ((fn f [s c]
       (loop [[i a] [s []] [h & r] c]
         (if (nil? h)
             [i a]
             (if (coll? h)
                 (recur ((fn [[j b]] [j (conj a b)]) (f i h)) r)
                 (if (< n (+ i h))
                     [i a]
                     (recur [(+ i h) (conj a h)] r))))))
       0
       coll)))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn sequs-horribilis [n v]
  (letfn [(sequs-horribilis-it [n s v]
            (loop [a [] s s v v]
              (let [f (first v)
                    r (rest v)]
                (cond (nil? f) [a,s]
                      (coll? f) (let [[a2,s2] (sequs-horribilis-it n s f)]
                                  (recur (conj a a2) s2 r))
                      (> (+ f s) n) [a,s]
                      :else (recur (conj a f) (+ s f) r)))))]
 
    (first (sequs-horribilis-it n 0 v))))
blucas's solution:

1
2
3
4
5
6
7
8
9
(fn prob112
  [num xs]
  (letfn [(prob112-helper [[num] xs]
            (if (coll? xs)
              (let [rs (take-while #(<= 0 (first %))
                                   (reductions prob112-helper [num] xs))]
                [(first (last rs)) (map second (rest rs))])
              [(- num xs) xs]))]
    (second (prob112-helper [num] xs))))
brendan's solution:

1
2
3
4
5
6
7
8
; Evil hack
(fn [& _]
  (reify Object
    clojure.lang.IPersistentCollection
    (seq [_])
    (cons [_ _])
    (empty [_])
    (equiv [_ _] true)))
kuze's solution:

1
2
3
4
5
6
7
8
9
(fn my-sequs-horribilis
  [sum-to nested-coll]
  (loop [result [] i 0 rest-to-sum sum-to]
    (let [current-val (last (take (inc i) nested-coll))]
      (if (sequential? current-val)
        (conj result (my-sequs-horribilis rest-to-sum current-val))
        (if (or (> 0 (- rest-to-sum current-val)) (= result (take (inc i) nested-coll)))
          result
          (recur (conj result current-val) (inc i) (- rest-to-sum current-val)))))))
lackita's solution:

1
2
3
4
5
6
(fn horribilis [u s]
  (cond (empty? s) []
        (coll? (first s)) [(horribilis u (first s))]
        (< u (first s)) []
        :else (cons (first s) (horribilis (- u (first s))
                                          (rest s)))))
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [n xs]
  (let [sum (atom 0)]
    (letfn [(go [[x & xs]]
              (if-not (nil? x)
                (if (number? x)
                  (do (swap! sum + x)
                      (if (<= @sum n)
                        (cons x (go xs))
                        ()))
                  (cons (go x) (go xs)))))]
      (go xs))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
#(letfn [(sequs [n [x & coll]]
  (if (nil? x)
    [n []]
    (if (coll? x)
      (let [[n1 sub1] (sequs n x)]
        (if (>= n1 0)
          (let [[n2 sub2] (sequs n1 (rest coll))]
            [n2 (cons sub1 sub2)]
            )
          [n1 [sub1]]
          )
        )
      (if (>= n x)
        (let [[n1 sub1] (sequs (- n x) coll)]
          [n1 (cons x sub1)]
          )
        [(- n x) []]
        )
      )
    )
                )]
   (last (sequs %1 %2))
   )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(let [f (fn f [sm lst-in lst-out]
          ;(prn sm lst-in lst-out)
          (cond
            (empty? lst-in) [sm lst-out]
            (<= sm 0) [sm lst-out]
 
            (coll? (first lst-in))
            (let [[sm sub-out] (f sm (first lst-in) [])]
              (recur sm (rest lst-in) (if (empty? sub-out)
                                        lst-out
                                        (conj lst-out sub-out))))
    
            (<= (- sm (first lst-in)) 0)
            [(- sm (first lst-in)) lst-out]
 
            :else
            (recur (- sm (first lst-in) 0) (rest lst-in) (conj lst-out (first lst-in)))))]
  (fn soln [n lst] (second (f (inc n) lst []))))
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [n ls]
  (letfn [(p [n ls]
    (last (take-while #((complement neg?) (first %)) (reductions
      (fn [[cnt coll :as res] itm]
        (cond
          (coll? itm) (let [[cnt2 coll2] (p cnt itm)]
                        [cnt2 (conj coll coll2)])
          (neg? (- cnt itm)) [(- cnt itm) coll]
          :else [(- cnt itm) (conj coll itm)]))
      [n []]
      ls))))] 
    (last (p n ls))))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn sh [mx l]
  (if (empty? l)
    []
    (let [n (first l)]
      (if (coll? n) 
        (let [res (sh mx n)
              s (apply + (flatten res))]
          (if (empty? res)
            []
            (cons res (sh (- mx s) (rest l)))))                
        (if (> n mx)
          []
          (cons n (sh (- mx n) (rest l))))))))
malvert's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(letfn [(f [r s] 
  (loop [n r l [] i s] 
      (let [[e & t] i
            a [n l]]
        (cond 
          (nil? e) a
          (number? e) 
            (if (< n e)
              a
              (recur (- n e) (conj l e) t))
          1  (let [[m k] (f n e)]
              (recur m (conj l k) t))))))] 
  #(nth (f %1 %2) 1))
matiasl's solution:

1
2
3
4
5
6
7
(fn sh [n coll]
  (lazy-seq
    (when-let [[x & xs] coll]
      (if (coll? x)
        (cons (sh n x) nil)
        (when (not (neg? (- n x)))
          (cons x (sh (- n x) xs)))))))
maximental's solution:

1
2
3
4
5
6
7
8
(fn [n s]
  ((fn g [n [h & t]]
    (if (coll? h)
      `(~(g n h))
      (if (and h (>= n h))
        (cons h (g (- n h) t))
        ()))) 
   n s))
mbakhterev's solution:

1
(fn F [n [v & V :as S]] (if (not-empty S) (let [[c w] (if-not (coll? v) [v v] ((juxt identity #(reduce + (flatten %))) (F n v)))] (if (<= w n) (concat [c] (F (- n w) V)) []))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
(fn structured-take-sum
  [n coll] {:pre [(number? n)]}
  (let [ ;; This function is just like our main function, except it returns a
         ;; pair [i result], where the second element is the desired return
         ;; sequence and the first is the amount of "headroom" leftover; that
         ;; is, the difference between n and the recursive sum of all elements
         ;; in result. If any elements were omitted from coll (that is, if the
         ;; desired sum has already been reached), i is nil.
        structured-take-sum-k
        (fn structured-take-sum-k [n coll]
          (let [ ;; This function is going to be used as a reducer.  The
                 ;; accumulator is a pair [i acc], where acc is the output
                 ;; accumulated so far (a vector), and i is the amount of room
                 ;; we have before we exceed our desired sum, or nil if we've
                 ;; already found a number that would cause us to exceed it (and
                 ;; so should ignore the rest of the sequence).
                take-sum-reducer
                (fn [[i acc] x]
                  (cond
                    (nil? i)         [nil acc]
                    (coll? x)        (let [[new-i acc-add]
                                           (structured-take-sum-k i x)]
                                       [new-i (conj acc acc-add)])
                    (and (number? x)
                         (<= x i))     [(- i x) (conj acc x)]
                    :else             [nil acc]))]
            (->> (reductions take-sum-reducer [n []] coll)
                 (take-while first)
                 last)))]
    (second (structured-take-sum-k n coll))))
mfikes's solution:

1
2
3
4
5
6
7
8
(fn sequs-horriblis [n [x & r]]
  (if x
    (if (sequential? x)
      (let [sub (sequs-horriblis n x)]
        (cons sub (sequs-horriblis (- n (reduce + (flatten sub))) r)))
      (if (<= x n)
        (cons x (sequs-horriblis (- n x) r))
        ()))))
minitrue's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [k xs]
  (let [n (count (take-while #(<= % k) (reductions + (flatten xs))))
        h (fn h [n [x & xs]]
            (cond
              (zero? n) []
              (nil? x) []
              (coll? x)
                (let [l (count (flatten x))]
                  (if (< l n)
                    (cons x (h (- n l) xs))
                    [(h n x)]))
              :else (cons x (h (dec n) xs))))]
    (h n xs)))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn horribilis [n s]
              (loop [init s r 0 result []]
                (if (empty? init)
                  result
                  (if (sequential? (first init))
                    (recur (rest init) 
                           (+ r (apply + (flatten (horribilis (- n r) (first init))))) 
                           (conj result (horribilis (- n r) (first init))))
                    (if (> (+ (first init) r) n)
                      result
                      (recur (rest init) (+ (first init) r) (conj result (first init))))))))
mobiusloop's solution:

1
2
3
4
5
6
7
(fn x [s [h & t]]
  (if (nil? h) []
    (if (coll? h)
      (cons (x s h) (x (apply - s (flatten h)) t))
      (if (< s h) [] (cons h (x (- s h) t)))
      )
    ))
mononite's solution:

1
2
3
4
5
6
7
8
(fn [v coll]
  (letfn [(f [v coll acc]
             (if-let [h (first coll)]
               (if (coll? h)
                 (let [[n r] (f v h [])] (if (neg? n) [n (conj acc r)] (recur n (rest coll) (conj acc r))))
                 (if (> h v) [-1 acc] (recur (- v h) (rest coll) (conj acc h))))
               [v acc]))]
    (second (f v coll []))))
mouse's solution:

1
2
3
4
5
6
7
8
9
(fn [n r]
    (letfn [
            (ixs [r i] (if (coll? r) (mapcat #(ixs % (conj i %2)) (seq r) (range)) [[i r]]))
            (f [is] (#(get-in (last %) [1 0] [-1])
                     (take-while #(<= 0 (% 0)) (reductions #(vector (- (% 0) (%2 1)) %2) [n []] is))))
            (tt  [t [k & ks]] (if (seq ks) (concat (take k t) [(tt (t k) ks)]) (take (inc k) t)))
            ]
      (tt r (f (ixs r [])))
      ))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [max-sum coll]
  (letfn [(sequs-horribilis [remain-sum coll]
            (loop [remain-sum remain-sum
                   coll       coll
                   result     []]
              (if (empty? coll)
                [remain-sum result]
                (let [x (first coll)]
                  (let [[remain-sum x] (if (sequential? x)
                                         (sequs-horribilis remain-sum x)
                                         [(- remain-sum x) x])]
                    (if (neg? remain-sum)
                      (if (and (sequential? x)
                               (not-empty x))
                        [remain-sum (conj result x)]
                        [remain-sum result])
                      (recur remain-sum
                             (rest coll)
                             (conj result x))))))))]
    (second (sequs-horribilis max-sum coll))))
nagi's solution:

1
2
3
4
5
6
7
(fn __ [n xs]
  (let [h (first xs)]
    (cond
      (empty? xs) '()
      (and (number? h) (< (- n h) 0)) '()
      (coll? h) (list (__ n h))
      :else (cons (first xs) (__ (- n h) (rest xs))))))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn solve [leftt ss]
  (letfn [(solve-in [left s]
            (loop [left left
                   s s
                   acc []]
              (if (empty? s)
                [left (remove #(and (coll? %) (empty? %)) acc)]
                (let [cur (first s)]
                (println cur)
                  (if (number? cur)
                    (if (>= left cur)
                      (recur (- left cur) (rest s) (conj acc cur))
                      [left (remove #(and (coll? %) (empty? %)) acc)])
                    (let [[l r] (solve-in left cur)]
                      (recur l (rest s) (conj acc r))))))))]
    (last (solve-in leftt ss))))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn jajj [max s]
  (loop [acc [] m max s s]
    (if (empty? s)
      acc
      (let [[c & r] s]
        (if (sequential? c)
          (let [res (jajj m c)
                sum (apply + (flatten res))]
            (recur (conj acc res) (- m sum) r))
          (if (<= c m)
            (recur (conj acc c) (- m c) r)
            acc)
          ))))
  )
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn horseq [n tree]
  (letfn [(treesum [tree]
            (if (coll? tree)
              (reduce + (map treesum tree))
               tree))]
    (when (>= n 0)
      (if (coll? tree)
        (if (seq tree)
      (let [fpart (horseq n (first tree))
                sum (treesum fpart)]
            (if fpart
              (cons fpart
                    (horseq (- n sum) (rest tree)))
              ()))
      ())
        (when (<= tree n) tree)))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn f
   ([sum n s]
    (if (seq s)
      (let [head (first s)
            tail (rest s)]
        (if (coll? head)
          (let [sub-result (f sum n head)]
            (cons sub-result (f (apply + sum (flatten sub-result)) n tail)))
          (if (<= (+ sum head) n)
            (cons head (f (+ sum head) n tail))
            '())))))
   ([n s] (f 0 n s)))
owk4057's solution:

1
2
3
4
5
6
7
8
9
(fn sub [n coll]
  
    (loop [sum 0, coll (take 10 coll), res []]
      (if (empty? coll) (filter #(or (number? %) ((complement empty?) (flatten %))) res)
        (if (number? (first coll)) (if (<= (+ (first coll) sum) n) 
                                     (recur (+ sum (first coll)) (rest coll) (conj res (first coll)))
                                     (recur sum (rest coll) res))
        
          (recur (+ sum (apply + (flatten (sub (- n sum) (first coll))))) (rest coll) (conj res (sub (- n sum) (first coll))))))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn f
  ([n xs] (second ((f n) (seq xs))))
  ([n]
   (fn [xs]
     (if-not xs
       [n ()]
       (let [[x & xs] xs]
         (if-not (sequential? x)
           (let [n (- n x)]
             (if-not (neg? n)
               (let [[n xs] ((f n) xs)]
                 [n (cons x xs)])
               [nil ()]))
           (let [[n x] ((f n) x)]
             (if-not n
               (if (empty? x)
                 [n x]
                 [n (cons x nil)])
               (let [[n xs] ((f n) xs)]
                 [n (cons x xs)])))))))))
ozan's solution:

1
2
3
4
5
6
7
8
(fn sequs [sum [x & xs]]
  (if (nil? x) []    
    (if (sequential? x)
      (concat [(sequs sum x)] (sequs (- sum (reduce + (flatten x))) xs))
      (if (< sum x)
        []
        (concat [x] (sequs (- sum x) xs)))))
  )
pukeface's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(comp first (fn sum-break [sum tree]
    (if
          (empty? tree) [tree sum]
        (let [head (first tree)]
             (if (and (number? head) (< sum head))
                 [[] -1]
                 (let [[proc-head remaining] 
                       (if (number? head)
                           [head (- sum head)]
                           (sum-break sum (first tree)))]
             (if (< remaining 0) [[proc-head] remaining]
                 (let [[proc-tail remaining] (sum-break remaining (rest tree))]
                      [(cons proc-head proc-tail) remaining]))))))))
quant1's solution:

1
2
3
4
5
6
7
8
(fn dcl [l x]
  (loop [c [] [x1 & rx] x]
    (let [rc (- l (apply + (flatten c)))]
      (cond
        (nil? x1) c
        (coll? x1) (recur (conj c (dcl rc x1)) rx)
        (<= x1 rc) (recur (conj c x1) rx)
        :else c))))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn [sum coll]
  (last
   (take-while
    #(>= sum (reduce + (flatten %)))
    (
     (fn redux
       ([coll] (redux [] coll))
       ([prefix [fst & rst]]
         (cons
          prefix
          (if-not (nil? fst)
            (concat
             (if (sequential? fst)
               (map #(conj prefix %) (lazy-seq (redux fst)))
               )
             (lazy-seq (redux (conj prefix fst) rst))
             ))
        ))
       )
     coll
     )
    )))
sbondaryev's solution:

1
2
3
4
5
6
7
(fn f [n [fst & rst :as xs]]
  (cond
    (not (seq xs)) nil
    (sequential? fst) (let [sub (f n fst)]
                        (cons sub (f (- n (apply + (flatten sub))) rst)))
    (>= (- n fst) 0) (cons fst (f (- n fst) rst))
    :else '()))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
(fn what [n coll]
  (letfn [(process-next [cnt in]
            (loop [cnt cnt out [] in in]
              (let [head (first in)]
                (cond
                  (= head nil) out
                  (coll? head) (conj out (process-next cnt head))
                  (> (+ cnt head) n) out
                  :else (recur (+ cnt head) (conj out head) (rest in))))))]
    (process-next 0 coll)))
sheldon's solution:

1
2
3
4
5
6
(fn d [n [h & t :as s]] 
   (cond 
     (empty? s) [] 
     (coll? h)  [(d n h)]
     (>= n h) (concat [h] (d (- n h) t))
     :else []))
silverio's solution:

1
2
3
4
5
6
7
8
9
10
(fn [n s]
  (let [x (ref n)] ; yeah, I know... stfu
    ((fn proc [[h & t]]
       (if (and h (or (coll? h) (>= @x h)))
        (cons
          (if (coll? h)
            (proc h)
            (dosync (ref-set x (- @x h)) h))
          (proc t)) '()))
      s)))
skyrem's solution:

1
2
3
4
5
6
7
8
9
(fn [n c]
  (letfn [(f [s] (if (and (coll? (last s)) (not (empty? (last s))))
                   (concat (drop-last s) [(f (last s))]) (drop-last s)))]
    (let [p (loop [step 3]
              (if (>= (apply + (flatten (take step c))) n) (take step c)
                (recur (inc step))))]
      (loop [r p]
        (if (> (apply + (flatten r)) n) (recur (f r)) r)
        ))))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
10
(fn [i n s]
  (let [n (atom n)]
    ((fn f [i [h & t :as s]]
      (if (empty? s)
           i
          (if (coll? h)
              (f (conj i (f [] h)) t)
              (if (neg? (swap! n - h))
                   i
                  (f (conj i h) t))))) i s))) []
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn drop-3d [sum xs]
  (second
    ((fn drop3d-core [sum xs]
      (loop [sum sum
             so-far []
             remain (rest xs)
             now (first xs)]
          (cond
            (nil? sum)          [nil so-far]
            (nil? now)          [sum so-far]
            (sequential? now)   (let [[inner-sum inner-seq] (drop3d-core sum now)]
                                  (recur inner-sum (conj so-far inner-seq) (rest remain) (first remain)))
            (>= sum now)        (recur (- sum now) (conj so-far now) (rest remain) (first remain))
            :else               [nil so-far])))
      sum
      xs)))
syeerzy's solution:

1
2
3
4
5
6
(fn horrible [x node]
  (if-let [h (first node)]
    (cond
      (coll? h) (if-let [t (horrible x h)] (list t))
      (<= h x) (cons h (horrible (- x h) (rest node)))
      :else '())))
tclamb's solution:

1
2
3
4
5
6
7
8
9
(fn f [n [a & b :as c]]
  (cond
    (empty? c) c
    (coll? a) (let [r (f n a)
                    s (reduce + (flatten r))]
                (concat [r] (f (- n s) b)))
    :else (if (<= a n)
            (concat [a] (f (- n a) b))
            [])))
thegeez's solution:

1
2
3
4
5
6
7
8
9
10
(fn r [n form]
    (map second (take-while identity
                 (next (iterate (fn [[c _ [s & ss]]]
                                  (when s
                                    (if (coll? s)
                                      (let [res (r (- n c) s)]
                                        [(+ c (reduce + (flatten res))) res ss])
                                     (when (<= (+ c s) n)
                                       [(+ c s) s ss])))) [0 nil form]))
                 )))
zzamboni's solution:

1
2
3
4
5
6
7
8
(fn sequs
  ([l s] (sequs l s [] 0))
  ([l [e & r] res t]
   (cond (nil? e) res
         (number? e) (let [t2 (+ t e)]
                       (if (> t2 l) res
                           (sequs l r (conj res e) t2)))
         :else (conj res (sequs l e [] t)))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
(fn __ [n xs]
  (letfn [(f [n & xs]
             (if (empty? xs) xs
               (let [x (first xs), rs (rest xs)]
                 (cond (coll? x) (list (apply f n x))
                       (> x n) '()
                       :else (cons x (apply f (- n x) rs))))))]
    (apply f n xs)))
zipzop's solution:

1
2
3
4
5
6
7
8
9
(fn sh 
  ([n c] (sh n [] c))
  ([n a [h & args]]
   (if (or (nil? h) (and (number? h) (> h n)))
     a
     (if (coll? h)
       (conj a (sh n [] h))
       (recur (- n h) (conj a h) args)
      ))))
yusubori's solution:

1
2
3
4
5
6
7
(fn f [n [x & r]]
  (cond
   (nil? x) ()
   (coll? x) (let [s (f n x)]
               (cons s (f (- n (apply + (flatten s))) r)))
   (<= x n) (cons x (f (- n x) r))
   :e ()))
ydash's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [n l]
  ((fn f [[h & r] sum]
     (cond (> sum n) ()
           h (if (sequential? h)
               (let [s (apply + (flatten h))]
                 (cons (f h sum) (f r (+ sum s))))
               (if (>= n (+ sum h))
                 (cons h (f r (+ sum h)))
                 () ))
           :else ()
           ))
   l 0))
vpeurala's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
(fn [n tree] (letfn [
(tree-from-stack-vector [sv]
    (cond
        (empty? sv)
        sv
        (empty? (rest sv))
        (first sv)
        :else
        (conj (first sv) (tree-from-stack-vector (rest sv)))))
(tree-take
    ([n tree] (tree-take n [] [] [] tree))
    ([n heads tails current-head current-tail]
    (cond
        (zero? n)
        (tree-from-stack-vector (conj heads current-head))
        (and (empty? current-tail) (empty? tails))
        (tree-from-stack-vector (conj heads current-head))
        (and (empty? current-tail) (not (empty? tails)))
        (tree-take
            n
            (pop heads)
            (pop tails)
            (conj (peek heads) current-head)
            (peek tails))
        (number? (first current-tail))
        (tree-take
            (dec n)
            heads
            tails
            (conj current-head (first current-tail))
            (rest current-tail))
        (sequential? (first current-tail))
        (tree-take
            n
            (conj heads current-head)
            (conj tails (rest current-tail))
            []
            (first current-tail)))))
(tree-take-while
    ([pred tree] (tree-take-while pred [] [] [] tree))
    ([pred heads tails current-head current-tail]
    (cond
        (not (pred heads tails current-head current-tail))
        (tree-from-stack-vector (conj heads (or (butlast current-head) [])))
        (and (empty? current-tail) (empty? tails))
        (tree-from-stack-vector (conj heads current-head))
        (and (empty? current-tail) (not (empty? tails)))
        (tree-take-while
            pred
            (pop heads)
            (pop tails)
            (conj (peek heads) current-head)
            (peek tails))
        (number? (first current-tail))
        (tree-take-while
            pred
            heads
            tails
            (conj current-head (first current-tail))
            (rest current-tail))
        (sequential? (first current-tail))
        (tree-take-while
            pred
            (conj heads current-head)
            (conj tails (rest current-tail))
            []
            (first current-tail)))))
(tree-sum [tree] (reduce + (flatten tree)))
(sequs-horribilis [n tree] (tree-take-while (fn [heads tails current-head current-tail] (>= n (tree-sum (conj heads current-head)))) tree))
] (sequs-horribilis n tree)))
v_bogdanov's solution:

1
2
3
4
5
6
7
8
(fn x [n v]
  (let [[f s] v]
    (cond (nil? f) nil
          (and (integer? f) (> f n)) []
          true
          (if (integer? f)
              (into [f] (x (- n f) (rest v)))
            [(x n (first v))]))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn para-go [n v]
  (letfn [(para-cnt [ret lst acc]
            (if (empty? lst)
              [ret acc]
              (let [head (first lst)]
                (if (coll? head)
                  (let [[new-val new-acc] (para-cnt [] head acc)
                        new-ret (if (empty? new-val)
                                  ret
                                  (conj ret new-val))]
                    (if (< new-acc 0)
                      [new-ret new-acc]
                      (recur new-ret (rest lst) new-acc)))
                  (if (> head acc)
                    [ret (- acc head)]
                    (recur (conj ret head) (rest lst) (- acc head)))))))]
    (first (para-cnt [] v n))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [n s]
  (second 
   ((fn sequs [n s]
      (loop [cnt 0 acc [] [x & xs] s]
        (cond
         (or (nil? x) (< n cnt)) [cnt acc]
         (coll? x) (let [[c r] (sequs (- n cnt) x)
                         coll (if (empty? r) acc (conj acc r))]
                     (recur (+ c cnt) coll xs))
         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) 
    n s)))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn crap [n loc]
  (loop [n n
         newz []
         z loc]
    (if (or (empty? z) (neg? n)) newz
        (let [h (first z)
              t (rest z)]
          (cond
           (vector? h) (conj newz (crap n h))
           (> h n) newz
           :else (recur (- n h) (conj newz h) t))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)