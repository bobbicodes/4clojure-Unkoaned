;; 86 Happy numbers [m]

Happy numbers are positive integers that follow a formula:
take each individual digit, square it,
and then sum the squares to get a new number.
Repeat with the new number and eventually,
you might get to a number whose squared sum is 1.
This is a happy number.
An unhappy number (or sad number) loops endlessly.
Determines if a number is happy or not.

(= (__ 7) true)
(= (__ 986543210) true)
(= (__ 2) false)
(= (__ 3) false)

(fn happy? [n]
  (letfn [(digits [n]
            (map #(Integer/parseInt (str %)) (str n)))
          (sum-of-squares [n]
            (reduce + (map #(* % %) (digits n))))]
    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))

(fn [i-n]
  (letfn [(sq-sum
           [x]
           (->> (str x) (re-seq #"\d")
                (map read-string)
                (#(map * % %))
                (apply +)))]           
    (loop [found #{} n i-n]
      (let [x (sq-sum n)]
        (cond (= 1 x) true
              (found x) false
              :else (recur (conj found x) x))))))

(fn
 f
 ([number] (f number 0))
 ([number counter]
  (let
   [x
    (reduce
     +
     (map
      (comp
       (fn* [p1__2852#] (* p1__2852# p1__2852#))
       (fn* [p1__2853#] (Integer/parseInt p1__2853#))
       str)
      (seq (str number))))]
   (if (= x 1) true (if (= counter 10000) false (recur x (inc counter)))))))

#(letfn[(sqDigit [d]
                 (let [dVal (- (int d) (int \0))]
                   (* dVal dVal)))
        (nextNumber[x]
                   (reduce + (map sqDigit (seq (str x)))))]
   (loop[seen #{}, number %]
     (cond
      (seen number) false
      (= number 1) true
      :else (recur (conj seen number) (nextNumber number)))))

(fn happy?
  ([n] (happy? [] n))
  ([seen n]
    (cond
      (= 1 n)
        true
      (contains? seen n)
        false
      true
        (recur (conj seen n)
          (->> n
            (str)
            (map #(- (int %) (int \0)))
            (map #(* % %))
            (reduce +) )))))
aceeca1's solution:
1
2
3
4
5
6
7
8
9
(letfn [
    (happy [x] (apply + (for [
        i (str x)] 
        (#(* % %) (- (int i) 48)))))
    (happy? [s x] (cond
        (s x) false
        (= 1 x) true
        true (recur (conj s x) (happy x))))]
    happy?) #{}
adereth's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [num]
  (let [digits (fn [n]
                 (map second
                      (rest
                       (take-while #(not= % [0 0])
                                   (iterate
                                    (fn [[q r]] [(quot q 10) (rem q 10)])
                                    [n 0])))))
        s-d (fn [n] (apply + (map #(* % %) (digits n))))]
    (loop [num num
           seen #{}]
      (cond
       (seen num) false
       (= num 1) true
       :else (recur (s-d num) (conj seen num))))))
aferrandi's solution:
1
2
3
4
5
6
7
8
9
10
(fn happyX [n] ((fn happyRec [n seen] 
    (if (= n 1) true 
        (if (contains? seen n) false 
            (happyRec ((fn squaresDigits [n] ((fn sumsquares [x] (reduce + (map (fn [n] (* n n)) x))) (
(fn digits[n]
    (if (< n 10) (list n) 
        (cons (mod n 10) (digits (quot n 10))))) n)))
 n) (conj seen n))
            )))
 n #{}))
aguirre's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn happy [x]
  (loop [y x
         seen-before #{}]
    (cond (= y 1) true
          (contains? seen-before y) false
          :else (letfn [(digits [x]
                                (loop [y x
                                             ds []]
                                        (if (< y 10) (conj ds y)
                                          (let [dig (mod y 10)]
                                            (recur (/ (- y dig) 10) (conj ds dig))))))
                        (sumSquares [xs] (reduce + (map #(* % %) xs)))]
                  (recur (sumSquares (digits y)) (conj seen-before y))))))
alanforr's solution:
1
2
3
4
5
6
7
8
9
(fn [a]
  (let [digits (fn [b] (map #(Integer/parseInt (str %))  (seq (str b))))
        sumsqrdigits (fn [c] (reduce +' (map #(*' % %)  (digits c)))) ]
    (loop [curr [(sumsqrdigits a)]]
      (let [num (sumsqrdigits (last curr))]
        (cond
         (= (last curr) 1) true
         (empty? (filter #(= % num) curr)) (recur (conj curr num))
         :else false)))))
allenl's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn happy? [x]
  (letfn [(sum-sq-digit [x]
           (->>
            (str x)
            (map #(- (int %) (int \0)))
            (map #(* % %))
            (apply +)
            str))]
        (loop [x x
               seen #{}]
          (let [sx (sum-sq-digit x)]
            (cond
              (= "1" sx) true
              (seen sx) false
              :else (recur sx (conj seen sx)))))))
andthorn's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (let [succ (fn [n] (reduce + (map #(let [d (read-string (str %))] (* d d)) (str n))))]
    (loop [seen #{n} n (succ n)]
      (if (= n 1)
        true
        (if (contains? seen n)
          false
          (recur (conj seen n) (succ n)))))))
anjensan's solution:
1
2
3
4
5
6
7
8
9
10
(fn [t]
        (= 1
           ((fn f 
              ([x d]
                (let [s (reduce + (map (comp #(* % %) read-string str) x))]
                  (if (d s)
                    s
                    (f (str s) (conj d s)))))
              ([x] (f (str x) #{})))
             t)))
astangl's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn
  [n]
  (letfn [(sumSq [n]
            (loop [a 0
                   n n]
              (if (= n 0)
                a
                (let [d (mod n 10)
                      n' (quot n 10)
                      a' (+ a (* d d))]
                  (recur a' n')))))]
    (loop [n n
           prev-n #{}]
      (if (= n 1)
        true
        (if (contains? prev-n n)
          false
 
          (let [n' (sumSq n)
                prev-n' (conj prev-n n)]
            (recur n' prev-n')))))))
austintaylor's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [x]
  (loop [x x seen '()]
    (cond (= 1 x) true
          (some #(= % x) seen) false
          true
            (recur 
              (reduce +
                (map #(int (Math/pow
                  (Integer/parseInt (str %)) 2))
                  (str x)))
              (conj seen x)))))
awebb's solution:
1
2
3
4
5
6
7
(fn h [n]
  (loop [seen #{}, n n]
    (cond (seen n) false
          (= 1 n) true
          :else (recur 
            (conj seen n)
            (reduce #(+ %1 (* %2 %2)) 0 (map (comp read-string str) (str n)) )  ))))
bendykst's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [n]
  (letfn [(sumsqrs [x] 
            (apply + 
              (loop [a [] n x] 
                (if (pos? n) 
                (recur (conj a (apply * (repeat 2 (mod n 10)))) 
                       (quot n 10)) 
                a))))]
    (loop [numbers [n]]
      (let [new-number (sumsqrs (last numbers))]
        (cond
          (= new-number 1) true
          (some (partial = new-number) numbers) false
          :else (recur (conj numbers new-number)))))))
benhammond's solution:
1
2
3
4
5
(fn f ([n] (f #{} n))
   ([acc n] (cond (= n 1) true
                  (acc n) false
                  :else (recur (conj acc n)
                         (apply + (map #(let [n (Character/getNumericValue %)] (* n n)) (seq (str n))))))))
benizi's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (letfn [(squaredsum [x] (reduce + (map #(* % %) (map #(Integer/parseInt %) (map str (str x))))))]
    (loop [seen #{}
           n (squaredsum n)]
      (cond
       (seen n) false
       (= 1 n) true
       :else (recur (conj seen n) (squaredsum n))))))
bobuhiro11's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn  [n]
  (let [num->digits
        (fn [num]
          (loop [n num res []]
            (if (zero? n)
              res
              (recur (long (/ n 10)) (cons (mod n 10) res)))))
        happy? (fn [n sads]
                 (let [sum (reduce +  (map #(* % %) (num->digits n)))]
                   (cond  (=  sum 1) true
                         (some #(= % n) sads) false
                         :else (recur sum (cons n sads)))))]
                 (happy? n [])))
burner's solution:
1
2
3
4
5
6
7
8
9
(letfn [(digits [n]
                (if (zero? n) [0] (cons (mod n 10) (digits (quot n 10)))))
              (hnext [n]
                (reduce + (map #(* % %) (digits n))))
              (happys [s n]
                (if (contains? s n)
                  s
                  (happys (conj s n) (hnext n))))]
        (fn [n] (contains? (happys #{} n) 1)))
caterpillar's solution:
1
2
3
4
5
6
#(loop[n % mem #{}]
   (if (= n 1) true
    (let [digits (map (fn[c] (- (int c) 48)) (str n)) 
          s-sum (reduce (fn[x y] (+ x (* y y))) 0 digits)]
      (if (contains? mem s-sum) false
        (recur s-sum (conj mem s-sum))))))
cc787's solution:
1
2
3
4
5
6
7
8
9
10
(fn [arg]
  (letfn [(happyloop [xs]
            (->> xs str (map #(Integer/parseInt (str %))) (map #(* % %)) (apply +)))]
    (loop [generated #{}
           xs (iterate happyloop arg)]
      (let [next (first xs)]
        (cond (= next 1) true
              ((complement nil?) (generated next)) false
              :else (recur (conj generated next) (drop 1 xs)))))
    ))
chunchangshao's solution:
1
#(case % 2 false 3 false true)
ctzsm's solution:
1
2
3
(fn [x] (not= nil (some (fn [x] (= x 1))
   (take 100
         (iterate #(apply + (for [y (str %)] (let [c (- (int y) 48)] (* c c)))) x)))))
dan7es's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn happy? [n]
  (loop [vis #{}
         n   n]
    (cond
     (= 1 n) true
     (vis n) false
     
     :else
     (recur (conj vis n)
            (apply +
              (map (comp
                    #(* % %)
                    #(- % 48)
                    int)
                   (str n)))))))
daniels's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
#(let 
  [nextnum (fn [x]
             (->> x
                  str
                  (map (comp read-string str))
                  (map (fn [a] (* a a)))
                  (apply +)))
             
   ]  
  ((fn e [a b] 
    (and
     (not (b a))
     (or
      (== a 1)
      (e (nextnum a) (conj b a))))) 
   % #{}))
daowen's solution:
1
2
3
4
5
6
7
8
9
(fn is-happy? [n]
  (let [sqr #(* % %)
        to-int #(- (int %) (int \0))
        sqr-as-int (comp sqr to-int)]
    (loop [n n, seen #{}]
      (if (seen n) false
        (let [n2 (apply + (map sqr-as-int (str n)))]
          (if (= 1 n2) true
            (recur n2 (conj seen n))))))))
del680202's solution:
1
2
3
4
5
6
7
8
9
10
(fn [num]
  (let [_sq_sum  (fn [n] (reduce + (map #(* % %) (for [sq (str n)](Integer. (str sq))))))]
  (loop [history [] n num]
   (if (= 1 n) true
     (if (contains? history n) false
       (recur (conj history (_sq_sum n)) (_sq_sum n))
     )
   )
  ))
)
deping's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [n]
  (letfn 
    [(sumthisbitch [n]
       (if (= n 0) 0
         (let [ln (mod n 10) lika (quot n 10)]
           (+ (* ln ln) (sumthisbitch lika))
         )))
     (tryx [n pastsums]
       (let [thissum (sumthisbitch n)]
         (if (= thissum 1) true
           (if (contains? pastsums thissum) false
             (tryx thissum (conj pastsums thissum))
             ))))]
    (tryx n [])))
devm33's solution:
1
2
3
4
5
6
7
8
9
(fn [h]
  (loop [seen #{} cur h]
    (if (= 1 cur) true
      (if (contains? seen cur) false
        (recur
          (conj seen cur)
          (reduce + (map #(* % %) (loop [n cur d []]
                                    (if (zero? n) d
                                      (recur (quot n 10) (conj d (mod n 10))))))))))))
dwelte's solution:
1
2
3
4
5
6
7
8
9
(fn [x]
  ((fn r [y s]
    (cond
      (= y 1) true
      (s y) false
      :else (r
        (reduce + (map #(* % %) (map #(Character/getNumericValue %) (str y))))
        (conj s y))))
    x #{}))
dzholev's solution:
1
2
3
4
5
6
; Porges, A. "A Set of Eight Numbers."
(fn [n]
  (letfn [(seq-n [k] (cons 0 (map #(Integer/parseInt (str %)) (str k))))
          (compute-n [s] (reduce #(+ %1 (* %2 %2)) s))
          (happy-seq [m] (cons m (lazy-seq (happy-seq (compute-n (seq-n m))))))]
    (= 1 (compute-n (seq-n (first (drop-while #(not (contains? #{0 1 4 16 20 37 42 58 89 145} %)) (happy-seq n))))))))
echevarria's solution:
1
2
3
4
5
6
7
(fn [s n]
  (if (= 1 n) 
   true
   (let [nn (reduce #(+ %1 (* %2 %2)) 0 (map (comp read-string str) (str n)))]
    (if (s nn)
     false
     (recur (conj s nn) nn))))) #{}
ericw's solution:
1
2
3
4
5
6
7
8
9
(letfn [                                                                                                                        
    (to-sequence [n] (map #(- (int %) 48) (seq (str n))))                                                                                               
    (new-number [n] (reduce #(+ %1 (* %2 %2)) 0 (to-sequence n)))                                                               
    (is-happy? [n] (loop [n' n seen #{}]                                                                                                                
        (cond                                                                                                                   
            (= n' 1) true                                                                                                                               
            (get seen n') false                                                                                                 
            :else (recur (new-number n') (conj seen n')))))]                                                                                            
                is-happy?)
featalion's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn happy-n?
  ([n] (happy-n? n #{}))
  ([n seen]
   (letfn [(n->digits
            ([n_] (n->digits nil n_))
            ([ds n_]
             (if (< 0 n_)
               (recur (conj ds (rem n_ 10)) (quot n_ 10))
               ds)))]
     (let [new-n (reduce #(+ %1 (* %2 %2)) 0 (n->digits n))]
       (if (= 1 new-n)
         true
         (if (contains? seen new-n)
           false
           (recur new-n (conj seen new-n))))))))
finsternis's solution:
1
2
3
4
5
6
7
8
9
10
(fn [n]
  (letfn [(ssd [n]
               (->> n str (map (comp #(* % %) read-string str)) (apply +)))
          (happy' [n v]
                  (let [s (ssd n)]
                    (cond
                     (= s 1) true
                     (contains? v s) false
                     :else (happy' s (conj v n)))))]
    (happy' n #{})))
flububb's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn happy
  ([n] (happy n []))
  ([n s]
    (letfn [(digits [n]
              (map #(Integer. (str %)) (str n)))]
      (if (empty? (filter #(= n %) s))
        (if (= n 1 )
          true
          (happy 
            (reduce + (map  #(* % %) (digits n)))
            (cons n s)))
        false))))
garyxia's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(letfn [(num->digits [num]
          (loop [n num res []]
            (if (zero? n)
              res
              (recur (long (/ n 10)) (cons (mod n 10) res)))))
        (change [n]
          (apply + (map #(* % %) (num->digits n))))]
  (fn [init]
    (loop [curr init results #{}]
      (println curr " - " results)
      (cond
       (= 1 curr) true
       (results curr) false
       :else (let [new-n (change curr)]
               (println curr new-n)
               (recur new-n (into results [curr])))
       )))
  )
geekerzp's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [n]
    (letfn [(digitize [n]
              (loop [n n
                     ret ()]
                (if (< n 1)
                  ret
                  (recur (quot n 10) (conj ret (rem n 10))))))
            (change [n]
              (reduce + (map #(* % %) (digitize n))))]
      (loop [n (change n)
             ret #{}]
        (cond
          (= 1 n) true
          (ret n) false
          :else (recur (change n) (conj ret n))))))
glchapman's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn happy? [n]
    (let [digits
            (fn digits [n] (lazy-seq
                (when (pos? n)
                    (cons (rem n 10) (digits (quot n 10))))))
          sqr #(* % %)
        ]
        (loop [n n, seen #{}]
            (cond
                (= n 1) true
                (seen n) false
                :else (recur (apply + (map sqr (digits n))) (conj seen n))
            ))))
goaranger's solution:
1
2
3
4
5
6
7
8
9
10
(fn allit 
  ([in] (allit in 1))
  ([in acc]
  (let [oneit (fn oneit [x] 
                (int (apply + (map #(Math/pow (Integer. %) 2) (rest (clojure.string/split (str x) #""))))))]
   (if (> acc 1000)
     false
     (if (= 1 (oneit in))
       true
       (allit (oneit in) (inc acc)))))))
gpittarelli's solution:
1
2
3
4
5
6
7
8
(fn happy? [n]
  (let [happy (fn [x] (reduce +
                              (map #(* %1 %1)
                                   (map read-string
                                        (re-seq #"." (str x))))))]
    (= 1 (happy
          (last (take-while #(and (not= 1 %1) (not= 4 %1))
                            (iterate happy n)))))))
happycrisis's solution:
1
2
3
4
5
6
7
(fn [n] (loop [seen #{} 
               [s & rst] (iterate (fn [s] (apply + (map (comp #(* % %) read-string)
                                                        (re-seq #"." (str s)))))
                                  n)] 
          (cond (= s 1) true 
                (seen s) false 
                :else (recur (conj seen s) rst))))
hisba's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn hn? [nn]
  (let [step (fn [n] (->> n
                          str
                          (map #(- (int %) (int \0)))
                          (map #(* % %))
                          (apply +)))]
    (loop [i nn done #{}]
      (let [i2 (step i)]
        (cond (= 1 i2) true
              (done i2) false
              :else (recur i2 (conj done i2)))))))
icamts's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n] 
    (let [happy-seq (fn [n] 
                      (iterate (fn [i] (reduce (fn [s j] 
                                                 (let [d (Integer/parseInt (str j))] 
                                                   (+ s (* d d)))) 
                                               0 (str i))) n))
          h? (fn [hs ps]
               (let [e (first hs)] (cond (= 1 e) true
                                    (ps e) false
                                     :else (recur (next hs) (conj ps e)))))]
      (h? (happy-seq n) #{})))
immo's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [n]
    (loop [n n s #{}]
      (cond
        (= 1 n) true
        (s n) false
        :else (recur 
                (apply 
                  +
                  (map 
                    (comp (fn [p] (* p p)) read-string str) 
                    (str n))) 
                (conj s n)))))
jarlax's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn happy? [n]
  (let [square #(* % %)
        ctoi #(. Character getNumericValue %)
        sum #(->> (str %)
               (map ctoi)
               (map square)
               (reduce +))
        res (loop [k n l #{}]
              (if (contains? l k)
                k
                (recur (sum k) (conj l k))))]
    (= res 1)))
jedo's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn happy [x]
  (letfn [(happyiter [y]
    (loop [y y sum 0]
      (let [r (rem y 10) q (quot y 10)]
        (if (zero? q) 
            (+ sum (* r r))
            (recur q (+ sum (* r r)))
        )
      )
    )
    )]
  (loop [x x sofar '[]]
    (cond (= x 1) true
          (some #{x} sofar) false
          :else (recur (happyiter x) (conj sofar x))
    )
   )
  )
)
jeff_terrell's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [x]
  (letfn [(digits [x]
            (mapv #(-> % str Integer.)
                  (print-str (str x))))
          (tic [x]
            (reduce +
                    (map #(* % %)
                         (digits x))))
          (get-seq [x]
            (take-while #(not= 1 %)
                        (iterate tic x)))
          (no-dupes? [xs]
            (loop [seen #{}
                   xs xs]
              (if (empty? xs)
                true
                (if (contains? seen (first xs))
                  false
                  (recur (conj seen (first xs)) (rest xs))))))]
    (no-dupes? (get-seq x))))
johncowie's solution:
1
2
3
4
5
6
(fn [n]
  (loop [c n s #{}]
    (cond
     (= c 1) true
     (contains? s c) false
     :else (recur (reduce + (map #(* (read-string (str %)) (read-string (str %))) (str c))) (conj s c)))))
jomicoll's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn happy-numbers [n]
  (let [m {\0 0 \1 1 \2 2 \3 3 \4 4 \5 5 \6 6 \7 7 \8 8 \9 9}
        parse-digits
        (fn [n] (mapv m (str n)))
        sum-of-squares
        (fn [nums]
          (apply + (map #(* % %) nums)))]
    (loop [ret n vists #{} cnt 0]
      (cond
        (= ret 1) true
        (contains? vists ret) false
        :else
        (recur (sum-of-squares (parse-digits ret)) 
               (conj vists ret) (inc cnt))))))
jorendorff's solution:
1
2
3
(let [sosod (fn [n] (->> n (str) (map #(- (int %) 48)) (map #(* % %)) (reduce + 0)))
      first-dup (fn recur [seen [x & xs]] (if (seen x) x (recur (conj seen x) xs)))]
  #(= 1 (first-dup #{} (iterate sosod %))))
jslavin's solution:
1
2
3
4
5
6
7
8
9
10
(fn ishappy? [n]
  (letfn [(split-num [n]  (seq (map #(Integer/parseInt (str %)) (seq (str n)))))
          (square [n] (* n n))
          (happy [n]  (apply + (map square  (split-num n))))] 
    (cond 
      (= n 1) true
      (= n 4) false
      :otherwise (ishappy? (happy n))      
    )
  ))
kohyama's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
  (let [sqs (fn [x] (apply + (map (comp #(* % %) read-string str) (str x))))]
    (->> [[] n]
      (iterate (fn [[a x]]
                 (cond (= x 1) true
                   (some (partial = x) a) false
                   :else [(conj a x) (sqs x)])))
      (drop-while vector?)
      (first))))
kopychenko's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn happy-numbers [x]
  (letfn [(calc [x]
            (apply + (map 
                      (fn [x] (let [x (- (int x) 48)] (* x x) ))
                      (vec (str x)))))]
    
    (loop [x x a #{}]
      (cond (= x 1) true
            (contains? a x) false
            :else (recur (calc x) (conj a x))))
 
    ))
blucas's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn prob86
  ([num] (prob86 num #{}))
  ([num seen]
   (letfn [(nextnum [num]
             (reduce + (map #( * % %) (digit-list num))))
           
           (digit-list [num]
             (map char-to-num (str num)))
           
           (char-to-num [c]
             (- (int c) 48))
           ]
     (if (= 1 num) true
         (if (contains? seen num) false
             (prob86 (nextnum num) (conj seen num)))))))
brendan's solution:
1
2
3
4
5
6
7
8
9
(fn [n] (= 1 (some #{1 20} 
      (iterate
       (fn [n] 
         (->> (str n)
              (map #(Integer/parseInt (str %)))
              (map #(* % %))
              (apply +)))
       
       n))))
kuze's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn myHappyNumbers
  [num]
  (loop [numbers #{} last num]
    (cond 
      (contains? numbers last) false
      (= last 1) true
      :else (recur (conj numbers last) 
                   (->> last 
                     (str) 
                     (map #(Character/digit % 10)) 
                     (map #(* % %)) 
                     (reduce +))))))
lackita's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
  (contains? ((fn happy-group [x s]
                (let [new-x (apply + 
                                   (map #(int (Math/pow (Integer/parseInt (str %)) 2)) 
                                        (str x)))]
                  (if (s new-x)
                    s
                    (happy-group new-x (conj s new-x)))))
              n #{n}) 1))
lambda4fun's solution:
1
2
3
4
5
6
7
8
9
10
11
#(letfn [(char->digit [c] (- (int c) 48))
         (square [x] (* x x))]
   (loop [x %
          appeared-nums #{}]
     (cond
      (= x 1) true
      (appeared-nums x) false
      :else (recur (->> (str x)
                        (map (comp square char->digit))
                        (apply +))
                   (conj appeared-nums x)))))
lasthemy's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [n]
  (loop [nums #{} x n]
    (cond
     (= x 1) true
     (contains? nums x) false
     :else (recur
            (conj nums x)
            (reduce
             #(+ %1 (let [y (read-string (str %2))] (* y y)))
             0
             (str x)
             )
            )
     )
    )
  )
lbarrett's solution:
1
2
3
4
5
6
7
8
9
10
(letfn [(step [x]
               (apply + (map (comp #(* % %) #(- % (int \0)) int)
                             (str x))))]
  (fn [x]
    (loop [i1 x
           i2 (step x)]
      (cond
        (= i2 1) true
        (= i1 i2) false
        :else (recur (step i1) (step (step i2)))))))
leetwinski's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n]
  (let [nxt (fn [n]
              (reduce 
                #(let [n (Integer. (str %2))] (+ %1 (* n n)))
                0
                (str n)))]
    (loop [c [] nn n]
      (cond
        (= nn 1) true
        (some #(= nn %) c) false
        :else (recur (conj c nn) (nxt nn))))))
littlejp2046's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn happy 
  ([nb] (happy nb #{}))
  ([nb res]
    (let 
      [r (int (reduce + 
        (map #(Math/pow (- (int %) 48) 2) (seq (str nb)))))]
      (if (= 1 r)
        true
        (if (contains? res r)
          false
          (happy r (conj res r)))))))
malvert's solution:
1
2
3
4
5
6
(fn [a] (loop [d a v #{1} s #(* % %)]
  (if (v d) 
    (= d 1) 
    (recur 
      (reduce + (map #(s (- (int %) 48)) (str d))) 
      (conj v d) s))))
matiasl's solution:
1
2
3
4
5
6
7
8
9
10
(fn happy? [n] 
  (let [h (fn [x] 
            (apply + 
                   (map #(* % %) 
                        (map #(Character/digit % 10) 
                             (str x)))))] 
    (case n 
      1 true 
      4 false 
      (happy? (h n)))))
maximental's solution:
1
2
3
4
5
6
7
(fn [m]
  (= 1 
     (some #{1 4}
           (iterate (fn [k] (reduce #(+ % (let [c (- (int %2) 48)] (* c c))) 
                                    0
                                    (str k))) 
                    m))))
mbakhterev's solution:
1
(fn R ([n] (R n #{})) ([n V] (cond (= 1 n) true (V n) false :else (R (reduce #(let [x (- (int %2) 48)] (+ % (* x x))) 0 (str n)) (conj V n)))))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn happy?
  [n] {:pre [(integer? n), (pos? n)]}
 
  ;; We begin by defining some helper functions.
  (let [
        ;; First we have a squaring function, just for convenience.
        sq (fn [x] (* x x))
 
        ;; Next, we have the function f. This is the iterator used in the
        ;; definition of a happy number; that is, f takes a positive integer n
        ;; and returns the sum of the squares of the digits of n.
        f (fn [n]
            (loop [acc 0, n n]
              (if (< n 1)
                (+ acc (sq n))
                (recur (+ acc (sq (mod n 10)))
                       (quot n 10)))))]
 
    ;; For the main body of the function, we loop through the iterates of f
    ;; until we either find a 1 (indicating that n is happy) or find a number
    ;; we've already seen (indicating that the sequence repeats and n is
    ;; unhappy).
    (loop [seen #{}, [i & tail] (iterate f n)]
      (cond
        (= i 1)   true
        (seen i)  false
        :else     (recur (conj seen i) tail)))))
mfikes's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [n]
  (letfn [(digits [n]
                  (if (< n 10)
                    [n]
                    (conj (digits (quot n 10)) (rem n 10))))
          (sum-squared [v]
                       (apply + (map * v v)))
          (happy* [n tried]
                  (let [n' (sum-squared (digits n))]
                    (println n')
                    (if (tried n')
                      false
                      (if (= 1 n')
                        true
                        (recur n' (conj tried n))))))]
    (happy* n #{})))
minitrue's solution:
1
2
3
4
5
6
(fn [x]
  (let [y (->> x str (map (comp #(* % %) read-string str)) (apply +))]
    (cond
      (= y 1) true
      (= y 42) false
      :else (recur y))))
mkahn's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn happy? [n]
     (loop [terms [n]]
       (if (== (peek terms) 1)
         true
         (if (some #{(peek terms)} (pop terms))
           false
           (recur (conj terms (apply + (map #(* % %)
                                            ((fn f [q]
                                               (if (< q 10)
                                                 (vector q)
                                                 (conj (f (/ (- q (mod q 10)) 10)) (mod q 10)))) (peek terms))))))))))
mobiusloop's solution:
1
2
3
4
5
6
7
8
(fn g
    ([m l]
     (let  [n (apply + (map #(int (Math/pow (mod % 10) 2))
                            (take-while #(not (= % 0)) (iterate #(int (/ % 10)) m))))]
       (if (= 1 n) true (if (some #(= n %) l) false (g n (cons n l))))
       )
     )
    ([m] (g m [])))
mononite's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
  (letfn [(digits [n] (loop [acc () n n] (if (< n 10) (conj acc n) (recur (conj acc (mod n 10)) (quot n 10)))))
          (square-sum [xs] (->> xs (map #(* % %)) (reduce +)))]                 
    (loop [n n coll #{}]
      (let [ss (square-sum (digits n))]
        (cond
         (= ss 1) true
         (contains? coll ss) false
         :else (recur ss (conj coll ss)))))))
mouse's solution:
1
2
3
4
5
#(= 1
    (nth (iterate
          (fn [n] (apply + (map (zipmap "0123456789" (map * (range)(range))) (str n))))
          %)
         9))
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn happy? [x]
  (letfn
      [(digits [n]
         (loop [res '() n n]
           (if (zero? n)
             res
             (recur (conj res (rem n 10))
                    (quot n 10)))))]
    (loop [x x]
      (let [n (->> (digits x)
                   (map #(*' % %))
                   (reduce +'))]
        (cond (= n 1) true
              (= n 4) false
              :else (recur n))))))
nagi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn happy? [n]
  (letfn [(split-square-sum [n]
            (->> n
                 (str)
                 (map #(int %))
                 (map #(- % 48))
                 (map #(* % %))
                 (reduce +)))]
    (if (= n 4)
      false
      (if (= n 1)
        true
        (happy? (split-square-sum n))))))
nikelandjelo's solution:
1
2
(fn [n]
(= 1 (nth (iterate (fn [n] (->> (str n) (map #(Character/digit % 10)) (map #(* % %)) (apply +))) n) 100)))
noiseehc's solution:
1
(fn [start] (= true (some #(= 1 %) (take 100 (iterate (fn [x] (reduce + (map #(let [n (- (int %) 48)] (* n n)) (str x)))) start)))))
norman's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn happy [n]
  (letfn [(sumsquare [n]
         (loop [current n sum 0]
           (if (= current 0)
             sum
            (let [digit (mod current 10)]
               (recur (/ (- current digit) 10) (+ sum (* digit digit)))))))]
    (loop [current n seen #{}]
      (cond
       (= current 1) true
       (seen current) false
       :else (recur (sumsquare current) (conj seen current))))))
nothsaevets's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n]
   (let [get-next (fn [n] (->> n
                               (str)
                               (map #(Integer/parseInt (str %)))
                               (map #(* % %))
                               (apply +)))]
     (loop [n n visited #{}]
       (cond
         (visited n) false
         (= 1 n) true
         :else (recur (get-next n) (conj visited n))))))
owk4057's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn myf2 [n]
  (letfn [(sq-sum [n]
            (->> (str n)
              vec
              (map #(Math/pow (- (int %) 48) 2))
              (apply +)
              int))]
    (loop [n n, coll #{}]
      (cond (= (sq-sum n) 1) true
        (contains? coll (sq-sum n)) false
        :else (recur (sq-sum n) (conj coll (sq-sum n)))))))
ownwaterloo's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [n]
  (->> (iterate
         (fn [x]
           (->> (iterate #(* 10 %) 1)
             (map #(quot x %))
             (take-while #(> % 0))
             (map #(rem % 10))
             (map #(* % %))
             (apply +)))
         n)
    (reductions
      (fn [acc x]
        (cond
          (== 1 x) true
          (acc x) false
         :else (conj acc x)))
      #{})
    (drop-while coll?)
    first))
ozan's solution:
1
2
3
4
5
6
7
8
9
(fn happy                                                                                                        
  ([n] (happy n []))                                                                                                
  ([n seen]                                                                                                         
   (let [calc (reduce + (map (comp #(* % %) #(Integer/parseInt %) str) (str n)))]                                   
     (if (= 1 calc)                                                                                                 
       true                                                                                                         
       (if (contains? seen calc)                                                                                    
         false                                                                                                      
         (happy calc (into [] (cons n seen))))))))
pukeface's solution:
1
2
3
4
5
6
7
8
9
10
(let [iter (fn i [n]
               (if (< n 10)
                   (* n n)
                   (+ (i (mod n 10)) (i (quot n 10)))))
      iters (fn [n] (iterate iter n))
      some-cycle (fn [s]
                     (some #(when (= (first %) (last %)) (first %))
                           (map vector (drop 1 s) (mapcat (partial repeat 2) s))))
                   ]
                 (comp (partial = 1) some-cycle iters))
quant1's solution:
1
2
3
(letfn [(seq-n [x n] (loop [c () v x] (if (< v n) (conj c v) (recur (conj c (mod v n)) (quot v n)))))
        (hnn [x] (->> (seq-n x 10) (map #(* % %)) (apply +)))]
   (fn [x] (loop [c #{} v x] (if (c v) (= 1 v) (recur (conj c v) (hnn v))))))
rodmax's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [x]
  (letfn [(sumsq [n] (
            ->> n
            str
             (map #(let [v ( Character/getNumericValue %)] (* v v)) )
             (reduce +)
            ))]
    (loop [ss (sumsq x)]
      (case ss
        1 true
        4 false
        (recur (sumsq ss))
        )
      ))
  )
sbondaryev's solution:
1
2
3
4
5
6
7
8
(letfn [(digits[n] (map #(- (int %) (int \0)) (str n)))]
  (fn [n]
    (loop [n n seen #{}]
      (cond
        (= n 1) true
        (seen n) false
        :else (recur (reduce #(+ %1 (* %2 %2)) 0 (digits n))
                     (conj seen n))))))
shiro's solution:
1
2
3
4
5
(fn is-happy [n]
  (letfn [(to-chars [n] (reduce #(conj %1 (Character/getNumericValue %2)) [] (str n)))
          (happy-step [n] (reduce #(+ %1 (* %2 %2)) 0 (to-chars n)))
          (gen-happy [n] (cons n (lazy-seq (gen-happy (happy-step n)))))]
    (contains? (reduce #(conj %1 %2) #{} (take 100 (gen-happy n))) 1)))
sheldon's solution:
1
(fn [y] (= 1 (last (take 10 (iterate #(apply + (for [n (for [m (vec (str %))] (- (int m) 48))] (* n n))) y)))))
silverio's solution:
1
2
3
4
5
6
7
8
#(loop [n % s #{}]
  (cond (s n) false, (= 1 n) true, :else
    (recur
      (loop [p n v 0]
        (if (zero? p) v
          (let [m (mod p 10)]
            (recur (quot p 10) (+ v (* m m))))))
      (conj s n))))
skyrem's solution:
1
2
3
4
5
6
7
(fn [n]
  (letfn [(happy [nn]
                 (apply + (map (comp #(* % %) read-string str) (str nn))))]
    (cond
     (= 1 (happy n)) true
     (= 4 (happy n)) false
     :else (recur (happy n)))))
soul_awaker's solution:
1
2
3
4
5
6
(fn f
  ([n] (f n #{}))
  ([i r]
    (let [e (apply + (map #(* % %) (map #(Long/valueOf %)
              (re-seq #"\d" (str i)))))]
    (if (= e 1) true (if (r e) false (f e (conj r e)))))))
staafl2's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(letfn
  [
  (digits [n]
    (let [[ds n]
      (last (take-while
        (comp (complement zero?) second)
        (iterate
          (fn [[ds n]] [(conj ds (mod n 10)) (int (/ n 10))])
          [[] n])))]
      (conj ds n)))
 
  (step [n]
    (let [ds (digits n)]
      (->> ds (map #(* % %)) (reduce +))))
 
  (is-happy [n]
    (let [[seen now]
      (first (drop-while
        (fn [[seen now]] (not (or (seen now) (= 1 now))))
        (take 1000 (iterate
          (fn [[seen now]] [(conj seen now) (step now)])
          [#{} n]))))]
      (= now 1)))]
  is-happy)
syeerzy's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (letfn [(cmpt [[& nums]] (reduce + (map * nums nums)))
          (splt [integer] (map #(read-string (str %)) (str integer)))]
    (loop [parm n
           cache []]
      (if (some #{parm} cache)
        (= parm 1)
        (recur (cmpt (splt parm)) (conj cache parm))))))
tclamb's solution:
1
2
3
4
5
6
7
< 5
;(fn happy? [n]
;  (loop [n n s #{n}]
;    (let [n (reduce + (mapv (comp #(* % %) #(- (int %) (int \0))) (str n)))]
;      (if (s n)
;        (= 1 n)
;        (recur n (conj s n))))))
thegeez's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [n]
    (let [digit-sum (fn [n] (loop [r n
                                   ds 0]
                              (if (zero? r)
                                ds
                                (let [m (mod r 10)]
                                  (recur (/ (- r m) 10)
                                         (+ ds (* m m)))))))]
      (loop [sum (digit-sum n)
             seen #{n}]
        (if (= sum 1)
          true
          (if (seen sum)
            false
            (recur (digit-sum sum)
                   (conj seen sum)))))))
zzamboni's solution:
1
2
3
4
5
6
(fn happy-number? [n]
  (letfn [(sum-square-digits [n] (apply + (map (comp #(* % %) read-string str) (seq (str n)))))]
    (loop [cur (sum-square-digits n) seen (hash-set n)]
      (cond (= cur 1)  true
            (seen cur) false
            :else      (recur (sum-square-digits cur) (conj seen cur))))))
zoltanjarai's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [n]
  (letfn [(f [x xs]
             (cond (= x 1) true
                   (contains? xs x) false
                   :else (recur
                          (->> (str x)
                               (map #(Character/digit % 10))
                               (map #(* % %))
                               (reduce +))
                          (conj xs x))))]
    (f n #{})))
zipzop's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [x]
  (cond
   (= 1 x) true
   ; All non-happy numbers follow sequences that reach the cycle:
   ;   4, 16, 37, 58, 89, 145, 42, 20, 4, ...
   (= 4 x) false
   :else (letfn [(sq [y] 
               (if (< y 10) 
                 (* y y) 
                 (+ (* (rem y 10) (rem y 10)) (sq (quot y 10)))))]
               (recur (sq x)))
  )
)
yusubori's solution:
1
2
3
4
5
6
(fn [n]
  (let [f (fn [x] (apply + (map (comp #(* % %) read-string str) (str x))))]
    (loop [y (f n) seen #{}]
      (if (contains? seen y)
        (if (= 1 y) true false)
        (recur (f y) (conj seen y))))))
ydash's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (loop [i n a {}]
    (cond (= i 1) true
          (a i) false
          :else (recur
                 ((fn [n] (apply + (map (comp #(* % %) read-string)
                                        (re-seq #"\d" (str n))))) i)
                 (conj a [i i])))))
vpeurala's solution:
1
2
3
4
5
6
7
8
(fn [n]
    (letfn [
        (to-digits [n] (map #(Integer/parseInt %) (map str (str n))))
        (formula [n] (reduce + (map #(* % %) (to-digits n))))
        (one-round [n already-encountered] (cond (contains? already-encountered n) false (= 1 n) true :else (one-round (formula n) (conj already-encountered n))))
        (happy-number? [n] (one-round n #{}))
        ]
        (happy-number? n)))
v_bogdanov's solution:
1
2
3
4
5
6
7
8
9
(fn happy? [n]
(letfn [(n-v [n] (map (comp read-string str) (str n)))
        (main [n st]
              (let [nn (apply + (map * n n))
                    nst (into st [nn])]
                (if (= 1 nn) true
                  (if (= st nst) false
                    (main (n-v nn) nst)))))]
  (main (n-v n) (set [n]))))
unionx's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [x]
  (letfn [(square [n]
                  (bigint (Math/pow n 2)))
          (happy [n]
                 (apply + (map #(square (bigint (str %))) (str n))))]
    (loop [not-happy #{} start x]
      (let [t (happy start)]
        (cond
          (= t 1) true
          (not-happy t) false
          :else (recur (conj not-happy start) t))))))
trxeste's solution:
1
2
3
4
5
6
(fn happy? [n]
  (letfn [(digits [n]
            (map #(Integer/parseInt (str %)) (str n)))
          (sum-of-squares [n]
            (reduce + (map #(* % %) (digits n))))]
    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))
transfinite's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [n]
  (letfn [(hap-step [n]
            (apply +
                   (map #(* % %)
                        (map #(Integer. (str %)) (str n)))))]
    (loop [ a n
           as #{a}]
      (if (= 1 a)
        true
        (let [a (hap-step a)]
          (if (as a)
            false
            (recur a (conj as a))))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)