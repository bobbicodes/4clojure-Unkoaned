;; 91 Graph Connectivity [h]

Given a graph, determines whether the graph is connected.
A connected graph is such that a path exists between
any two given nodes.

Returns true if the graph is connected and false otherwise.

We have a set of tuples representing the edges of a graph.
Each member of a tuple being a vertex/node in the graph.

-Each edge is undirected (can be traversed either direction). 
(= true (__ #{[:a :a]}))
(= true (__ #{[:a :b]}))
(= false (__ #{[1 2] [2 3] [3 1]
               [4 5] [5 6] [6 4]}))
(= true (__ #{[1 2] [2 3] [3 1]
              [4 5] [5 6] [6 4] [3 4]}))
(= false (__ #{[:a :b] [:b :c] [:c :d]
               [:x :y] [:d :a] [:b :e]}))
(= true (__ #{[:a :b] [:b :c] [:c :d]
              [:x :y] [:d :a] [:b :e] [:x :a]}))

(fn fully-connected? [graph]
  (let [nodes (set (apply concat graph))
        full-graph (set (mapcat (fn [[a b :as n]] [n [b a]]) graph))
        children (into {} (for [[k v] (group-by first full-graph)] [k (set (map second v))]))
        connections (fn [node]
                      (->> (iterate #(into % (mapcat children %)) #{node})
                           (partition 2 1)
                           (drop-while #(apply not= %))
                           first first))]
    (every? #(= % nodes) (map connections nodes))))
(fn [edges]
   (let [adj-list (reduce (fn [agg [x y]]
                            (merge-with into agg (into {} [[x #{y}] [y #{x}]]))) {}
                          edges)
         vs (into #{} (keys adj-list))
         linked-cmp (fn ch [v adj-list visited]             
                      (if (empty? adj-list)
                        visited
                        (->> (for [v-adj (adj-list v)
                                  :when (not (visited v-adj))]
                               (ch v-adj (dissoc adj-list v) (into visited [v v-adj])))
                             (reduce into visited))))]
     
     (-> vs first
         (linked-cmp adj-list #{})
         (= vs))))

(fn
  ff
  ([s]
   (if (= 1 (count s))
     true
     (ff [(first s)] (rest s))))
  ([f r]
   (let [tr (mapcat #(filter (fn [x] (or (= (first x) (second %)) (= (second x) (first %)) (= (first x) (first %)) (= (second x) (second %)))) r) f)]
     (if (and (empty? tr) (empty? r))
       true
       (if (and (empty? tr) (not (empty? r)))
         false
       (recur tr (remove #(some (fn [x] (= % x)) tr) r)))))))

(fn [edgeSet]
 (let [nodeSet (set (flatten (seq edgeSet)))];get the node set
   (loop[connectivity (for [[n1 n2] edgeSet] [#{n1}, n2])];inital connectivity where the first element is the visited nodes
     (let[extendedConnectivity (for [[linked node] connectivity, [n1 n2] edgeSet :when (and (or (= n1 node) (= n2 node)) (or (nil? (linked n1)) (nil? (linked n2))))]
                                 [(conj linked n1 n2) (if (= node n1) n2 n1)])];extend the connectivity when a newly linked node is found
       (if (not-any? #(= nodeSet %) (map first connectivity));if not a fully connected graph is found
         (if (empty? extendedConnectivity) false;and no extended connectivity can be found either
           (recur extendedConnectivity));extend the connectivity
         true)))));a fully connected graph is found

(fn f [edges]
  (let [
    maps (map #(list (hash-map (first %) (rest %)) (hash-map (last %) (butlast %))) edges)
    all (apply merge-with concat (flatten maps))
    reachable (fn [self seen start]
      (flatten
        (cons start 
          (for [node (all start) :when (not (seen node))]
            (self self (assoc seen node 1) node)))))
  ]
    (or (= 1 (count edges))
      (= (set (keys all)) (set (reachable reachable {} (key (first all))))))))
aceeca1's solution:

1
2
3
4
5
6
7
8
9
10
(fn [x] (letfn [
    (adjlist [e] (let [
        ee (concat e (map reverse e))
        ve (group-by first ee)]
        (into {} (for [[k v] ve] [k (map second v)]))))
    (connected? [g] (letfn [
        (add-vertex [s v] (if (s v) s 
            (reduce add-vertex (conj s v) (g v))))]
        (= (count (add-vertex #{} (ffirst g))) (count g))))]
    (connected? (adjlist x))))
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [edge-set]
  (let [all-nodes (reduce (fn [acc pair] (-> acc
                                             (conj (first pair))
                                             (conj (second pair))))
                          #{} edge-set)
        reachable-from-node (fn [node]
                              (reduce (fn [acc pair] (cond
                                                      (= node (first pair)) (conj acc (second pair))
                                                      (= node (second pair)) (conj acc (first pair))
                                                      :else acc))
                                      #{} edge-set))
        reachable-from-set (fn [nodes]
                             (reduce clojure.set/union nodes (map reachable-from-node nodes)))
 
        ]
    (loop [reached #{(first all-nodes)}]
      (let [reachable (reachable-from-set reached)]
        (cond
         (= all-nodes reachable) true
         (= reached reachable) false
         :else (recur reachable))))))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
(fn connectedX[nodes]
    (letfn [
        (connectedSimple [a b]
            (or 
                (= (first a)(first b))
                (= (first a)(last b))
                (= (last a)(first b))
                (= (last a)(last b))
            )
        )
 
 
        (connectedTransitive [a b c nodes]
            (and
                (connected2 a c nodes)
                (connected2 b c nodes)
            )
        )
 
        (ors[x]
            (if (empty? x)
                false
                (reduce (fn[a b] (or a b)) x)
            )
        )
 
 
        (ands[x]
            (if (empty? x)
                false
                (reduce (fn[a b] (and a b)) x)
            )
        )
 
        (connected2 [a b nodes]
            (or 
                (connectedSimple a b) 
                (ors (map (fn[c] (connectedTransitive a b c (disj nodes c))) nodes))
            )
        )
 
        (connected[nodes]
            (ands 
                (for [a nodes b nodes]
                    (if (= a b)
                        true
                        (connected2 a b (clojure.set/difference nodes #{a b}))
                    )
                )
            )
        )
        ]
        (ands 
            (for [a nodes b nodes]
                (if (= a b)
                    true
                    (connected2 a b (clojure.set/difference nodes #{a b}))
                )
            )
        )
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
(fn connected? [graph]
  (loop [g graph
         parsed #{(first (first graph))}]
    (if (nil? g) true
      (let [spanned-g (group-by (fn [[from to]] (or (contains? parsed from) (contains? parsed to))) g)
            filtered-rest (spanned-g false)
            filtered-out (spanned-g true)
            new-parsed (into parsed (flatten filtered-out))]
        (if (= filtered-rest g) false
          (recur filtered-rest new-parsed))))))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [gr]
  (letfn [(share? [c1 c2] (some #(or (= (first c2) %) (= (last c2) %)) c1))
          (sharers [c1 cs2] (filter #(share? c1 %) cs2))
          (non-sharers [c1 cs2] (remove #(share? c1 %) cs2))
          (add-sharers [c1 cs2] (set (concat c1 (apply concat (sharers c1 cs2)))))
          (connected? [g]
            (loop [res (first g) leftover (rest g)]
              (if (empty? leftover)
                true
                (if (and (= (add-sharers res leftover) res) (empty? (sharers res leftover)))
                  false
                  (recur (add-sharers res leftover) (non-sharers res leftover))))))]
    (connected? gr)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn f [g]
  (let [expand-graph (fn expand-graph [g]
                       (let [rev-g (map #(apply hash-map [(second %) [(first %)]]) g)
                             gm (map #(apply hash-map [(first %) [(second %)]]) g)]
                         (reduce (fn [col x]
                                   (merge-with concat col x))
                                 (concat rev-g gm))))
        traverse     (fn traverse [visited n eg]
                       (let [all-children (eg n)
                             not-visited  (filter #(not (visited %)) all-children)
                             visited'     (conj visited n)
                             _ (println n visited all-children not-visited)]
                         (if (not-empty not-visited)
                           (mapcat #(traverse visited' % eg) not-visited)
                           (do (println "Returning" visited')
                               visited'))))
        eg           (expand-graph g)
        n            (first (first eg))
        all-nodes    (set (mapcat concat g))
        visited      (set (traverse #{} n eg))]
    (println eg all-nodes visited)
    (= all-nodes visited)))
andthorn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [vs]
  (let [mk-g (fn [vs g]
                (if vs
                  (let [x (first (first vs))
                        y (second (first vs))
                        f #(update-in %1 [%2] (partial cons %3) )]
                    (recur (next vs) (f (f g x y) y x) ))
                  g))
        g (mk-g vs '{})
        is-con (fn [s]
                 (let [s1 (set(flatten (map (partial get g) s)))]
                   (if (= (count s) (count s1))
                     (= (count s) (count g))
                     (recur s1)
                     )))       ]
    (is-con (set (apply cons(first g)))  )))
anjensan's solution:

1
2
3
4
5
(fn [t]
  (let [g (reduce (fn [z [a b]] (merge-with concat z {a [b]} {b [a]})) {} t)
        h (iterate #(into % (mapcat g %)) #{(ffirst t)})
        [[a _] & _] (drop-while (fn [[a b]] (not= a b)) (map vector h (next h)))]
      (== (count (keys g)) (count a))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn
  [coll]
  (let [m (reduce (fn [m [s d]]
                    (let [ds (get m s #{})
                          ds' (conj ds d)
                          ss (get m d #{})
                          ss' (conj ss s)]
                      (assoc m s ds' d ss'))) {} coll)]
    (letfn [(bfs [q v m]
              (if (seq q)
                (let [h (first q)
                      t (rest q)]
                  (if (contains? v h)
                    (recur t v m)
                    (let [v' (conj v h)]
                      (if (contains? m h)
                        (recur (concat t (m h)) v' m)
                        (recur t v' m)))))
                v))]
      (= (count m) (count (bfs [(first (first coll))] #{} m))))))
austintaylor's solution:

1
2
3
4
5
6
7
8
(fn [s]
  (loop [edges (rest s) nodes (set (first s))]
    (let [parts (group-by (fn [[a b]] (not (nil? (or (nodes a) (nodes b))))) edges)
          in (set (apply concat (parts true))) out (set (parts false))
          newnodes (into nodes in)]
      (cond (empty? out) true
            (= newnodes nodes) false
            true (recur out newnodes)))))
awebb's solution:

1
2
3
4
5
6
7
(fn [e]
  (let [vs    (->> e seq flatten (into #{}))
        find  (fn [s v] (if (contains? s v) (recur s (s v)) v)) 
        union (fn [s [v1 v2]] 
          (let [r1 (find s v1), r2 (find s v2)]
            (if (= r1 r2) s (assoc s r1 r2))))      ]
    (= (dec (count vs)) (count (reduce union {} e)))))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn [edge-list]
 (letfn 
  [(test-intersection [a b]
    ((complement empty?) (clojure.set/intersection a b)))
   (merge-intersecting [coll itm]
    (if
     (some (partial test-intersection itm) coll)
     (set
      (map
       (fn [a]
        (if (test-intersection a itm) (clojure.set/union a itm) a))
       coll))
     (conj coll itm)))
   (merge-nodes [edge-set]
    (let
     [merged
      (reduce
       (fn [acc itm] (merge-intersecting acc itm))
       #{}
       edge-set)]
     (if (= merged edge-set) merged (merge-nodes merged))))]
  (= 1 (count (merge-nodes (set (map set edge-list)))))))
benhammond's solution:

1
2
3
4
5
6
(fn [s]
           (let [m (reduce-kv (fn [m k v] (assoc m k (mapv second v))) {} (group-by first (concat s (map (juxt second first) s))))]
             (loop [unv (set (mapcat identity (drop 1 s))) v (set (first s))]
               (let [nv (set (mapcat #(get m %) v))
                     unv2 (remove nv unv)]
                 (if (= unv unv2) (empty? unv) (recur unv2 nv))))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [edges]
  (let [paths (apply merge-with into
                     (mapcat (fn [[a b]]
                               [{a #{b}}
                                {b #{a}}])
                             edges))
        reachable (nth (iterate (fn [reach]
                                  (into {}
                                        (map (fn [[k v]]
                                               [k (into v (mapcat #(get reach % #{}) v))])
                                             reach)))
                                (into paths (map (fn [[k v]] [k (conj v k)]) paths)))
                       (count edges))]
    (= (first (vals reachable)) (set (keys reachable)))))
bobuhiro11's solution:

1
2
3
(fn [g] 
     (= (into #{} (flatten (vec g)))
        (nth (iterate #(into #{} (flatten (for [e g] (if (or (% (e 0)) (% (e 1))) e)))) #{((first g) 0)}) (count g))))
burner's solution:

1
2
3
4
5
6
7
8
9
10
(letfn [(component [sets v]
                (or (some #(if (% v) %) sets) #{v}))
              (update-components [sets [v1 v2]]
                (let [c1 (component sets v1)
                      c2 (component sets v2)]
                  (conj (remove #(or (= % c1) (= % c2)) sets)
                        (clojure.set/union c1 c2))))
              (components [vs]
                (reduce update-components #{} vs))]
        (fn [x] (= (count (components x)) 1)))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
#(let [numOfNodes (count (set (apply concat %)))
       undirectGraph (fn [g]
                       (apply clojure.set/union (for[[a b] g]
                                                  (set (list [a b] [b a])))))
       growGraph (fn [g]
          (let [ng (into g (set (concat (for[ [a b] g [c d] g :when (= b c)]
                                  [a d]))))]
            (if (= g ng) ng (recur ng))))]
   (= (* numOfNodes numOfNodes) (count (growGraph (undirectGraph %)))))
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [nodes]
            ((fn connected-1? [nodes tried]
               (let [next_try (first (clojure.set/difference (first nodes) tried))]
                 (cond (= (count nodes) 1) true
                       (nil? next_try) false         ; cann't go any further
                       :else
                       (recur (reduce (fn [acc e]
                                        (if (e next_try)
                                          (cons (clojure.set/union (first acc) e)
                                                (rest acc))
                                          (conj (vec acc) e))
                                        ) [#{}] nodes)
                              (conj tried next_try)))))
             (map set nodes) #{}))
chunchangshao's solution:

1
2
3
4
5
6
#((fn graph-con [gs] 
    (if (= 1 (count gs)) 
      true 
      (letfn [(v-inc? [g] ((complement empty?) (clojure.set/intersection (first gs) g)))] 
        (let [bg (filter v-inc? (rest gs)) gs (remove v-inc? (rest gs))] 
          (if (empty? bg) false (graph-con (cons (reduce clojure.set/union bg) gs))) )))) (map set %))
ctzsm's solution:

1
2
3
4
5
6
7
(fn [s]
  (let [o (set (apply concat (for [e s] (vector (first e) (second e)))))
        m (zipmap o (range))
        os (sort #(if (= (m (first %)) (m (first %2))) (< (m (second %)) (m (second %2))) (< (m (first %)) (m (first %2)))) s)]
    (= o (clojure.set/intersection o 
                                   (reduce #(set (remove nil? (concat % (for [x %] (cond (= x (first %2)) (second %2)
                                                                            (= x (second %2)) (first %2)))))) #{(ffirst os)} os)))))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn connected? [graph] 
  (= (-> graph seq flatten set)
     (nth (iterate
           #(set
             (flatten
              (for [edge graph]
                (if (or (-> edge second %)
                        (-> edge first %))
                  edge))))
                  #{(-> graph first first)})
          (count graph))))
daniels's solution:

1
2
3
4
5
6
7
8
9
(fn [x]
  (loop [a (rest x) b (into #{} (first x)) f #{}]
    (if (and (or (empty? a) (nil? a)) (empty? f))
      true
      (if (or (empty? a) (nil? a))
        false
        (if (or (contains? b (first (first a))) (contains? b (last (first a))))
          (recur (concat f (rest a)) (into #{} (conj b (first (first a)) (last (first a)))) #{})
          (recur (rest a) b (conj f (first a)) ))))))
daowen's solution:

1
2
3
4
5
6
(fn connected? [edges]
  (= (set (apply concat edges))
     (loop [vs #{(ffirst edges)}]
       (if-let [nvs (seq (for [[a b] edges :when (and (vs a) (not (vs b)))] b))]
         (recur (into vs nvs))
         vs))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [graph]
 (let [connect (fn [r g](first (for [[s e] g :when (some #(let [[s2 e2] %] (or (= s s2)(= s e2)(= e s2)(= e e2))) r)][s e])))]
  (let [ connect_graph (loop [r [(first graph)] g (disj graph (first graph))]
    (if (empty? g)r
      (let [cnode (connect r g)]
         (if (empty? cnode) r
           (recur (conj r cnode) (disj g cnode))
         )
      )
    )
  )]
   (= (count graph) (count connect_graph)))
 )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [edges]
  (letfn [(getij [cm i j] (nth (nth cm i) j))
          (setij [cm i j newv] (assoc (vec cm) i (assoc (vec (nth cm i)) j newv)))
          (markcon [cm i j] (setij (setij cm i j 1) j i 1))]
    (let [vedges (vec edges)
          nodes (distinct (flatten (seq edges)))
          n (count nodes)
          nindexmap (zipmap nodes (range n))
          startm0 (map #(assoc (vec (repeat n -1)) % 1) (range n))
          startm (reduce (fn [mat edge] 
                           (let [i (nindexmap (first edge)) j (nindexmap (second edge))]
                             (markcon mat i j))) startm0 vedges)
          endm (reduce (fn [mat [k i j]] 
                         (if (and (not= -1 (getij mat k i)) (not= -1 (getij mat k j))) 
                           (markcon mat i j) mat))
                       startm (for [k (range n) i (range n) j (range n)] [k i j]))]
      (empty? (filter #(= % -1) (first endm)))
      )))
devm33's solution:

1
2
3
4
5
6
7
8
9
10
(fn connected? [adjlist]
  (if (<= (count adjlist) 1)
    true
    (loop [conn (set (first adjlist)) xs (rest adjlist)]
      (if (empty? xs)
        true
        (let [cut ((juxt filter remove) #(some (partial contains? conn) %) xs)]
          (if (empty? (first cut))
            false
            (recur (reduce (partial apply conj) conn (first cut)) (second cut))))))))
dwelte's solution:

1
2
3
4
5
6
7
(fn conn [s]
  (let
    [m (some #(if (not= (first %) (second %)) %) s)]
    (if m
      (let [r (fn [v] (if (= v (first m)) (second m) v))] 
        (conn (set (map #(vector (r (first %)) (r (second %))) s))))
      (= (count s) 1))))
dzholev's solution:

1
2
3
4
5
6
7
8
9
(fn [s]
  (let [edges (into s (map reverse s))
        edge-map (group-by first edges)
        nodes (set (keys edge-map))
        traverse (fn traverse [visited node]
                   (if (contains? visited node)
                     []
                     (into #{node} (mapcat #(traverse (conj visited node) (second %)) (edge-map node)))))]
    (= nodes (traverse #{} (first nodes)))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [v]
    (let [  g-assoc (fn [m k v] (assoc m k (set (conj (m k) v))))
            g (reduce (fn [m [a b]] (g-assoc (g-assoc m a b) b a)) {} v)]
    ((fn [m1 m2]
           (if (= m1 m2)
                (if (= (set (keys m1)) (second (first m1)))
                    true
                    false)
                (recur 
                    m2
                    (reduce (fn [m [k kv]] 
                        (let [ch (mapcat m kv)]
                            (println ch)
                            (reduce #(g-assoc %1 k %2) m ch)))
                        m2 m2))
                ))
        {} g)
        ))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(letfn [                                                                                                                                                
    (get-nodes [edges] (-> edges vec flatten set (zipmap (range))))                                                             
    (square-matrix [size] (map (fn [_] (repeat size 99)) (range size)))                                                                                 
    (set-ij [m i j v]                                                                                                           
        (let [row (nth m j)                                                                                                                             
              row- (concat (take i row) [v]  (nthnext row (inc i)))]                                                            
            (concat (take j m) [row-] (nthnext m (inc j)))))                                                                                            
    (get-ij [m i j] (-> m (nth j) (nth i)))                                                                                     
    (transitive-closure [edges] (let [                                                                                                                  
        nodes (get-nodes edges)                                                                                                 
        node-count (count nodes)                                                                                                                        
        graph (-> (square-matrix node-count)                                                                                    
                  (#(reduce (fn [m [a b]] (set-ij m (nodes a) (nodes b) 1)) % edges))                                                                   
                  (#(reduce (fn [m [a b]] (set-ij m (nodes b) (nodes a) 1)) % edges))                                           
                  (#(reduce (fn [m i] (set-ij m i i 0)) % (range node-count))))                                                                         
        distance (reduce                                                                                                        
                      (fn [m [i j k]] ; this is the floyd-warshall algorithm                                                                            
                          (let [ij (get-ij m i j) ik (get-ij m i k) kj (get-ij m k j)]                                          
                              (if (< (+ ik kj) ij)                                                                                                      
                                  (set-ij m i j (+ ik kj))                                                                      
                                  m)))                                                                                                                  
                      graph                                                                                                     
                      (for [k (range node-count) i (range node-count) j (range node-count)] [i j k]))]                                                  
            distance))                                                                                                          
    (is-reachable? [s] (not-any? (partial = 99) (flatten (transitive-closure s))))]                                                                     
        is-reachable?)
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(letfn [(connected? [a b]
          (reduce (fn [acc x]
                    (or acc (< -1 (.indexOf b x))))
                  false a))
        (connected-in? [graph node]
          (reduce #(or %1 (connected? node %2)) false graph))
        (path-to-any? [connected not-visited]
          (if (seq not-visited)
            (some true?
                  (map #(when (connected-in? connected %)
                          (path-to-any? (conj connected %) (disj not-visited %)))
                       not-visited))
            true))]
  (fn [graph]
    (let [conn (first graph)]
      (true? (path-to-any? #{conn} (disj graph conn))))))
finsternis's solution:

1
2
3
4
5
6
7
8
9
10
(fn [es]
  (let [nodes (set (apply concat es))
        es' (filter (fn [[u v]] (not= u v)) es)
        edges (set (into es' (for [[u v] es'] [v u])))]
    (= (* (count nodes) (dec (count nodes)))
       (count
        (loop [cur edges]
          (let [addl (for [[u v] cur [w x] cur :when (and (= v w) (not= u x))] [u x])
                nxt (set (into cur addl))]
            (if (= nxt cur) nxt (recur nxt))))))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn graph-connect
  ([s] 
    (let [el (distinct (flatten (seq s)))]
      (every?
        #(graph-connect (first %) (second %) s)
          (for [i el j el] [i j]))))
  ([a b s]
    (letfn [(any? [f s] ((comp boolean some) f s))
            (includes? [s a] (any? (partial = a) s))
            (rm-one [s a] 
                (concat 
                  (remove (partial = a) s) 
                  (rest (filter (partial = a) s))))]
    (if (= a b)
    true
    (if (empty? s)
      false
      (let [next (filter #(includes? % a) s)]
        (if (empty? next)
          false
          (any?
            #(graph-connect 
              (if (= (second %) a) (first %) (second %))
              b
              (rm-one s %))
            next))))))))
garyxia's solution:

1
2
3
4
5
6
7
8
(fn [graph]
  (let [vertices (set (apply concat graph))]
    (letfn [(vertex-connectness [vertex searched-vertex graph]
              (let [adjacent-vertices (filter #(not (searched-vertex %)) (apply concat (filter #(some #{vertex} %) graph)))]
                (if (seq adjacent-vertices)
                  (set (mapcat #(vertex-connectness % (set (cons % searched-vertex)) graph) adjacent-vertices))
                  searched-vertex)))]
      (every? #(= vertices (vertex-connectness % #{%} graph)) vertices))))
geekerzp's solution:

1
2
3
4
5
6
(fn [s]
    (apply = (vals (reduce
                    (fn [g [a b]]
                      (let [r (clojure.set/union (g a #{a}) (g b #{b}))]
                        (reduce #(assoc % %2 r) g r)))
                    {} s))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [edges]
    (let [union clojure.set/union
          difference clojure.set/difference
          vmap (->> edges
                    (mapcat (fn [[v1 v2]] [{v1 #{v2}} {v2 #{v1}}]))
                    (apply merge-with union))
          traverse
            (fn [vertex]
                (loop [vs (vmap vertex), res #{vertex}]
                    (let [new (difference vs res)]
                        (if (empty? new)
                            res
                            (recur (apply union (map vmap new)) (union res new))
                        ))))
        ]
        (every? #(= (count vmap) (count (traverse %))) (keys vmap))
    ))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn __ [d]
(letfn [(isce [a b]
 (> (count (clojure.set/intersection (into #{} a) (into #{} b))) 0))
(somcon [a ans]
 (not= 0 (count (filter #(true? %) 
   (for [b ans]
     (isce a b))))))    
(getgroup [ds]
 (let [vs (into [] ds)]
  (loop [v vs i 0 n (count vs) acc []]
   (if (= i 0) (recur (rest v) (inc i) n (conj acc (first v)))
    (if (= i n) acc
      (recur (rest v) (inc i) n
             (if (somcon (first v) acc)
             (conj acc (first v))
         acc)))))))
(conup [s]
 (loop [m s acc []]
  (if (empty? m) acc
   (let [ans (getgroup m)]
    (recur (clojure.set/difference m ans)
           (conj acc (distinct (flatten ans))))))))]
  (loop [m (into #{} (conup d)) prevn 0]
    (if (= (count m) prevn)
        (= 1 (count m))
    (recur (into #{} (conup m)) (count m))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn connected? [edges']
  (let [edges (set (remove (partial apply =) edges'))
        nodes (set (mapcat identity edges'))
        connected'?
        (fn connected'? [nodes edges*]
          (println nodes edges*)
          (if (empty? edges*)
            (= 1 (count nodes))
            (let [collapse-edge (first edges*)
                  collapse-node (first collapse-edge)
                  target-node (second collapse-edge)
                  
                  collapsed-edges
                  (->> edges*
                       (filter (partial some (partial = collapse-node)))
                       (map (partial map #(if (= % collapse-node)
                                            target-node
                                            %)))
                       (remove (partial apply =))
                       (map (comp vec sort))
                       (set))]
              (connected'?
               (disj nodes collapse-node)
               (set (concat collapsed-edges
                            (set (remove (partial some (partial = collapse-node))
                                         edges*))))))))]
    (println edges)
    (connected'? nodes edges)))
happycrisis's solution:

1
2
3
4
5
6
7
8
9
(fn [fxpt s]
  (= (reduce into #{} s)
     (fxpt (iterate  #(reduce (fn [s [a b]]
                                (cond (s a) (conj s b)
                                      (s b) (conj s a)
                                      1 s))
                              % s)
                     (set (first s))))))
#(ffirst (filter (fn [[a b]] (= a b)) (partition 2 1 %)))
hisba's solution:

1
2
3
4
5
6
7
8
9
10
(fn cg? [g]
     (let [n (set (mapcat identity g))
           cg (group-by first (set (mapcat (fn [[a b]] [[a b] [b a]]) g)))]
       (loop [loc (first (first g)) tn #{loc} tp {} d (zipmap n (repeat 0))]
         (cond (= (count tn) (count n)) true
               (= (set (mapcat cg tn)) (set (mapcat tp tn))) false
               :else (let [id (d loc)
                           p (nth (cycle (cg loc)) id)
                           n_g (second p)]
                       (recur n_g (conj tn n_g) (merge-with concat tp {loc [p]}) (update-in d [loc] inc)))))))
icamts's solution:

1
2
3
4
5
6
7
8
(fn [g] (let [v (reduce #(into % %2) #{} g)
                      vs (set (map (comp set list) v))
                      connect (fn [vs [e1 e2]]
                                (let [es (filter #(or (% e1) (% e2)) vs)]
                                  (cond (= 1 (count es)) vs
                                    :else (conj (apply disj vs es) 
                                                (into (first es) (second es))))))]
                  (= 1 (count (reduce connect vs g)))))
immo's solution:

1
2
3
4
5
6
7
8
9
(fn [edges]
  (let [nodes (reduce into #{} edges)
        edge-map (reduce (fn [m [x y]] (-> m (update-in [x] conj y) (update-in [y] conj x))) {} edges)] 
    (loop [s #{(first nodes)}]
      (let [new-s (into s (flatten (vals (select-keys edge-map s))))]
        (cond
          (= new-s nodes) true
          (= new-s s) false
          :else (recur new-s))))))
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [graph]
  (let [updated (fn [dict key val]
                  (conj (dict key []) val))
        add-edge (fn [adj [from to]]
                   (into adj [[from (updated adj from to)]
                              [to (updated adj to from)]]))
        adj (reduce add-edge {} graph)
        start (first (first graph))
        desired (count (keys adj))
        not-in #(not (%1 %2))
        neighbors (fn [v vis]
                    (filter (partial not-in vis) (adj v)))]
    (loop [[x & _ :as all] (list start) vis #{}]
      (cond
        (empty? all) (= (count vis) desired)
        :else (recur
                (concat (rest all) (neighbors x vis))
                (conj vis x))))))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn connected? [graph]
  (let [first-node (first graph)
          nodes (rest graph)
          connected-nodes? (fn [[a b] [c d]] (cond (or (= a c) 
                                                       (= a d)
                                                       (= b c)
                                                       (= b d)) true
                                                    :else false))]
        (loop [node first-node found [] nodes nodes]
            (cond (empty? nodes) true
                  (empty? node) (if (empty? found) false
                                    (recur (first found) (rest found) nodes))
                  :else (let [toadd (into #{} (filter #(connected-nodes? node %) nodes))]
                     (recur nil (into #{} (concat toadd found)) (remove toadd nodes))
                  )
            )
        )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [g]
  (letfn [(g->m [g]
            (->> g
                 (group-by first)
                 (map (fn [[node items]]
                        [node (set (map second items))]))
                 (into {})))
          (expand [m]
            (into {}
                  (for [[f ts] m]
                    [f (set (apply concat ts
                                   (for [t ts]
                                     (get m t))))])))]
    (let [g1 (g->m g)
          g2 (g->m (map (comp vec reverse) g))
          m (merge-with #(set (concat %1 %2)) g1 g2)
          size (count m)]
      (= size
         (-> (nth (iterate expand m) size) vals first count)))))
johncowie's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [p]
  (letfn [(conn? [m c e v]
    (cond (= c e) true
          (contains? v c) false
          (empty? (m c)) false
          :else (reduce #(or %1 %2) (flatten (for [n (m c)] (conn? m n e (merge v c)))))))]
      (let [e (apply merge-with concat (map #(hash-map (first %) [(second %)]) (concat p (map reverse p))))
            k (keys e)]
        (if (= (count k) 1)
          true
          (reduce #(and %1 %2) (for [x (rest k)] (conn? e (first k) x #{})))))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn connected? [edges]
  (let [nodes (set (apply concat edges))
        num-nodes (count nodes)
        adjacency-mat
        (reduce (fn [ret [x y :as edge]]
                  (-> (update-in ret [x] conj y)
                      (update-in [y] conj x)))
                (into {} (map vector nodes (repeat #{})))
                edges)
        walk
        (fn walk [visited node]
          (lazy-seq
            (let [neighbors (adjacency-mat node)
                  visited   (conj visited node)
                  unvisited (clojure.set/difference neighbors visited)]
              (cond (= num-nodes (count visited)) (list true)
                    (empty? unvisited) (list nil)
                    :else
                    (mapcat (partial walk visited) unvisited)))))]
    (boolean (some true? (walk #{} (first nodes))))))
jorendorff's solution:

1
2
3
4
5
6
(fn [pairs] (= (count (distinct (apply concat pairs)))
               (count (loop [s (set (first pairs))]
                        (let [t (into s (for [[a b] pairs [a b] [[a b] [b a]] :when (s a)] b))]
                          (if (= s t)
                            s
                            (recur t)))))))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn graphconn [verts]
  (let [all-nodes (reduce (fn [acc v] (conj acc (first v) (second v))) #{} verts)]
    (letfn [(walk-graph [nodes-to-visit verts visited]
                        (loop [visit (vec nodes-to-visit) remaining-verts verts already-visited visited] 
                               (if (empty? visit) 
                                 (if (empty? remaining-verts) true false)
                                 (let [node (first visit)
                                       matching (filter (fn [v] (some #{node} v)) (vec remaining-verts))
                                       non-matching (filter (fn [v] (not (some #{node} v))) (vec remaining-verts))
                                       non-visited (reduce
                                                     (fn [acc v] (let [to-node (if (= (first v) node) (second v) (first v))]
                                                                   (when (not (contains? already-visited to-node)) (conj acc to-node))))
                                                     #{} matching)]
                                   (recur (concat (rest visit) non-visited) non-matching (conj already-visited node) )
                                 ))))]
      (let [vert (first verts)
            nodes-to-visit (conj #{} (first vert) (second vert))]
        (walk-graph nodes-to-visit verts #{})))
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [g]
  (letfn [
    (paths [[prev :as path] rests]
            (if (empty? rests)
                [path]
                (#(if (empty? %) [path] %)
                  (apply concat
                    (keep
                      #(if (or (nil? prev)
                               (> 4 (count (into #{} (concat prev %)))))
                           (paths (cons % path) (disj rests %)))
                      rests)))))]
    (let [ps (paths () g)]
      (every?
        (fn [[src dst]]
          (some
            (fn [p]
              (and (= src (last p))
                   (some #(= dst %) p)))
            ps))
        (for [src g dst (disj g src)] [src dst])))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
(fn [g]
  (loop [q (map set g)]
    (let [c (count q)
          z (reduce (fn [[h & t :as a] y]
                       (if (empty? (clojure.set/intersection h y))
                         (conj a y)
                         (into [(clojure.set/union h y)] t)))
                     [(first q)] (-> q rest vec))]
      (if (= c (count z)) (= 1 c)
          (recur z)))))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
(fn problem91
  [s]
  (letfn [;; Is there a path from node a to node b
          ;; (path [1 2] [2 3]) -> true
          ;; (path [1 2] [3 2]) -> true
          (is-path [[a b] [c d]]
            (or (= b c)
                (= b d)
                (= a c)
                (= a d)))
 
          ;; Return [elem [xs without elm]]
          (remover [elm xs]
            [elm (filter #(not= elm %) xs)])
          
          ;; split all combinations
          ;; given [a b c d]
          ;; return
          ;; [a [b c d]] [b [a c d] [c [a b d]] [d [a b c]]
          (combo-splitter [xs]
            (map #(remover % xs) xs))
 
          (filter-next-paths
            [node xs]
            (filter (fn [[n r]] (or (nil? node) (is-path node n))) (combo-splitter xs)))
 
          ;; For a given set of nodes return true if they are connected
          (problem91Ex [path xs]
            (if (empty? xs)
              path
              ;; for each item in xs
              ;; if is-path (last path) (first xs)
              ;; call foo (add-path path node) (remove node xs)
              (let [node (last path)
                    paths (filter-next-paths node xs)]
                    (map (fn [[ a res ]] (problem91Ex (conj path a) res)) paths))))]
    (pos? (count (flatten (problem91Ex [] s))))))
brendan's solution:

1
2
3
4
5
6
7
8
; Evil hack
(fn [& _]
  (reify Object
    clojure.lang.IPersistentCollection
    (seq [_])
    (cons [_ _])
    (empty [_])
    (equiv [_ _] true)))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn my-graph-connectivity
  [graph]
  (letfn [(end-element? [list end] (some #(= (set (key (last %))) (set end)) list))
          (remove-first [val coll] (let [[n m] (split-with (partial not= val) coll)] (concat n (rest m))))
          (get-pairs [graph] (filter #(= 2 (count %)) (set (for [x graph y graph] (conj #{} x y)))))
          (possible-paths [val coll]
                          (remove nil? (map #(cond 
                                               (= (second val) (first %)) (hash-map % (remove-first % coll))
                                               (= (second val) (second %)) (hash-map (reverse %) (remove-first % coll)))
                                  coll)))
          (are-vertices-connected [start end elements]
                                  (loop [result (list (hash-map start (remove #(= % start) elements))) i 1]
                                     (if (or (end-element? result end) (= i (inc (count elements))))
                                       (not (empty? result))
                                       (recur (mapcat #(possible-paths (key (last %)) (val (last %))) result) (inc i)))))]
    (if (= 1 (count graph))
      true
      (not-any? false? (map #(or (are-vertices-connected (first %) (second %) graph)
                 (are-vertices-connected (reverse (first %)) (second %) graph)) (get-pairs graph))))))
lackita's solution:

1
2
3
4
5
6
7
8
9
10
#(let [graph (group-by first 
                       (mapcat (fn [e]
                                 [e (vec (reverse e))])
                               %))]
   ((fn traverse [v]
      (let [new-v (into v (map last (mapcat graph v)))]
        (if (= new-v v)
          (= v (set (keys graph)))
          (traverse new-v))))
    #{(first (keys graph))}))
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [edges]
  (let [nodes (->> edges
                   (map (fn [[a b]] (merge {a [b]} {b [a]})))
                   (apply merge-with concat))
        passed (atom #{})]
    (letfn [(go [node-id]
              (when-not (@passed node-id)
                (swap! passed conj node-id)
                (doseq [node-id' (nodes node-id)]
                  (go node-id'))))]
      (go (key (first nodes)))
      (= (count @passed)
         (count nodes)))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn connected [graph]
  (loop [[[a b :as e] & edges] (sort (concat graph (mapv (fn [[x y]] [y x]) graph)))
         unmatched #{}
         nodes #{a}]
    (cond
     (or (contains? nodes a) (contains? nodes b))
       (recur edges (disj unmatched e) (into nodes e))
     (empty? edges) (empty? unmatched)
     :else (recur edges (conj unmatched e) nodes)
     )
    )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(letfn [(intersects? [s1 s2]
          (not (empty? (clojure.set/intersection (set s1) (set s2)))))]
  (fn connected? [g]
    (= 1
       (count
         (reduce (fn [subgroups e]
                   (prn subgroups e)
                   (conj
                     (remove (partial intersects? e) subgroups)
                     (set (apply concat (filter (partial intersects? e) subgroups)))))
                 (map list (set (flatten (seq g))))
                 g)))))
leetwinski's solution:

1
2
3
4
5
6
7
(fn [ls]
  (loop [s (set (first ls)) r (rest ls)] 
    (or (empty? r)
        (let [{linked true unlinked nil} (group-by #(some (comp boolean s) %) r)]
          (if (seq linked)
            (recur (reduce into s linked) unlinked)
            false)))))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [g] 
  (= (set (apply concat g))
    ((fn clos 
      ([g] (clos (set (first g)) (set (rest g))))
      ([stock graph]
        (let [ nodes
          (group-by 
            #(not (empty? (clojure.set/intersection stock (set %1))))
            graph)]
          (if (empty? (get nodes true))
            stock
            (clos 
              (into stock (apply concat (get nodes true)))
              (get nodes false)))))) g)))
malvert's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [g]
  (let [[e & r] (map set g)]
    (loop [a e c (into #{} r)]
      (if (empty? c)
        true
        (if-let 
          [n (some #(when (not 
            (empty? (clojure.set/intersection % a))) %)
            c)]
          (recur (clojure.set/union a n) (disj c n))
          false)))))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn connected?
  [edges]
  (letfn [(grow-paths [edges]
            (let [[edge & more] (seq edges)]
              (reduce path-to #{edge} more)))
          (path-to [a b]
            (let [ab (concat (first a) b)]
              (if (apply distinct? ab)
                (conj a b)
                (conj (rest a) (distinct ab)))))
          (changed? [[x y]]
            (not= (count x) (count y)))]
    (->> edges
         (iterate grow-paths)
         (partition 2)
         (drop-while changed?)
         ffirst
         count
         (= 1))))
maximental's solution:

1
2
3
4
5
6
7
(fn [g]
  ((fn f [e] 
     (#(if (= e %) (= % g) (f %)) 
        (reduce (fn [a b] (into a (filter #(some (set b) %) g))) 
                #{} 
                e))) 
   #{(first g)}))
mbakhterev's solution:

1
2
3
4
5
6
7
(fn [E]
  (let [G (reduce (fn [R [a b]] (assoc R a (conj (R a #{}) b) b (conj (R b #{}) a))) {} E)
        C (loop [R #{(first (keys G))}]
            (let [D (mapcat (fn [v] (apply disj (G v) R)) R)]
              (if (empty? D) R (recur (into R D)))))]
    (and (= (count C) (count G))
         (<= (count (filter (fn [v] (= 1 (mod (count v) 2))) (vals G))) 4))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn connected? [g]
  {:pre [(coll? g),
         (every? (comp (partial = 2) count) g)]}
  (loop [ccom (set (first g)), edges (rest g)]
    (let [[new-ccom new-edges]
          (reduce (fn [[in out] [a b :as e]]
                    (if (or (in a) (in b))
                      [(conj in a b) out]
                      [in (conj out e)]))
                  [ccom []]
                  edges)]
      (cond
        (empty? edges)     true
        (= ccom new-ccom)  false
        :else              (recur new-ccom new-edges)))))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn connected? [g]
  (let [flood (fn [ns g]
                (let [ns' (into ns
                                (flatten
                                  (for [[a b] g :when (or (contains? ns a)
                                                          (contains? ns b))]
                                    [a b])))]
                  (if (= ns' ns)
                    ns
                    (recur ns' g))))]
    (= (flood #{(ffirst g)} g)
       (set (flatten (seq g))))))
minitrue's solution:

1
2
3
4
5
(fn [g]
  (letfn [(un [dicts [p q]]
            (let [has? #(or (% p) (% q))]
              (cons (apply clojure.set/union (set [p q]) (filter has? dicts)) (remove has? dicts))))]
    (->> (reduce un #{} g) count (= 1))))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn connected? [g]
    (let [transitiveclosure (fn [m]
       (loop [storage #{} result m]
         (if (= storage result)
           result
           (recur result (set (into result (for [x result
                                                 y result
                                                 :when (= (peek x) (first y))]
                                             (vector (first x) (peek y)))))))))]
    (reduce #(and %1 %2) (map sequential? 
            (for [q (set (mapcat flatten g))
                 r (set (mapcat flatten g))]
             (some #{(vector q r)} (transitiveclosure (into g
                                                            (map #(vec (reverse %)) g)))))))))
mobiusloop's solution:

1
2
3
4
5
6
7
8
9
(fn [g]
(let [y (fn y [s g z]
          (let [c (remove #{s} (mapcat #(if (some #{s} %) % []) g))
                t (mapcat #(y % g (concat z c)) (remove (set z) c))]
            (set (concat c t [s]))))
      e (-> g (seq)(flatten)(set))
      ]
  (= e (y (first e) g []))
  ))
mononite's solution:

1
2
3
4
5
6
(fn [graph]
  (letfn [(eliminate [s node] 
            (let [m (group-by #(or (= node (first %)) (= node (last %))) s)] 
              (reduce #(eliminate % (if (= node (first %2)) (last %2) (first %2))) (get m false) (get m true))))]
    (let [[start end] (first graph)]
      (empty? (eliminate (eliminate (rest graph) start) end)))))
mouse's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [C O I g]
    (O
     (reduce
      (fn [s [f t]]
        (let [{[a & [r]] true o false :or {o []}}
              (group-by #(or (C % f) (C % t)) s)]
          (I #{(I a r)} o)
          ))
      (I #{} (map #(hash-set %) (distinct (flatten (seq g)))))
      (seq g))))
  contains? #(= 1 (count %)) into
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(fn f91 [edges]
  (letfn [(graph [edges]
            (->> edges
                 (mapcat (fn [v]
                           (let [f (first v)
                                 s (second v)]
                             [{f #{s}} {s #{f}}])))
                 (apply merge-with clojure.set/union)))
          (dsf [graph node]
            (loop [seen #{node}
                   path [node]
                   todo (vec (get graph node))]
              (if (empty? todo)
                path
                (let [node (peek todo)]
                  (if (seen node)
                    (recur seen
                           path
                           (pop todo))
                    (recur (conj seen node)
                           (conj path node)
                           (into (pop todo) (get graph node))))))))
 
          (connected-graph? [g]
            (= (count g)
               (count (dsf g (ffirst g)))))]
    (-> edges
        graph
        connected-graph?)))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [edges]
  (let [edges (shuffle (vec edges))]
    (letfn [(connected?[[x y]]
              "Does an edge connect two nodes?"
              (not-empty (clojure.set/intersection (set  x) (set y))))
 
            (any-connections? [edges]
              "Can any of the nodes we have connect up?"
              (some connected?
                    (for [x edges
                          y edges
                          :when (not= x y)]
                      [x y])))]
 
      (let [[h t & r] edges]
        (cond
          (= 1 (count edges)) true
          (not (any-connections? edges)) false
          :else (if (connected? [h t])
                  (recur (concat [(into h t)] r))
                  (recur (concat [t] r [h]))))))))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [g]
        (letfn [(n [v] (remove nil? (map (fn [[a b]] (cond (= a v) b
                                                                 (= b v) a
                                                                 :else nil))
                                               g)))
               (d [s v]
                    (if (s v)
                        s
                        (->> (n v)
                             (reduce d (conj s v)))))]
           (= (d #{} (first (first g)))
              (reduce into #{} g))))
noiseehc's solution:

1
2
3
4
5
6
(fn graphconnect [x]
    (letfn [(getset [a acc] (if-let [s (first (filter #(% a) acc))] s #{a}))]
           (= 1 (count
           (reduce 
             (fn [acc [a b]] (let [_a (getset a acc) _b (getset b acc)] (conj (disj acc _a _b) (clojure.set/union _a _b)))) 
             #{} x)))))
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn connected? [nodegraph]
  (letfn [(all-nodes [nodegraph]
            (into #{} (mapcat identity nodegraph)))
 
          (node-connection [edge node]
            (cond
             (= (first edge) node) (second edge)
             (= (second edge) node) (first edge)))
 
          (paths-from [nodegraph node]
            (let [nodes (map #(node-connection % node) nodegraph)
                  node-set (disj (set nodes) nil)]
              node-set))
 
          (rand-set [nodeset]
            (rand-nth (seq nodeset)))
 
          (visited-all? [nodeset visitedset]
            (= nodeset visitedset))]
 
    (let [nodes (all-nodes nodegraph)]
      (loop [visited #{} to-visit #{(rand-set nodes)}]
  (if (empty? to-visit)
          (visited-all? visited nodes)
          (let [next-visit (rand-set to-visit)
                paths (paths-from nodegraph next-visit)
                new-paths (clojure.set/difference paths visited)]
            (recur (conj visited next-visit) (into (disj to-visit next-visit) new-paths))))))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [edges]
    (let [nodes (into #{} (concat (map first edges) (map second edges)))
          connections (->> (concat edges (map reverse edges))
                           (group-by first)
                           (map (fn [[k v]] [k (map second v)]))
                           (into {}))]
      (loop [to-visit (into #{} (take 1 nodes)) visited #{}]
        (if (seq to-visit)
          (let [head (first to-visit)
                remaining (disj to-visit head)
                remaining (->> (connections head)
                               (remove visited)
                               (into remaining))]
            (recur remaining (conj visited head)))
          (= visited nodes)))))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
(fn myf [graph]
 (loop [all-set (set (flatten (vec graph)))
        graph-set (set (first graph))]
   (let [res (reduce 
               #(if (or (contains? %1 (second %2)) (contains? %1 (first %2))) (into %1 %2) %1)
               graph-set
               graph)]
     (cond (= graph-set all-set) true;
           (= graph-set res) false;
           :else (recur all-set res)))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [xs]
  (->> xs
    (reduce
      (fn [m [x y]]
        (let [s (-> #{} (into [x y]) (into (m x)) (into (m y)))]
          (into m (map vector s (repeat s)))))
      {})
    vals
    set
    count
    (>= 1)))
ozan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn connected? [edges]
   (let [bidirectional (concat edges (map reverse edges))
         adjacencies (into {} (for [[k v] (group-by first bidirectional)] [k (map second v)]))]
     (letfn [(traverse [visited]
               (if (= (count adjacencies) (count visited)) true
                   (let [adjacent (into #{} (adjacencies (last visited)))
                         visited-set (into #{} visited)
                         to-traverse (clojure.set/difference adjacent visited-set)]
                     (or (some true? (map #(traverse (conj visited %)) to-traverse)) false))))]
       (or (some true? (map #(traverse (vector %)) (keys adjacencies))) false)))
     
   
   )
pukeface's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [S]
    (let [g (apply merge-with concat 
               (for [[x y] S
                     m [{x [y]} {y [x]}]]
                 m))
          n (into #{} (apply concat S))
          f (fn f [A V]
                (if (empty? A) V
                    (->> (first A)
                         (g)
                         (filter #(not (V %)))
                         (concat (rest A))
                         (#(f % (conj V (first A)))))))
                    
          ]
        (= n (f [(first n)] #{}))))
quant1's solution:

1
2
3
(fn [es] (let [ng (fn [es ps] (into ps (apply concat (for [p ps e es :when (e p)] e))))
               n (count (set (apply concat es)))]
  (->> (iterate #(ng (map set es) %) (set (first es))) (take n) last count (= n))))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [ll]
 (->>
  (map set ll)
  ((fn [[f & r :as lst]]
     (if
      (empty? r) lst
      (let [rr (map #(if (nil? (some % f)) % (into % f)) r)]
         (if (= rr r) lst (recur rr))
   ))))
   set
   count
   (= 1)
))
sbondaryev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [edges]
  (let [
        maps (map #(list (hash-map (first %) (rest %))
                         (hash-map (last %) (butlast %))) edges)
        all (apply merge-with concat (flatten maps))
        connected? (fn cn? [s e path all]
                     (cond
                       (some #{s} path) false
                       (= s e) true
                       :else (some true?
                                   (map #(cn? % e (conj path s) all)
                                        (all s)))))]
    (->>
     (for [s (keys all) e (keys all) :when (not= s e)]
       (connected? s e [] all))
     (#(conj % true))
     (every? true?))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn connected? [edges]
  (letfn [(group [sets edge]
                 (let [gt-cntns (fn [sets node]
                                  (reduce #(if (contains? %2 node) %2 %1) 
                                          nil 
                                          sets))
                       contains-left (gt-cntns sets (first edge))
                       contains-right (gt-cntns sets (last edge))]
                   (cond
                    (and (set? contains-left) (set? contains-right)) 
                    (conj (disj sets contains-left contains-right) 
                          (clojure.set/union contains-left contains-right))
                    (set? contains-left) (conj (disj sets contains-left) 
                                               (apply conj contains-left edge))
                    (set? contains-right) (conj (disj sets contains-right) 
                                                (apply conj contains-right edge))
                    :else
                    (conj sets (apply conj #{} edge)))))]
    (= 1 (count (reduce group #{} edges)))))
sheldon's solution:

1
2
3
4
5
6
7
8
(fn [x] 
   (let [h (reduce #(conj % %2 (reverse %2)) #{} x)
         g ((fn f [s] 
              (let [r (reduce #(conj % %2) s (remove nil? (for [a s b s] (if (= (second a) (first b)) [(first a) (second b)]))))]
                (if (= r s) r (f r)))) h)
         n (set (map first g))
         m (for [a n b n] [a b])] 
     (reduce #(and % (not (nil? (g %2)))) true m)))
silverio's solution:

1
2
3
4
5
6
7
8
9
10
#(> 2 (count
   (reduce (fn [s [ea eb]]
    (apply cons
      (reduce (fn [[j d] cs]
        (if (or (cs ea) (cs eb))
          [(into j cs) d]
          [j (conj d cs)]))
        [#{} []] s)))
    (->> % vec flatten set (map hash-set))
    %)))
skyrem's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s]
         (let [deal (sort-by second s)
               route (reduce 
                      (fn [a b]
                        (cond
                          (contains? a (first b)) (conj a (second b))
                          (contains? a (second b)) (conj a (first b))
                          :else a))
                      (into #{} (first deal)) (rest deal)) 
        all (reduce into #{} s)]
    (= all route)))
soul_awaker's solution:

1
2
3
4
5
6
7
8
(fn [s]
  (let [h (first s)]
    (loop [x (disj s h), i (into #{} h)]
      (or (empty? x)
          (let [e (some #(when (some i %) %) x)]
            (if e
                (recur (disj x e) (into i e))
                false))))))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(letfn
    [( closure [xys]
        (into
            xys
            (for [[x1 y1] xys
                  [x2 y2] xys
                  :when (= y1 x2)]
                  [x1 y2])))
 
      ( tc [xys]
        (loop [count-so-far (count xys)
               step (closure xys)]
          (if (= count-so-far (count step))
            step
            (recur (count step) (closure step)))))
 
      ( vertices [graph]
        (distinct (flatten (vec graph))))
 
      ( normalize [graph]
        (set (apply concat (for [[x y] graph] [[x y] [y x]]))))]
 
    (fn [graph]
      (let [count-full (->> graph normalize tc count)
            count-vertices (count (vertices graph))]
          (= count-full (* count-vertices count-vertices)))))
syeerzy's solution:

1
2
3
4
5
6
(fn [edges]
  (= (set (apply concat edges))
     (loop [vs #{(ffirst edges)}]
       (if-let [nvs (seq (for [[a b] edges :when (and (vs a) (not (vs b)))] b))]
         (recur (into vs nvs))
         vs))))
tclamb's solution:

1
2
3
4
5
6
7
8
(fn [g]
  (let [u clojure.set/union
        g (apply merge-with u (mapcat (fn [[k v]] [{k #{v}} {v #{k}}]) g))
        f #(into {} (for [[k v] %] [k (reduce (fn [v k] (u v (% k))) v v)]))]
    (loop [g g]
      (if (= g (f g))
        (apply = (count g) (map (comp count val) g))
        (recur (f g))))))
thegeez's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [edges]
    (let [all-nodes (set (mapcat identity edges))]
      (loop [seen #{(ffirst edges)}]
        (if (= seen all-nodes)
          true
          (let [next-seen (into seen (mapcat (fn [node]
                                               (keep (fn [[a b]]
                                                       (cond
                                                        (= a node) b
                                                        (= b node) a)) edges)) seen))]
            (if (= seen next-seen)
              false
              (recur next-seen)))))))
zzamboni's solution:

1
2
3
4
(fn connected? [g]
  (let [g (sort-by first (concat g (map reverse g)))]
    (= (count (reduce (fn [seen [n m]] (if (seen n) (conj seen m) seen)) #{(ffirst g)} g))
       (count (distinct (flatten g))))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn __ [edges]
  (letfn [(connected? [c1 c2]
                      (not (empty? (clojure.set/intersection c1 c2))))
          (add-comp [c1 c2]
                      (if (connected? c1 c2) (apply conj c1 c2) c1))
          (merge-comp [cs]
                      (if (empty? cs) '()
                        (let [c (first cs), rs (rest cs)]
                          (if (true? (some true? (map #(connected? c %) rs)))
                            (merge-comp (map #(add-comp % c) rs))
                            (cons c (merge-comp rs))))))
          ]
    (->> (map #(into #{} %) edges)
         (merge-comp)
         (count)
         (#(= 1 %)))))
zipzop's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn gc [graph]
  (= (set (apply concat graph))
 
((fn c
  ([e] (c (ffirst e) #{} e))
  ([t v e] 
    (reduce clojure.set/union v
      (let [step (filter #(or (= t (first %)) (= t (second %))) e)
          nbs (disj (set (concat (map first step) (map second step))) t)
          rst (clojure.set/difference e step)
          new (clojure.set/difference nbs v)
          ]
        ;(println "t" t "n" nbs "r" rst "new" new "v" v) 
        (if (empty? new)
           (list #{t})
          (for [n new]
            (c n (into v #{t}) rst))
        )
      )   
    )
  )
) graph)))
yusubori's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s]
  (letfn [(connected-nodes
           [nodes coll]
           (let [nodes' (into nodes
                              (flatten
                               (for [[a b] coll :when (or (contains? nodes a)
                                                          (contains? nodes b))]
                                [a b])))]
             (if (= nodes nodes')
               nodes
               (recur nodes' coll))))]
    (= (connected-nodes #{(ffirst s)} s)
       (set (flatten (seq s))))))
ydash's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [s]
  (letfn [(connect [n e]
            (some {n (first (remove #(= n %) e))} e))]
    (loop [nodes (first s) ue (rest s)]
      (if (empty? ue)
        true
        (let [c (set (apply concat (map #(keep (partial connect %) ue) nodes)))]
          (if (empty? c)
            false
            (recur c (reduce #(remove (fn [n] (connect %2 n)) %) ue nodes))))
        ))))
vpeurala's solution:

1
(fn [graph] (letfn [ (vertices [edge-set] (sort (distinct (flatten (map flatten edge-set))))) (without [coll item] (cond (empty? coll) [] (= (first coll) item) (rest coll) :else (cons (first coll) (without (rest coll) item)))) (seq-contains? [coll item] (cond (empty? coll) false (= (first coll) item) true :else (seq-contains? (rest coll) item))) (edges-with [edge-set vertex] (filter #(seq-contains? % vertex) (map flatten edge-set))) (vertices-with-distance-1 [edge-set vertex] (mapcat #(without % vertex) (edges-with edge-set vertex))) (expand [edge-set vertices] (sort (distinct (concat vertices (mapcat #(vertices-with-distance-1 edge-set %) vertices))))) (iterate-while-changes [f x] (cons x (map second (take-while #(not= (first %) (second %)) (partition 2 1 (iterate f x)))))) (expand-full [edge-set] (last (iterate-while-changes (partial expand edge-set) (take 1 (vertices edge-set))))) (is-connected? [graph] (= (set (vertices graph)) (set (expand-full graph)))) ] (is-connected? graph)))
v_bogdanov's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
#(let [vc (vec %)]
    (loop [s (set (first vc))
           uc #{}
           r (rest vc)]
      (let [cuc (count uc) fr (first r) rr (rest r)]
      (cond
       (= 0 cuc (count r)) true
       (and (= 0 (count r)) (not= 0 cuc)) false
       :else 
        (if (= (count (into s fr)) (+ 2 (count s)))
          (recur s (into uc fr) rr)
          (if (= (count (into uc fr)) (+ 2 cuc))
            (recur (into s fr) uc rr)
               (recur (into s (concat fr uc)) #{} rr)))))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn is-connected [xset]
  (loop [ret [] rst (vec xset)]
    (if (empty? rst)
      true
      (if (empty? ret)
        (recur (conj ret (first rst)) (rest rst))
        (let [tails (flatten ret)
              heads (flatten rst)
              common-elt (first (clojure.set/intersection (set tails)
                                                          (set heads)))]
          (if (nil? common-elt)
            false
            (let [add-elt (first (filter #(or (= (first %) common-elt)
                                              (= (second %) common-elt))
                                         rst))]
              (recur (conj ret add-elt)
                     (remove #{add-elt} rst)))))))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
10
(fn fully-connected? [graph]
  (let [nodes (set (apply concat graph))
        full-graph (set (mapcat (fn [[a b :as n]] [n [b a]]) graph))
        children (into {} (for [[k v] (group-by first full-graph)] [k (set (map second v))]))
        connections (fn [node]
                      (->> (iterate #(into % (mapcat children %)) #{node})
                           (partition 2 1)
                           (drop-while #(apply not= %))
                           first first))]
    (every? #(= % nodes) (map connections nodes))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn [graph]
  (letfn [(setify [coll] (set (map set coll)))
(adjacent? [edge1 edge2]
  (not (empty? (clojure.set/intersection edge1 edge2))))
(neighbors [edges graph]
  (set (apply concat
        (for [e edges]
          (filter #(adjacent? e %) graph)))))
(step [from graph]
  (let [to (neighbors from graph)]
    {   :edges to
     :subgraph (clojure.set/difference graph to)}))
(rand-bf-walk [graph]
  (loop [edges (->> graph seq rand-nth set (conj #{}))
         graph (-> graph setify (clojure.set/difference edges))
         walk [edges]]
    (let [next-step (step edges graph)
          edges (:edges next-step)]
      (if (or (empty? edges) (empty? graph))
        walk
        (recur edges (:subgraph next-step) (conj walk edges))))))]
(= (->> graph rand-bf-walk (map seq) flatten count)
                             (count graph))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)