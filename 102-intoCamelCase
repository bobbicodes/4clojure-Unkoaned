102 kebab-case to CamelCase

(= (__ "something") "something")
(= (__ "multi-word-key") "multiWordKey")
(= (__ "leaveMeAlone") "leaveMeAlone")

(fn name [s]
  (let [words (re-seq #"[a-zA-Z]+" s)
        words (cons (first words)
                    (map clojure.string/capitalize
                      (rest words)))]
    (apply str words)))

;; What's going on here?

Actually, only 1 thing:
(apply str words)

words is a binding created by let,
which takes our argument s
and calls re-seq on it.
This breaks a hyphenated string
into one word strings:

user> (re-seq #"[a-zA-Z]+"
        "make-this-camel-case")
("make" "this" "camel" "case")

#(let [[_ & tail :as col] (clojure.string/split % #"\-")]
   (->> (map clojure.string/capitalize tail)
        (concat (take 1 col))
        clojure.string/join))

#(apply str
  (into
    [(first (clojure.string/split % #"-"))]
       (map clojure.string/capitalize
         (rest
           (clojure.string/split % #"-")))))

#(let [words (clojure.string/split % #"\W")
       capWords (map clojure.string/capitalize (rest words))]
   (reduce str (first words) capWords))

(fn [s]
  (letfn
    [(ucfirst [w]
      (apply str (-> w first str .toUpperCase) (rest w)))]
    (let [words (re-seq #"[a-zA-Z]+" s)]
      (apply str (first words)
        (map ucfirst (rest words))))))

#(clojure.string/replace % #"-[a-z]"
   (comp clojure.string/upper-case last))

(fn [dashed]
  (let [tokens (.split dashed "-")
        capped (map
                #(apply str
                   (Character/toUpperCase (first %))
                   (rest %))
                 (rest tokens))]
       (apply str
         (first tokens) capped)))

(fn camel [s] 
  (let [splitted (clojure.string/split s #"-")]
    (clojure.string/join
      (cons
        (first splitted)
        (map clojure.string/capitalize
          (rest splitted))))))

(fn [x] 
  (let [splitted (clojure.string/split x #"-")
        firstword (first splitted)
        restwords (map
                    clojure.string/capitalize
                    (rest splitted))
        combinedResult (cons firstword restwords)]
    (apply str combinedResult)))

(fn [a]
    (let [spondash
            (clojure.string/split a #"-")
          hasdash?
            (> (count spondash) 1)
          wordsforcamel
           (fn [b]
             (map
               #(clojure.string/capitalize
                  (nth b %))
                (range 1
                  (count b))))]
    (if hasdash?
       (clojure.string/join
         (concat
          [(nth spondash 0)]
           (wordsforcamel spondash))) a)))

(fn camel-case [s]
     (let
         [words (clojure.string/split s #"-")]
        (->>
            words
           (drop 1)
           (map clojure.string/capitalize)
           (concat (take 1 words))
           (clojure.string/join))))

(fn [s] 
        (let [[a & as]
                (re-seq #"(\w)([^-]+)" s)]
             (apply str
               (first a)
               (map
                 #(str
                    (.toUpperCase
                       (second %))
                    (last %)) as))))

(fn [s]
  (clojure.string/replace s #"-\w"
    #(.toUpperCase (.substring % 1))))

(fn
  [s]
  (let [fix-case (fn [s] (let [c (.charAt s 0)]
                           (.concat (str (Character/toUpperCase c))
                                    (.substring s 1))))
        ss (.split s "-")
        h (first ss)
        t' (map fix-case (rest ss))]
    (reduce #(.concat % %2) (cons h t'))))
austintaylor's solution:
1
2
3
4
5
6
7
8
9
(fn [s]
  (let [words (.split s "-")]
    (apply str
      (first words)
      (map (fn [s]
        (apply str
          (.toUpperCase (str (first s)))
          (rest s)))
        (rest words)))))
awebb's solution:
1
(fn [s] (clojure.string/replace s #"-(\w)" #(str (.toUpperCase (% 1)))))
bendykst's solution:
1
2
3
4
5
6
7
8
(fn [s]
  (letfn
   [(cap [[head & tail]]
      (apply (partial str (char (- (int head) 32))) tail))]
    (apply str
      (first (clojure.string/split s #"\-"))
      (map cap 
        (rest (clojure.string/split s #"\-"))))))
benhammond's solution:
1
2
(fn [x] (let [rs (clojure.string/split x #"\-")]
            (apply str (cons (first rs) (map #(clojure.string/join (cons (clojure.string/upper-case (first %)) (next %))) (next rs))))))
benizi's solution:
1
2
3
4
(fn [w]
  (let [words (re-seq #"[^-]+" w)
        [fst & rst] words]
    (apply str (cons fst (map (fn [[fl & rstl]] (apply str (cons (.toUpperCase (str fl)) rstl))) (rest words))))))
bobuhiro11's solution:
1
2
3
4
(fn intoCamelCase [s]
  (let [lst (clojure.string/split s #"[-]")]
    (clojure.string/join ""
    (cons (first lst) (map  (fn [x] (clojure.string/capitalize x)) (rest lst))))))
burner's solution:
1
2
(fn [x] (apply str (map #(if (= (second %) \-) (Character/toUpperCase (first %)) (first %)) 
                      (remove #(= (first %) \-) (reverse (partition 2 1 [:begin] (reverse x)))))))
caterpillar's solution:
1
2
3
#(let[[word & words] (filter (fn[x] (not= x "")) (seq (.split #"-" %)))]
      (if(seq words) (apply str (cons word (map clojure.string/capitalize words)))
        word))
cc787's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [s]
  (clojure.string/replace s #"-\w" #(->> % last str clojure.string/upper-case)))
 
;; (fn [arg]
;;   (clojure.string/join
;;    (loop [xs arg
;;           upper? false
;;           result []]
;;      (if (empty? xs)
;;        result
;;        (recur (rest xs)
;;               (= \- (first xs))
;;               (cond (= \- (first xs)) result
;;                     upper? (conj result (clojure.string/upper-case (first xs)))
;;                     :else (conj result (first xs)))
;;               ))))
;;   )
chunchangshao's solution:
1
#(case (count %) 12 "leaveMeAlone" 9 "something" "multiWordKey")
ctzsm's solution:
1
2
3
4
5
(fn [s]
   (apply str
          (for [t (partition 2 1 (str "0" s))] (if (= \- (second t)) ""
            (if (= \- (first t))
              (Character/toUpperCase (second t)) (second t))))))
dan7es's solution:
1
2
3
4
5
6
(fn camel-case [s]
  (let [[head & tail]
        (.split #"-" s)]
    (apply str head
      (map clojure.string/capitalize
           tail))))
daniels's solution:
1
#(clojure.string/replace % #"(-)([a-z])" (comp clojure.string/upper-case last))
daowen's solution:
1
2
3
4
5
6
(fn camel [s]
  (->>
    (partition 2 1 (cons 0 s))
    (map (fn [[a b]] (if (= a \-) (Character/toUpperCase b) b)))
    (remove #(= \- %))
    (apply str)))
del680202's solution:
1
2
3
4
5
(fn [_str] 
  (let [[fw & lw] (re-seq #"\w+" _str)]
     (apply str fw (map #(apply str (cons (.toUpperCase (str (first %))) (rest %))) lw))
   )
)
deping's solution:
1
(fn [ls] (let [tg (clojure.string/split ls #"-")] (str (first tg) (apply str (map #(apply str (concat (clojure.string/upper-case (first %)) (rest %))) (rest tg))))))
devm33's solution:
1
2
3
4
5
#(loop [s (seq %) c false r []]
    (if (empty? s)
      (apply str r)
      (let [f (first s) nc (= \- f)]
        (recur (rest s) nc (conj r (if nc "" (if c (Character/toUpperCase f) f)))))))
dwelte's solution:
1
2
3
4
5
(fn [s]
  (let [
      camel #(str (Character/toUpperCase (first %)) (apply str (rest %)))
      words (.split s "-")]
    (str (first words) (apply str (map camel (rest words))))))
dzholev's solution:
1
#(clojure.string/replace % #"-(\w)" (fn [[_ w]] (clojure.string/capitalize w)))
echevarria's solution:
1
2
3
(fn [s]
    (let [ p (filter #(not= %1 '(\-)) (partition-by (partial = \-) s))]
    (apply str (apply concat (first p) (map #(cons (.toUpperCase (str (first %1))) (rest %1)) (rest p))))))
ericw's solution:
1
2
3
4
5
(fn into-camel-case [string]                                                                                                    
    (let [[a & b] (clojure.string/split string #"-")                                                                                                    
          uc-first (fn [s] (apply str (clojure.string/upper-case (first s)) (rest s)))                                          
          camel-case (apply str a (map uc-first b))]                                                                                                    
                camel-case))
featalion's solution:
1
2
(fn [s]
  (clojure.string/replace s #"-([a-zA-Z])" (fn [[_ m]] (clojure.string/upper-case m))))
finsternis's solution:
1
2
3
(fn [s]
  (let [[w & ws] (clojure.string/split s #"-")]
    (apply str w (map clojure.string/capitalize ws))))
flububb's solution:
1
2
(fn camel [s]
  (clojure.string/replace s #"-(.)" #(.toUpperCase (%1 1))))
garyxia's solution:
1
#(clojure.string/replace % #"-(\w)" (fn [[a b]] (clojure.string/capitalize b)))
geekerzp's solution:
1
2
3
4
(fn [s]
    (clojure.string/join
     (let [words (clojure.string/split s #"-")]
       (cons (first words) (map #(clojure.string/capitalize %) (rest words))))))
glchapman's solution:
1
#(clojure.string/replace % #"-([a-z])" (fn [m] (clojure.string/upper-case (m 1))))
goaranger's solution:
1
(fn [s] (clojure.string/replace s #"-(.)" #(.toUpperCase (%1 1))))
gpittarelli's solution:
1
2
3
4
5
6
7
8
#(clojure.string/join ""
                       (map (fn [[a b]]
                              (if (= \- b)
                                ""
                                (if (= \- a)
                                  (Character/toUpperCase b)
                                  b)))
                              (partition 2 1 (cons \a (seq %)))))
happycrisis's solution:
1
2
#((fn [[x & s]] (apply str x (map clojure.string/capitalize s))) 
  (clojure.string/split % #"-" ))
hisba's solution:
1
2
3
4
5
6
7
8
9
(fn intoCamelCase [s]
(let [isChar? #(<= (int \A) (int %) (int \z))]
(->> s
     (partition-by isChar?)
     (filter #(isChar? (first %)))
     (map #(apply str %))
     (#(cons (first %) (map clojure.string/capitalize (rest %))))
     (apply str)
     )))
icamts's solution:
1
#(apply str (apply (fn [x & xs] (cons x (map clojure.string/capitalize xs))) (re-seq #"\w+" %)))
immo's solution:
1
2
#(let [s (clojure.string/split % #"-")]
  (apply str (first s) (map clojure.string/capitalize (rest s))))
jarlax's solution:
1
2
3
4
5
#(reduce
  (fn [s [from to]]
    (.replace s from (clojure.string/upper-case to)))
  %
  (re-seq #"-(\w)" %))
jedo's solution:
1
2
3
4
5
6
7
8
(fn intoCamelCase [x]
  (loop [x x res '[]]
    (cond (empty? x) (apply str res)
          (= \- (first x)) (recur (nnext x) (conj res (clojure.string/upper-case (second x))))
          :else (recur (rest x) (conj res (first x)))
    )
  )
)
jeff_terrell's solution:
1
2
3
4
5
(fn [s]
  (clojure.string/replace
    s
    #"-(\w)"
    #(.toUpperCase (second %))))
johncowie's solution:
1
2
3
4
5
6
7
8
9
(fn [s]
  (apply str
     (for [x (range 0 (count s))]
               (let [c (nth s x)]
                 (cond
                  (= x 0) (str c)
                  (= c \-) ""
                  (= (nth s (dec x)) \-) (clojure.string/upper-case (str c))
                  :else (str c))))))
jomicoll's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [s]
  (loop [ret []
         s s]
    (cond (empty? s) 
          (apply str ret)
          
          (= (first s) \-)
          (let [x1 (first s)
                x2 (second s)]
            (if (nil? x2)
              (apply str (conj ret x1))
              (recur (conj ret (clojure.string/upper-case x2))
                     (nnext s))))
          
          :else
          (recur (conj ret (first s))
                 (next s)))))
jorendorff's solution:
1
#(clojure.string/replace % #"-\w" (fn [m] (.toUpperCase (subs m 1))))
jslavin's solution:
1
2
3
4
(fn [s] 
  (apply str (reduce 
              (fn [acc v] (if (= 0 (count acc)) (conj acc v) (conj acc (clojure.string/capitalize v))))
              [] (re-seq #"\w+" s))))
kohyama's solution:
1
2
#(let [[h & r] (clojure.string/split % #"-")]
  (apply str h (map clojure.string/capitalize r)))
kopychenko's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn intoCamelCase [www]
  (let [words (re-seq #"\w+" www)]
    (reduce 
     
     (fn [a x]
       (let [c (first x)
             cu (clojure.string/upper-case c)]
         (if (= c cu) (str a x) (reduce str (str a cu) (rest x)))
 
         ))
 
     (first words)
     (rest words))))
blucas's solution:
1
2
3
4
5
6
7
8
(fn prob102
  [string]
  (let [words (clojure.string/split string #"-")
        num (count words)
        ]
    (if (= 1 num)
      (first words)
      (apply str (concat  [(first words)] (vec (map clojure.string/capitalize (rest words))))))))
brendan's solution:
1
(fn [w] (clojure.string/replace w #"-(\w)" #(.toUpperCase (second %))))
kuze's solution:
1
2
3
(fn my-into-camel-case
  [word]
  (reduce #(apply str %1 (java.lang.Character/toUpperCase (first %2)) (rest %2)) (re-seq #"\w+" word)))
lackita's solution:
1
2
3
#(let [words (clojure.string/split % #"-")]
   (apply str (cons (first words)
                    (map clojure.string/capitalize (rest words)))))
lambda4fun's solution:
1
(fn [s] (clojure.string/replace s #"-(.)" #(.toUpperCase (% 1))))
lasthemy's solution:
1
2
3
4
5
(fn [word]
  (clojure.string/replace word #"-([a-z])"
                          #(clojure.string/upper-case (second %))
                          )
  )
lbarrett's solution:
1
(fn f [s] (clojure.string/replace s #"-." #(->> % rest (apply str) clojure.string/capitalize)))
leetwinski's solution:
1
#(clojure.string/replace % #"-." (comp clojure.string/upper-case second))
littlejp2046's solution:
1
2
3
(fn [s]
  (let [spl (clojure.string/split s #"\-")]
    (apply str (first spl) (map clojure.string/capitalize (rest spl)))))
malvert's solution:
1
2
#(let [[f & r] (.split % "-")]
  (apply str f (map (fn [s] (clojure.string/capitalize s)) r)))
matiasl's solution:
1
2
3
4
(fn [s] 
  (clojure.string/replace s 
                          #"-(\w)" 
                          #(clojure.string/upper-case (str (% 1)))))
maximental's solution:
1
2
#(reduce (fn [a [c & s]] (apply str `(~a ~(Character/toUpperCase c) ~@s)))
         (.split % "-"))
mbakhterev's solution:
1
(fn [S] (clojure.string/replace S #"-[a-z]" (fn [s] (-> (last s) str (.toUpperCase)))))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn to-camel-case--flex [& args]
  {:pre [(every? string? args),
         (every? (partial re-find #"^[-a-zA-Z0-9\s]*$") args)]}
  (let [
        ;; It will be convenient to reverse the argument order in the function
        ;; clojure.string/split.
        split
        (fn [re s] (clojure.string/split s re)),
 
        ;; Most of the work occurs here.
        result
        (map (comp (partial apply str)
                   (juxt first
                         (comp (partial apply str)
                               (partial map clojure.string/capitalize)
                               rest))
                   (partial split #"-"))
             (mapcat (partial split #"\s") args))]
 
    ;; All that remains is to deal with the single-word case.
    (if (= 1 (count result))
      (first result)
      result)))
mfikes's solution:
1
2
3
(fn [s]
  (let [split-up (clojure.string/split s #"-")]
    (clojure.string/join (cons (first split-up) (map clojure.string/capitalize (rest split-up))))))
minitrue's solution:
1
(fn [s] (apply str (map #(%1 %2) (cycle [identity #(.toUpperCase %)]) (re-seq #"(?<=-)\w|\w+" s))))
mkahn's solution:
1
2
3
4
5
6
7
(fn tocamelcase [s]
  (let [capifhyphen (fn [a b]
                      (if (not= b \-)
                        (if (= a \-)
                        (Character/toUpperCase b)
                        b)))]
  (apply str (map-indexed #(capifhyphen (get s (dec %1)) %2) s))))
mobiusloop's solution:
1
2
3
4
(fn [s]
    (let [w (clojure.string/split s #"-")]
      (apply str (first w) (map #(apply str (cons (Character/toUpperCase (first %)) (rest %))) (rest w)))
      ))
mononite's solution:
1
2
3
4
(fn [s]
  (->> (clojure.string/split s #"-") 
       (#(into (conj [] (first %)) (map clojure.string/capitalize (rest %)))) 
       (apply str)))
mouse's solution:
1
(fn [w] (clojure.string/replace w #"-(.)" #( clojure.string/capitalize (second %))))
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
(fn [s]
  (->>
   (partition 2 1 (cons nil s))
   (map (fn [[prev char]]
          (if (= prev \-)
            (Character/toUpperCase char)
            char)))
   (filter #(not= % \-))
   (apply str)))
nagi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn cc [s]
  (let [matcher (re-matcher #"-." s)]
    (letfn [(subst [ss matcher]
      (let [next (re-find matcher)]
        (if next
          (subst (clojure.string/replace ss next (-> next
                                                     (clojure.string/upper-case)
                                                     (clojure.string/replace #"-" "" )))
                 matcher)
          ss
          )))]
      (subst s matcher))))
nikelandjelo's solution:
1
2
3
4
(fn [s]
  (->> (re-seq #"\w+" s)
       (map-indexed (fn [i v] (if (zero? i) v (str (.toUpperCase (subs v 0 1)) (subs v 1)))))
    (apply str)))
noiseehc's solution:
1
2
(fn [x] (let [[s1 & sr] (clojure.string/split x #"\-")]
  (clojure.string/join (cons s1 (map #(clojure.string/capitalize %) sr)))))
norman's solution:
1
2
3
4
5
(fn to-camel [text]
  (let [upchar (fn [word] (str (.toUpperCase (subs word 0 1)) (subs word 1)))
        words (clojure.string/split text #"-")
        upwords (map upchar words)]
    (clojure.string/join (cons (first words) (rest upwords)))))
nothsaevets's solution:
1
2
3
4
(fn [s]
   (let [parts (clojure.string/split s #"-")]
     (clojure.string/join
       (cons (first parts) (map clojure.string/capitalize (rest parts))))))
owk4057's solution:
1
2
3
4
5
6
(fn myf2 [s]
  (let [coll (clojure.string/split s #"-")]
    (->> (cons (first coll) (map clojure.string/capitalize (rest coll)))
      (apply str)
    
    )))
ownwaterloo's solution:
1
#(let [[x & xs] (clojure.string/split % #"-")] (apply str (cons x (map clojure.string/capitalize xs))))
ozan's solution:
1
2
3
#(clojure.string/join ""
                      (let [sp (clojure.string/split % #"\-")]
                        (cons (first sp) (map clojure.string/capitalize (rest sp)))))
pukeface's solution:
1
2
3
#(let [[f & r] (re-seq #"\w+" %)]
      (apply str f
             (map clojure.string/capitalize r)))
quant1's solution:
1
#(clojure.string/replace % #"-[a-z]" (comp clojure.string/upper-case last))
rodmax's solution:
1
(fn [s] (clojure.string/replace s #"-(.)" #(.toUpperCase (% 1))))
sbondaryev's solution:
1
2
3
(fn [w]
  (let [[fst & rst] (clojure.string/split w #"-")]
    (str fst (apply str (map clojure.string/capitalize rst)))))
shiro's solution:
1
2
3
(fn camel-case [word]
  (let [[lead & words] (clojure.string/split word #"-")]
    (apply str lead (map clojure.string/capitalize words))))
sheldon's solution:
1
(fn [s] (let [a (.split s "-")] (apply str (cons (first a) (map #(str (.toUpperCase (subs % 0 1)) (subs % 1)) (rest a))))))
silverio's solution:
1
2
3
#(let [[f & r] (.split % "-")]
  (apply str f (map (fn [[a & b]]
     (apply str (Character/toUpperCase a) b)) r)))
skyrem's solution:
1
2
3
4
5
6
7
8
9
(fn [s]
  (let [pos (.indexOf s "-")
        strings (seq s)]
    (if (= -1 pos) s
      (recur (apply str 
                    (concat
                     (first (split-at pos strings)) 
                     (clojure.string/upper-case (nth strings (inc pos)))
                     (drop 2 (last (split-at pos strings)))))))))
soul_awaker's solution:
1
2
3
#((fn [[h & t]]
  (apply str h (map clojure.string/capitalize t)))
(re-seq #"\w+" %))
staafl2's solution:
1
(fn [snake-case] (clojure.string/replace snake-case #"-(.)" (fn [m] (.toUpperCase (second m)))))
syeerzy's solution:
1
2
3
4
5
6
(fn [s]
  (let [re clojure.string/replace
        up clojure.string/upper-case]
    (re s
        #"-([a-z])" 
        #(up (last %)))))
tclamb's solution:
1
#(clojure.string/replace % #"-\w" (fn [[_ w]] (clojure.string/upper-case w)))
thegeez's solution:
1
2
3
(fn [s]
  (let [[p & ps] (re-seq #"\w+" s)]
      (apply str p (map #(apply str (.toUpperCase (str (first %))) (rest %)) ps))))
zzamboni's solution:
1
2
3
(fn intoCamelCase [s]
  (let [[fw & rw] (clojure.string/split s #"-")]
    (apply str (cons fw (map clojure.string/capitalize rw)))))
zoltanjarai's solution:
1
2
3
(fn __ [s]
  (let [l (clojure.string/split s #"-")]
    (apply str (cons (first l) (map clojure.string/capitalize (rest l))))))
zipzop's solution:
1
(fn cc [s] (clojure.string/replace s #"-(\S)" #(str (.toUpperCase (% 1)))))
yusubori's solution:
1
2
#(let [s (re-seq #"\w+" %)]
   (apply str (first s) (map clojure.string/capitalize (rest s))))
ydash's solution:
1
2
3
4
5
(fn [s]
  (reduce #(str %
                (clojure.string/replace-first
                 %2 #"\w" (.toUpperCase (.toString (first %2)))))
          (re-seq #"\w+" s)))
vpeurala's solution:
1
(fn intoCamelCase [word] (clojure.string/replace word #"-(.)" #(.toUpperCase (second %))))
v_bogdanov's solution:
1
2
(fn t [s]
  (clojure.string/replace s #"\-[a-z]"  #(.toUpperCase (str (last %)))))
unionx's solution:
1
2
3
4
5
6
7
8
(fn [w]
  (let [split clojure.string/split
        spt-w (split w #"-")]
    (if (= (count spt-w) 1)
      w
      (let [cap #(apply str (cons (Character/toUpperCase (first %)) (rest %)))]
        (apply str (cons (first spt-w)
                         (map cap (rest spt-w))))))))
trxeste's solution:
1
2
3
#(let [words (clojure.string/split % #"-")] 
    (str (first words) 
         (apply str (map clojure.string/capitalize (drop 1 words)))))
transfinite's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn icc [words]
(letfn [(cap-first [word]
  (clojure.string/join
   [ (clojure.string/upper-case (str (first word)))
     (clojure.string/join (next word))]))]
 
 
  (let [ words (clojure.string/split words #"-")
        head (first words)
        tail (rest words)]
  (clojure.string/join (cons head (map cap-first tail))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)