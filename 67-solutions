4clojure.com
Main PageProblem ListTop UsersHelpREPLDocs
Logged in as btowers793Logout
Account SettingsLeaguesSubmit a Problem
Solutions:
1
2
(fn [n] (letfn [(prime? [p] (or (= p 2) (every? #(> (rem p %) 0) (range 2 
(inc (quot p 2))))))] (take n (filter prime? (iterate inc 2)))))
1067's solution:
1
2
3
4
#(loop [v 2 agg () n-last %]
   (cond (zero? n-last) (reverse agg)
         (some (fn [p] (zero? (mod v p))) agg) (recur (inc v) agg n-last)
         :else (recur (inc v) (cons v agg) (dec n-last))))
_artem_uv's solution:
1
2
3
4
#(take % ((fn sieve [s]
  (cons (first s)
        (lazy-seq (sieve (filter (fn [xx] (not= 0 (mod xx (first s))))
                                 (rest s)))))) (iterate inc 2)))
_caterpillar's solution:
1
2
3
4
#(loop[result [], ind 0, remaining (drop 2 (range))];(drop 2 (range)) represents 2, 3, .... to infinite
   (let[primeNum (first remaining)];take out the new prime number
     (if (= ind %) result
       (recur (conj result primeNum) (inc ind) (remove (fn[x] (= 0 (rem x primeNum))) remaining)))));take out of the multiples
_pcl's solution:
1
2
3
4
5
6
7
8
(fn primes [x]
  (if (= x 1)
    [2]
    (let [pp (primes (- x 1))]
      (conj pp
        (first (filter
          (fn [i] (every? #(< 0 (mod i %)) pp))
          (range (last pp) (* 2 (last pp)))))))))
aceeca1's solution:
1
(fn [x] (take x (filter #(= (inc (mod (apply * (range 1N %)) %)) %) (iterate inc 2))))
adereth's solution:
1
2
3
4
5
6
(fn [n] 
  (->>
  (range)
  (drop 2)
  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))
  (take n)))
aferrandi's solution:
1
2
(fn primes2 [n] ((fn primesRec [primes all n] (if (zero? n) primes (if ((fn isPrime[primes toTest] (not-any? #(zero? (mod toTest %)) primes)) primes (first all)) (primesRec (conj primes (first all)) (rest all) (- n 1)) (primesRec primes (rest all) n))))
 [] (cons 2 (iterate (partial + 2) 3)) n))
aguirre's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn primes [n]
  (loop [prevPrimes [2 3]]
    (if (< (count prevPrimes) n)
      (recur (conj prevPrimes 
                   (first 
                     (filter 
                       (fn [x] 
                         (every? 
                           #(not= 0 (mod x %))
                           prevPrimes)) 
                       (map (partial + (last prevPrimes)) (range))))))
      (take n prevPrimes))))
alanforr's solution:
1
2
3
4
(fn [n]
  (letfn [(non-mults [l] (filter #(not= 0 (mod % (first l))) (rest l)) )
          (non-mult-list [l] (cons (first l) (lazy-seq (non-mult-list (non-mults l)))))]
    (take n (non-mult-list (drop 2 (range))))))
allenl's solution:
1
2
3
4
5
6
7
8
9
10
(fn primes [n]
  (condp = n
    0 []
    1 [2]
    (let [lastprimes (primes (dec n))]
      (loop [i (inc (peek lastprimes))]
        (if (empty? (filter #(= (mod i %) 0) lastprimes))
          (conj lastprimes i)
          (recur (inc i))
          )))))
andthorn's solution:
1
2
3
4
5
6
7
8
(fn [max]
  (loop [n 3 primes [2]]
    (if (= max (count primes))
      (reverse primes)
      (if (not-any? zero? (map #(mod n %) primes))
        (recur (inc n) (cons n primes))
        (recur (inc n) primes)
        ))))
anjensan's solution:
1
2
3
4
5
(fn [n]
  (take n
    (filter 
      (fn [x] 
        (not-any? #(= 0 (mod x %)) (range 2 x))) (iterate inc 2))))
astangl's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn
  [n]
  (let [odds (range 3 Double/POSITIVE_INFINITY 2)]
    (letfn [(divides? [n d] (= 0 (mod n d)))
            (is-prime [n] (cond
                            (< n 2) false
                            (= n 2) true
                            (divides? n 2) false
                            :else (let [divs (take-while #(<= (* % %) n)
                                                         odds)]
                                    (nil? (some (partial divides? n) divs)))))]
      (take n (cons 2 (filter is-prime odds))))))
austintaylor's solution:
1
2
3
(fn [n]
  (let [prime (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))]
  (take n (filter prime (iterate inc 2)))))
awebb's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (loop [primes [2] i 3]
    (cond 
       (< (count primes) n)
         (if (some #(zero? (rem i %)) primes) 
           (recur primes (+ i 2))
           (recur (conj primes i) (+ i 2)) )
       :else primes )))
bendykst's solution:
1
2
3
4
5
6
7
#(loop [n 2 primes []] 
   (if (< (count primes) %) 
   (recur (inc n) 
          (if (empty? (filter (fn [div] (= 0 (mod n div))) (range 2 n))) 
            (conj primes n) 
            primes)) 
   primes))
benhammond's solution:
1
2
3
4
5
6
7
(fn [c]
    (take c
          (reduce (fn [coll pos]
                    (let [seed (nth coll pos)]
                      (filter #(or (<= % seed) (not (zero? (rem % seed)))) coll)))
                  (drop 2 (range))
                  (range c))))
benizi's solution:
1
2
3
4
5
6
7
8
9
10
(fn [target]
  (loop [trying 3
         ps [2]]
    (if (= (count ps) target)
      ps
      (recur
       (+ trying 2)
       (if (empty? (filter #(zero? (mod trying %)) ps))
         (conj ps trying)
         ps)))))
bobuhiro11's solution:
1
2
3
4
(fn  [n]
  (let [prime?
        (fn [n] (every? #(pos? (rem n %)) (range 2 (Math/sqrt (inc n)))))]
    (take n (filter prime? (range 2 100000)))))
burner's solution:
1
(fn [x] (take x (filter (fn [x] (zero? (count (filter #(= (rem x %) 0) (take-while #(<= (* % %) x) (range 2 x)))))) (iterate inc 2))))
caterpillar's solution:
1
2
3
4
#(loop[c % n 2 p []]
   (if (= c (count p)) p
    (if (some (fn prim[x] (= 0 (rem n x))) p) (recur c (inc n) p)
              (recur c (inc n) (conj p n)))))
cc787's solution:
1
2
3
4
5
6
7
8
9
10
(fn [c]
  (loop [result [2]
         next 3]
    (if (= (count result) c)
      result
      (if (not-any? zero? (map #(mod next %) result))
        (recur (conj result next) (inc (inc next)))
        (recur result (inc (inc next))))
      )
    ))
chunchangshao's solution:
1
#(case % 2 [2 3] 5 [2 3 5 7 11] (range 542))
ctzsm's solution:
1
2
(fn prime [n] (take n 
  (filter (fn [x] (every? #(not= 0 (mod x %)) (range 2 x))) (iterate inc 2))))
dan7es's solution:
1
2
3
4
5
6
7
8
9
(letfn [(primes
         [[x & xs]]
         (lazy-seq
          (cons x (primes
                   (remove #(zero? (mod % x))
                           xs)))))]
    
  #(->> (iterate (partial + 2) 3)
        primes (cons 2) (take %)))
daniels's solution:
1
2
3
4
(fn [n]
  (let [candidates (drop 2 (range))]
    (take n
          (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (dec x)) )) candidates))))
daowen's solution:
1
2
3
4
5
(fn [n]
  (loop [ps [2], x 3]
    (if (= n (count ps)) ps
      (let [p (loop [i x] (if (some #(= 0 (mod i %)) ps) (recur (+ 2 i)) i))]
        (recur (conj ps p) (+ 2 p))))))
del680202's solution:
1
2
3
4
5
6
7
(fn [num]
    (loop [result [2]  seed 3]
         (if (= num (count result)) result
           (recur (concat result (if (empty? (filter #(zero? (rem seed %)) result)) [seed])) (inc seed))
         )
    )
)
deping's solution:
1
2
3
(fn [x] (take x (drop 2 (filter 
                         (fn [y] (empty? (filter #(= % (int %)) (map #(/ y %) (range 2 y)))))                         
                         (range)))))
devm33's solution:
1
2
3
4
5
6
(fn __ [n]
  (take
    n
    (filter
      #(empty? (re-matches #"^1?$|^(11+?)\1+$" (apply str (repeat % "1"))))
      (range))))
dwelte's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (take
    n
    (filter
      #(not-any?
        (fn [x] (= (mod % x) 0))
        (range 2 (- % 1)))
      (iterate inc 2))))
dzholev's solution:
1
2
3
4
5
6
7
8
9
(fn first-primes [n]
  (letfn [(compute-primes [cnt result number]
                          (if (= cnt 0)
                            result
                            (let [divisors (take-while #(<= (* % %) number) result)]
                              (if (some #(zero? (rem number %)) divisors)
                                (recur cnt result (+ number 2))
                                (recur (dec cnt) (conj result number) (+ number 2))))))]
    (compute-primes (dec n) [2] 3)))
echevarria's solution:
1
2
3
4
5
6
7
(fn [n]
 (take n
  (filter 
   (fn [n] 
    (= (filter #(= 0 (mod n %1)) (range 1 (inc n)))
    (list 1 n)))
   (iterate inc 2))))
ericw's solution:
1
2
3
4
(letfn [                                                                                                                                                
    (is-prime? [x] (not-any? (partial = 0) (map #(mod x %) (range 2 (inc (/ x 2))))))                                           
    (prime-seq [] (filter is-prime? (map (partial + 2) (range))))]                                                                                      
        #(take % (prime-seq)))
featalion's solution:
1
2
3
4
5
6
7
(fn [n]
  (letfn [(sieve [s]
                 (cons (first s)
                       (lazy-seq
                        (sieve (filter #(not= 0 (mod % (first s)))
                                       (rest s))))))]
    (take n (sieve (iterate inc 2)))))
finsternis's solution:
1
2
3
4
5
6
7
(fn [x]
  (loop [i 0 acc [] n 2]
    (if (= i x)
      acc
      (if (every? #(pos? (mod n %)) acc)
        (recur (inc i) (conj acc n) (inc n))
        (recur i acc (inc n))))))
flububb's solution:
1
2
3
4
5
6
7
8
(fn primes
  ([] (cons 2 (primes [2] 3)))
  ([n] (take n (primes)))
  ([s x]
    (loop [k x] 
      (if (some #(= (mod k %) 0) s)
        (recur (inc k))
        (lazy-seq (cons k (primes (cons k s) (inc k))))))))
garyxia's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (take n(filter 
(fn is-prime [n]
  (nil?
  (some
    #(zero? (mod n %))
    (range 2 n))))
(range 2 1000))))
geekerzp's solution:
1
2
3
4
5
6
7
(fn [x]
    (take x
          (remove
           (fn [n]
             (some #(= 0 (mod n %))
                   (range 2 (inc (int (Math/sqrt n))))))
           (iterate inc 2))))
glchapman's solution:
1
2
3
4
5
6
7
8
9
(let [primes
      (letfn [
            (sieve [[a & b]] (lazy-seq
                (cons a (sieve (remove #(zero? (rem % a)) b)))
            ))
        ]
        (cons 2 (sieve (iterate #(+ 2 %) 3)))
    )]
  #(take % primes))
goaranger's solution:
1
2
3
4
5
(fn [param]
((fn primer [x s acc dsieve]
  (if (> x 0)
      (primer (dec x) (first dsieve) (conj acc s) (drop 1 (filter #(not= (mod % s) 0) dsieve)))
    acc)) param 2 [] (drop 3 (range))))
gpittarelli's solution:
1
#(take %1 [2 3 5 7 11 541])
happycrisis's solution:
1
2
3
4
5
6
#(loop [primes [] cnt % n 2]  
   (if (zero? cnt) 
     primes 
     (if (some (fn [p] (zero? (mod n p))) primes)  
       (recur primes cnt (inc n)) 
       (recur (conj primes n) (dec cnt) (inc n)))))
hisba's solution:
1
2
3
4
5
6
7
8
(fn npn [n]
  (let [nextpn (fn [pn]
    (loop [g
           (+ 2 (apply max pn))]
      (if (some #(= 0 (mod g %)) pn)
        (recur (+ g 2))
        (conj pn g))))]
    (first (filter #(>= (count %) n) (iterate nextpn [2 3])))))
icamts's solution:
1
2
3
4
(fn [n] (take n ((fn sieve [s] 
                   (cons (first s) 
                         (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s)))))) 
                 (iterate inc 2))))
immo's solution:
1
Scored 134, before 4clojure started saving solutions.
jarlax's solution:
1
2
3
4
5
(fn [cnt]
  (let [not-divisible? #(not (zero? (mod %1 %2)))
        is-prime? #(every? (partial not-divisible? %)
                           (range 2 (inc (Math/sqrt %))))]
   (take cnt (concat [2] (filter is-prime? (iterate inc 2))))))
jedo's solution:
1
2
3
4
5
6
7
8
(fn nprime [x]
(letfn [(is-prime? [n]
  (if (= n 1) false
    (every? false?
      (map #(= 0 (mod n %1)) (range 2 n)))))]
 (take x (filter #(is-prime? %) (map #(+ 1 %) (range))))
)
)
jeff_terrell's solution:
1
2
3
4
5
(fn [n]
  (let [e? #(zero? (rem %1 %2))
        p? (fn [x] (not-any? #(e? x %) (range 2 x)))
        xs (map #(+ 2 %) (range))]
    (->> xs (filter p?) (take n))))
johncowie's solution:
1
2
3
4
5
6
7
8
9
10
11
#(take %
       (filter (fn [n]
                 (if (< n 2)
                   false
                   (loop [i 2]
                     (if (<= i (/ n 2))
                       (if (= (mod n i) 0)
                         false
                         (recur (inc i)))
                       true
                       )))) (range)))
jomicoll's solution:
1
2
3
4
5
6
7
8
9
(fn [n]
  (take n 
         (mapcat      
          #(loop [i 2]      
             (if (= i %)      
               (list %)      
               (when (> (mod % i) 0)      
                 (recur (inc i)))))
          (iterate inc 2))))
jorendorff's solution:
1
2
3
4
5
(fn [k] (take k ((fn primes [p n]
                        (if (some #(= 0 (mod n %)) p)
                          (primes p (inc n))
                          (cons n (lazy-seq (primes (conj p n) (inc n))))))
                      [] 2)))
jslavin's solution:
1
2
3
4
5
6
7
8
9
(fn prime [n]
    (loop [pp 2 ps #{}]
      (if (= (count ps) n)
        (into []  (sort ps))
        (if (= 0 (count (filter #(= 0 (mod pp %)) ps))) 
          (recur (inc pp)  (conj ps pp)) 
          (recur (inc pp) ps)
          )))
      )
kohyama's solution:
1
2
3
4
5
(fn [n]
  (take n
    (filter
      (fn [m] (pos? (apply * (map #(mod m %) (range 2 m)))))
      (iterate inc 2))))
kopychenko's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn prime-numbers [x]
  (letfn [(prime? [xi]
            (loop [i (dec xi)]
              (cond (= 1 i) true
                    (= 0 (rem xi i)) false
                    :else (recur (dec i))))
            )]
 
    (loop [n 2 f 0 a []]
      (cond (= f x) a
            (prime? n) (recur (inc n) (inc f) (conj a n))
            :else (recur (inc n) f  a)))
    ))
blucas's solution:
1
2
3
4
5
6
7
(fn prob67 [n]
  (take n
        (cons 2 (filter 
                 (fn [x] ;; is prime
                   (empty? (filter #(= 0 (mod x %)) (range 2 x)))
                   )
                 (iterate #(+ 2 %) 3)))))
brendan's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (take n
        ((fn sieve [[x & xs]]
           (lazy-seq 
            (cons x
                  (sieve 
                   (filter #(> (mod % x) 0) 
                           xs))))) (iterate inc 2))))
kuze's solution:
1
2
3
4
(fn myPrimeNumbers
  [num]
  (let [prime? (fn [x] (not-any? zero? (map #(mod x %) (range 2 x))))]
    (take num (filter prime? (iterate inc 2)))))
lackita's solution:
1
2
3
4
5
6
7
8
9
(fn primes [x]
  (if (= x 1) 
    [2]
    (let [known (primes (dec x))]
      (conj known
            (first (filter #(not-any? (fn [p] 
                               (= (mod % p) 0))
                             known)
                  (iterate inc (inc (last known)))))))))
lambda4fun's solution:
1
2
3
(fn [n]
  (letfn [(prime? [x] (and (> x 1) (every? #(not= 0 (mod x %)) (range 2 x))))]
    (take n (filter prime? (range)))))
lasthemy's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [x]
  (loop [cand (range 2 (* 10 x))
         primes [2]]
    (let [elim (range (last primes) (* 10 x) (last primes))]
      (let [newcand (remove (set elim) cand)]
        (if (== (inc (count primes)) x)
          (take x (concat primes newcand))
          (recur newcand (concat primes [(first newcand)]))
          )
        )
      )
    )
  )
lbarrett's solution:
1
2
3
4
(fn ps [n]
  (take n
        (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x)))
                (drop 2 (range)))))
leetwinski's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [prime? 
          (fn [n] 
            (not-any? 
              #(zero? (rem n %)) 
              (range 2 n)))]
    (take n (filter prime? (iterate inc 2)))))
littlejp2046's solution:
1
2
3
4
5
6
7
#(take %
  ((fn p [l s] 
    (lazy-seq 
      (if (some (fn [n] (zero? (mod s n))) l)
        (p l (inc s))
        (cons s (p (conj l s) (inc s))))))
    [] 2))
malvert's solution:
1
2
3
4
5
(fn [n]
  (take n
    (filter
      #(not-any? (fn [e] (= 0 (mod % e))) (range 2 %))
      (drop 2 (range)))))
matiasl's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [n]
  (take n
        ((fn primes
          ([p]
           (lazy-seq
             (cons p
                   (primes ((fn [p]
                              (loop [x p]
                                (let [divisors (range 2 (-> x
                                                            Math/sqrt
                                                            int
                                                            inc))]
                                  (if (not-any? zero? (map #(mod x %) divisors))
                                    x
                                    (recur (inc x))))))
                            (inc p))))))) 2)))
maximental's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(comp (partial apply take) reverse list)
(remove (comp (partial apply some)
              (juxt (partial partial (comp zero? rem))
                    (partial range 2))) 
        (iterate inc 2))
 
#_
 
(fn [n]
  (take n
    (remove (fn [k] (some #(zero? (rem k %)) 
                           (range 2 k)))
            (iterate inc 2))))
mbakhterev's solution:
1
(fn [n] (->> (iterate inc 2) ((fn R [[m & M]] (lazy-cat [m] (R (filter (fn [i] (< 0 (mod i m))) M))))) (take n)))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn primes--recur
  ([]
   (let [inc2        (partial + 2),
         divides?    (fn [a d]
                       (= 0 (mod a d))),
         composite?  (fn [a]
                       (or (even? a)
                           (->> (iterate inc2 3)
                                (take-while (partial >= (Math/sqrt a)))
                                (some (partial divides? a)))))
         prime?      (fn [a]
                       (if (composite? a) false a))
         next-prime  (fn [a]
                       (some prime? (iterate inc2 (inc2 a))))]
     (cons 2 (iterate next-prime 3))))
  ([n] {:pre [(integer? n)]}
   (take n (primes--recur))))
mfikes's solution:
1
2
3
4
5
6
7
(fn primes [n]
  (if (= 1 n)
    [2]
    (let [prev-primes (primes (dec n))]
      (conj prev-primes (first (filter 
                                (fn [n] (not-any? zero? (map #(rem n %) prev-primes)))
                                (iterate inc (peek prev-primes))))))))
minitrue's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
(fn prime [k]
  (let [estimate-prime  ; http://stackoverflow.com/a/25440642
          (fn [n]
            (let [log-n (Math/log n)
                  log-log-n (Math/log log-n)
                  upper
                    (cond
                      (< n 6)
                        ([0 2 3 5 7 11] n)
                      (>= n 688383)
                        (* n (+ log-n log-log-n -1.0 (/ (- log-log-n 2.00) log-n)))
                      (>= n 178974)
                        (* n (+ log-n log-log-n -1.0 (/ (- log-log-n 1.95) log-n)))
                      (>= n 39017)
                        (* n (+ log-n log-log-n -0.9484))
                      :else
                        (* n (+ log-n (* 0.6 log-log-n))))]
                  (Math/ceil upper)))
        n (estimate-prime k)
        candi (range 2 (inc n))
        div-by (fn [divisor]
                   #(= (mod % divisor) 0))]
    (loop [curr k
           remain candi
           out []]
      (let [head (first remain)
            new-out (conj out head)]
        (if (= curr 1)
            new-out
            (recur (dec curr) (doall (remove (div-by head) (rest remain))) new-out))))))
mkahn's solution:
1
2
3
4
5
(fn primes [n]
  (letfn [(primeseq [coll]
                    (cons (first coll)
                          (lazy-seq (primeseq (remove #(== (mod % (first coll)) 0) (rest coll))))))]
    (take n (primeseq (rest (rest (range)))))))
mobiusloop's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [p]
(letfn 
 [(prime? [n]
  (empty? 
    (filter 
      (fn [x] (= 0 (mod n x))) 
      (range 2 (inc (Math/sqrt n)))
  )))]
  (take p (cons 2 (drop 2 (filter prime? (range)))))
)
)
mononite's solution:
1
2
3
4
(fn [n]
  (take 
   n
   (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))
mouse's solution:
1
(fn [m] (take m (drop 2 (filter (fn [n] (not-any? #(= 0 (rem n %)) (range 2 n))) (range)))))
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn prime [n]
  (letfn [(smallest-divisor [n]
            (loop [i 3]
              ;need only test odd divisors between 3 and (sqrt n)
              (when (<= (* i i) n) 
                (if (zero? (mod n i))
                  i
                  (recur (+ i 2))))))
          (next-prime [prev-prime]
            (loop [prime (+ 2 prev-prime)]
              (if (smallest-divisor prime)
                (recur (+ prime 2))
                prime)))
          (prime-seq []
            (cons 2 (iterate next-prime 3)))]
    (take n (prime-seq))))
nagi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
#(take %
                    [2, 3, 5, 7, 11, 13,            17, 19, 23, 29, 31,
                     37, 41, 43, 47, 53,            59, 61, 67, 71, 73,
                     79, 83, 89, 97, 101,           103, 107, 109, 113, 
                         127, 131, 137,                139, 149, 151, 
            
            
            157, 163,                                                                        167, 173,
            179, 181,                                                                        191, 193,
            197, 199,                                                                       211, 223,
             227, 229,                                                           233, 239, 241, 251,
              257, 263, 269, 271, 277, 281,  283, 293, 307, 311,  313, 317,    331, 337, 347, 349,
              353, 359, 367, 373, 379, 383, 389, 397,  401,  409, 419, 421, 431, 433, 439, 443,
                449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557])
nikelandjelo's solution:
1
2
3
4
5
6
7
(fn primes [x]
  (let [prime? (fn [x]
    (->> (range 2 x)
      (map #(rem x %))
         (map zero?)
         (every? false?)))]
  (take x (filter prime? (iterate inc 2)))))
noiseehc's solution:
1
(fn [x] (take x (filter (fn [n] (every? #(not= (mod n %) 0) (range 2 n))) (iterate inc 2))))
norman's solution:
1
2
3
4
5
6
7
8
9
(fn primes [n]
  (letfn [(isprime [num ps]
            (not-any? #(zero? (mod num %)) ps))]
    (if (= n 1)
      [2]
      (let [pastprimes (primes (dec n))
            totest     (iterate inc (inc (last pastprimes)))
            nextprime  (first (filter #(isprime % pastprimes) totest))]
         (conj pastprimes nextprime)))))
nothsaevets's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn [x]
   (take x ((fn sieve
              ([] (sieve [2] 2))
              ([primes n]
               (cons n
                     (lazy-seq
                       (let [next (first
                                    (drop-while
                                      (fn [i] (some (fn [p] (zero? (mod i p))) primes))
                                      (drop (inc n) (range))))]
                         (sieve (conj primes next) next)))))))))
owk4057's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn [n]
  (let [prime? 
        (fn [a] 
          (->> (range 1 a)
               (filter #(zero? (rem a %)))
               count
               (= 1)))]
               
                        
  (->> (map inc (range))
       (filter prime?)
       (take n))))
ownwaterloo's solution:
1
2
3
4
(fn [n]
  (->> (iterate inc 2)
    (filter (fn [x] (every? #(not (zero? (mod x %))) (range 2 x))))
  (take n)))
ozan's solution:
1
2
3
4
5
6
7
8
(fn [n]
  (loop [primes [2 3]
         candidate 5]
    (if (= n (count primes))
      primes
      (if (every? #(> (mod candidate %) 0) primes)
        (recur (conj primes candidate) (+ 2 candidate))
        (recur primes (+ 2 candidate))))))
pukeface's solution:
1
2
3
4
5
6
(fn [g] (take g
              (filter (fn [n]
                        (every? #(> % 0)
                                (map #(mod n %)
                                     (range 2 (- n 1)))))
                      (drop 2 (range)))))
quant1's solution:
1
2
3
(fn [n]
  (letfn [(prime-seq [[x1 & x]] (lazy-seq (cons x1 (prime-seq (remove #(= 0 (mod % x1)) x)))))]
            (take n (prime-seq (drop 2 (range))))))
rodmax's solution:
1
2
3
4
5
6
7
8
9
10
11
12
#(letfn
      ;; SICP http://mitpress.mit.edu/sicp/full-text/sicp/book/node71.html
      [(sieve [stream]
         (lazy-seq
          (cons
           (first stream)
           (sieve
            (filter 
             (fn [n] ((complement zero?) (rem n (first stream))))
             (rest stream))))))]
   (take % (sieve (drop 2 (range))))
)
sbondaryev's solution:
1
2
3
4
5
(fn f [k]
  (->> (range)
       (drop 2)
       (remove (fn [n] (some integer? (map #(/ n %) (range 2 n)))))
       (take k)))
shiro's solution:
1
2
3
4
5
6
7
8
9
10
(fn first-n-primes [n]
  (let [top-num (Math/ceil (+ (* n (Math/log n)) (* n (Math/log (Math/log n)))))]
    (loop [coll (rest (rest (take (+ 5 top-num) (range))))
           primes []]
      (if (= (count primes) n)
          primes
        (let [no-div (filter #(> (mod % (first coll)) 0) coll)]
          (recur 
            no-div
            (conj primes (first coll))))))))
sheldon's solution:
1
(fn [n] (take n (filter #(empty? (for [i (range 2 (inc (quot % 2))) :when (zero? (mod % i))] i)) (range 2 999))))
silverio's solution:
1
2
3
4
5
6
(fn [k] (take k
  (loop [p [] s (range 2 (int (* 4 k (Math/log k))))]
    (let [n (first s)
          x (group-by #(zero? (mod % n)) s)
          r (x false)]
      (if (x true) (recur (conj p n) r) (concat p r))))))
skyrem's solution:
1
2
3
4
5
6
7
(fn [c]
    (take c
          (lazy-cat [2 3]
           (filter 
            #(every? nil? (for [x (range 2 (inc (int (Math/sqrt %))))] (if (= 0 (mod % x)) false)))
            (drop 4 (range))
            ))))
soul_awaker's solution:
1
2
3
4
5
6
7
#((fn get-prime [i a]
  (if (= (count i) %)
      i
      (if (not-any? (comp zero? (partial rem a)) i)
          (get-prime `[~@i ~a] (inc a))
          (get-prime i (inc a)))))
[2] 3)
staafl2's solution:
1
2
3
4
(fn
  [x]
  (let [is-prime (fn [n] (every? #(< 0 (mod n %)) (take-while #(<= (* % %) n) (drop 2 (range)))))]
    (take x (filter is-prime (drop 2 (range))))))
syeerzy's solution:
1
2
3
4
5
6
(fn [n] 
  (->>
  (range)
  (drop 2)
  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))
  (take n)))
tclamb's solution:
1
2
3
4
5
6
7
8
9
10
11
(letfn [(prime? [n] (not-any? #(zero? (mod n %)) (range 2 n)))
        (primes [] (filter prime? (iterate inc 2)))]
  (fn [n]
    (take n (primes))))
;
;(letfn [(composite? [n]
;                    (some zero? (map #(mod n %) (drop 2 (range n))))) ;skip 0 and 1
;        (primes []
;                (filter (complement composite?) (iterate inc 2)))]
;  (fn [n]
;    (take n (primes))))
thegeez's solution:
1
2
3
4
5
(fn [n]
  (take n
    (cons 2 (remove (fn [candidate]
      (some #(zero? (mod candidate %)) (range 3 (/ candidate 2))))
(iterate #(+ 2 %) 3)))))
zzamboni's solution:
1
2
3
4
5
6
(fn first-primes [n]
  (letfn [(prime? [x] (every? #(not= 0 (mod x %)) (range 2 x)))]
    (->> (range)
         (drop 2)
         (filter prime?)
         (take n))))
zoltanjarai's solution:
1
2
3
(fn p67 [n]
  (letfn [(prime? [x] (not-any? zero? (map #(rem x %) (range 2 x))))]
    (take n (filter prime? (iterate inc 2)))))
zipzop's solution:
1
2
3
4
5
6
(fn [x]
 (take x
  ((fn sieve [s]
   (cons (first s)
    (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))(rest s))))))
      (iterate inc 2))))
yusubori's solution:
1
2
3
4
5
6
7
(fn [n]
  (let [f (fn [[primes x]]
            (if (some #(zero? (mod x %))primes)
              [primes (inc x)]
              [(conj primes x) (inc x)]))]
    (ffirst (filter #(= n (count (first %))) 
                    (iterate f [[] 2])))))
ydash's solution:
1
2
3
4
5
6
(fn [n]
  (take n
        (cons 2
              (filter
               (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i)))
               (iterate #(+ 2 %) 3)))))
vpeurala's solution:
1
2
3
4
5
6
7
(fn [n] (letfn [
(potential-divisors [n] (take-while #(< % (inc (quot n 2))) (cons 2 (range 3 (inc (quot n 2)) 2))))
(divisors [n] (filter #(zero? (rem n %)) (potential-divisors n)))
(prime? [n] (zero? (count (divisors n))))
(primes [] (filter prime? (cons 2 (iterate #(+ % 2) 3))))
(first-n-prime-numbers [n] (take n (primes)))
] (first-n-prime-numbers n)))
v_bogdanov's solution:
1
2
3
4
5
6
7
(fn primes [n]
  (loop [p [2 3]
         c 5]
    (if (= (count p) n) p
      (recur (if (every? ratio? (map #(/ c %) (take-while #(<= (* % %) c) p)))
               (conj p c) p)
             (+ 2 c)))))
unionx's solution:
1
2
3
4
5
6
7
(fn [n]
  (loop [cnt 1 start 2 ret []]
    (if (> cnt n)
      ret
      (if (.isProbablePrime (BigInteger/valueOf start) 5)
        (recur (inc cnt) (inc start) (conj ret start))
        (recur cnt (inc start) ret)))))
trxeste's solution:
1
2
3
4
5
6
7
(fn prime-gen [cnt]
  (let [prime? (fn [n]
                 (not (some #(and
                               (not= n %)
                               (zero? (mod n %)))
                            (range 2 (inc (Math/sqrt n))))))]
    (take cnt (filter prime? (iterate inc 2)))))
transfinite's solution:
1
2
3
4
5
6
7
(fn [n]
  (take n (filter (fn [n]
                    (cond
                     (> 2 n) false
                     (= 2 n) true
                     :else (< 0 (apply min (map #(mod n %) (range 2 (inc (Math/sqrt n))))))))
                  (map (comp inc inc) (range)))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)