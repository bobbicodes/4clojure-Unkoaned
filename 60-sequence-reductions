;; 60 Sequence Reductions

Like reduce, but returns
each intermediate value of reduction.
Accepts two or three arguments,

(= (take 5 (__ + (range))) [0 1 3 6 10])	
(= (__ conj [1] [2 3 4]) [[1] [1 2] [1 2 3] [1 2 3 4]])
(= (last (__ * 2 [3 4 5])) (reduce * 2 [3 4 5]) 120)

(fn my-reduce
  ([op input]
    (my-reduce op
      (first input)
      (rest input)))
  ([op result input]
    (lazy-seq
      (if (empty? input)
        (list result)
        (cons result
          (my-reduce op
            (op result (first input))
            (rest input)))))))

user> (take 5 ((fn my-reduce
  ([op input]
    (my-reduce op
      (first input)
      (rest input)))
  ([op result input]
    (lazy-seq
      (if (empty? input)
        (list result)
        (cons result
          (my-reduce op
            (op result (first input))
            (rest input))))))) + (range)))
(0 1 3 6 10)

(fn m-reductions
  ([op v col] (m-reductions op (cons v col)))
  ([op [h & tail]]
   (->>
    (iterate (fn [[v [h & tail :as col]]]
               (if (empty? col)
                 [v]
                 [(op v h) tail]))
             [h tail])
    (take-while next)
    (map first))))

(fn mf
  ([f [a1 & s1]] 
   (lazy-seq (cons a1 (mf f (cons (f a1 (first s1)) (rest s1))))))
  ([f sa [a1 & s1]]
   (take (+ 2 (count s1)) (lazy-seq (cons sa (mf f (f sa (if (nil? a1) 0 a1)) s1))))))

(fn myReductions
  ([f preVal coll]
   (lazy-seq
    (if-let [firstVal (first coll)];if there is still some items left
      (cons preVal (myReductions f (f preVal firstVal) (rest coll)));lazy recipe
      (list preVal))));last item shall be containted by a seq
  ([f coll]
    (myReductions f (first coll) (rest coll))))

(fn r
  ([f xs] (r f (first xs) (rest xs)))
  ([f v xs]
    (lazy-seq 
      (cons v
        (if (empty? xs) [] (r f (f v (first xs)) (rest xs)))))))
aceeca1's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn red
  ([f coll]
     (lazy-seq
      (if-let [s (seq coll)]
        (red f (first s) (rest s))
        (list (f)))))
  ([f init coll]
     (cons init
           (lazy-seq
            (when-let [s (seq coll)]
              (red f (f init (first s)) (rest s)))))))
adereth's solution:
1
2
3
4
5
6
(fn r ([f v s]
           (lazy-seq
            (cons v
                  (if (seq s)
                    (r f (f v (first s)) (rest s))))))
  ([f s] (r f (first s) (rest s))))
aferrandi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn  [op & x] 
(
let [reductions2 
(fn  red2 [op reduction x]  
(lazy-seq (if (empty? x) [reduction] 
(let [newreduction (op reduction (first x))] 
(cons reduction 
(red2 op newreduction (rest x)))))))
]
(if (= (count x) 2)
(lazy-seq (reductions2 op (first x) (second x)))
(lazy-seq (reductions2 op (first (first x)) (rest (first x))))))
)
aguirre's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [x y & z]
     (letfn [(rns [f zero xs] 
                  (lazy-cat [zero]
                  ((fn iter [ys prevVal]
                     (if (empty? ys) []
                                   (let [nextVal (f prevVal (first ys))
                                         restys (rest ys)]
                                   (lazy-cat [nextVal]
                                               (iter (rest ys) nextVal)))))
                  xs zero)))]
     (if (nil? z)
       (rns x (first y) (rest y))
       (rns x y (first z)))))
alanforr's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(letfn [(reddy
            ([f coll]
               (lazy-seq
                (if-let [s (seq coll)]
                  (reddy f (first s) (rest s))
                  (list (f)))))
            ([f init coll]
               (cons init
                     (lazy-seq
                      (when-let [s (seq coll)]
                        (reddy f (f init (first s)) (rest s)))))))]
   (fn ([g c] (reddy g c))
     ([g i c] (reddy g i c))))
allenl's solution:
1
2
3
4
5
6
7
8
(fn my-reductions
  ([op v col]
   (lazy-seq
    (cons v
          (if (first col)
            (my-reductions op (op v (first col)) (next col))))))
  ([op col]
   (my-reductions op (first col) (rest col))))
andthorn's solution:
1
2
3
4
5
6
7
(fn me
  ([f l] (me f (first l) (next l)))
  ([f z l]
    (let [r (f z (first l)) l (next l)]
      (if l
        (cons z (lazy-seq (me f r l)))
        (list z r)))))
anjensan's solution:
1
2
3
4
(fn r 
  ([f s] (r f (first s) (rest s)))
  ([f x [a & b]]
    (if a (lazy-cat [x] (r f (f x a) b)) [x])))
astangl's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn
  ([f coll]
   (letfn [(r [a coll]
             (lazy-seq
               (if (seq coll)
                 (let [fst (first coll)
                       a' (f a fst)]
                   (cons a (r a' (rest coll))))
                 (list a))))]
     (if (seq coll)
       (r (first coll) (rest coll))
       (list (f)))))
  ([f val coll]
   (letfn [(r [a coll]
             (lazy-seq
               (if (seq coll)
                 (let [fst (first coll)
                       a' (f a fst)]
                   (cons a (r a' (rest coll))))
                 (list a))))]
     (if (seq coll)
       (r val coll)
       (list val)))))
austintaylor's solution:
1
2
3
4
5
6
7
8
9
10
(fn [f & args]
  (let [start (if (= 2 (count args)) (first args) (ffirst args))
        s (if (= 2 (count args)) (last args) (rest (last args)))]
    (letfn [(op [s l]
      (if (empty? s)
        s
        (cons
          (f l (first s))
          (lazy-seq (op (rest s) (f l (first s)))))))]
      (cons start (op s start)))))
awebb's solution:
1
2
3
4
(fn reds
  ([f coll] (when-let [s (seq coll)] (reds f (first s) (rest s))))
  ([f init coll] 
    (cons init (lazy-seq (when-let [s (seq coll)] (reds f (f init (first s)) (rest s)))))))
bendykst's solution:
1
2
3
4
5
6
7
(fn reducts
  ([f [arg & args]]
    (reducts f arg args))
  ([f v [arg & args]]
    (if-not arg
      (list v)
      (cons v (lazy-seq (reducts f (f v arg) args))))))
benhammond's solution:
1
2
3
(fn r
           ([f [x & xs]] (lazy-seq (r f x xs)))
           ([f x xs] (cons x (lazy-seq (if (empty? xs) '() (r f (f x (first xs)) (rest xs)))))))
benizi's solution:
1
2
3
4
5
6
7
8
(fn reduced
  ([f coll]
   (reduced f (first coll) (rest coll)))
  ([f v coll]
   (lazy-seq
    (if-let [s (seq coll)]
      (cons v (reduced f (f v (first s)) (rest s)))
      [v]))))
bobuhiro11's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn reduction
  ([f coll]
     (lazy-seq
      (if-let [s (seq coll)]
        (reduction f (first s) (rest s))
        (list (f)))))
  ([f init coll]
     (cons init
           (lazy-seq
            (when-let [s (seq coll)]
              (reduction f (f init (first s)) (rest s)))))))
burner's solution:
1
2
3
4
5
(fn reds 
        ([f s] (lazy-seq (reds f (first s) (rest s))))
        ([f val s]
           (if (empty? s) [val]
               (lazy-seq (cons val (reds f (f val (first s)) (rest s)))))))
caterpillar's solution:
1
2
3
4
5
6
7
(fn myReduct
  ([f x s]
   (if (seq s) 
     (cons x (lazy-seq (myReduct f (f x (first s)) (rest s))))
     (list x)))
  ([f s]
   (myReduct f (first s) (rest s))))
cc787's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn r 
  ([f x]
   (if (empty? (rest x))
     (list (first x))
     (lazy-seq
      (cons (first x) (r f (cons (f (first x) (second x)) (drop 2 x)))))))
  ([f s x]
   (if (empty? x)
     (list s)
     (lazy-seq
      (cons s (r f (cons (f s (first x)) (drop 1 x)))))))
  )
chunchangshao's solution:
1
(fn a ([f x xs] (lazy-seq (if-let [t (first xs)] (cons x (a f (f x t) (rest xs))) [x]))) ([f xs] (a f (first xs) (next xs))))
ctzsm's solution:
1
2
3
4
5
6
7
8
9
(fn res
  ([f coll]
    (lazy-seq
      (if-let [s (seq coll)]
        (res f (first s) (rest s)) (list (f)))))
  ([f init coll]
    (cons init
      (lazy-seq
        (when-let [s (seq coll)] (res f (f init (first s)) (rest s)))))))
dan7es's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn folds
  ([f xs]
   (if-let [[x & xs] (seq xs)]
     (folds f x xs)
     [(f)]))
    
  ([f init xs]
   (lazy-seq
    (cons
     init
     (if-let [[x & xs] (seq xs)]
       (folds f (f init x) xs))))))
daniels's solution:
1
2
3
4
(fn r 
  ([o a] (r o (first a) (rest a))) 
  ([o p a] (if (empty? a) [p] (cons p (lazy-seq (r o (o p (first a)) (rest a))))))
)
daowen's solution:
1
2
3
4
5
(fn folds
  ([f [x & xs]] (folds f x xs))
  ([f acc [x & xs]] 
    (lazy-seq
      (cons acc (if x (folds f (f acc x) xs))))))
del680202's solution:
1
2
3
4
5
(fn _reduce
 ([f c] (cons (first c) (lazy-seq (_reduce f (f (first c) (second c)) (next (next c)) true))))
 ([f arg c] (cons arg (lazy-seq (_reduce f (f arg (first c)) (next c) true))))
 ([f r c n] (if (not (nil? (first c))) (cons r (lazy-seq (_reduce f (f r (first c)) (next c) true))) [r]))
)
deping's solution:
1
2
3
4
5
6
7
8
9
(fn myreduce 
  ([fc vl coll] 
   (if (empty? coll) [vl]
     (let [r1 (fc vl (first coll)) 
           rr (cons vl (lazy-seq (myreduce fc r1 (rest coll))))] 
       rr)
     ))
  ([fc coll] (myreduce fc (first coll) (rest coll)))
  )
devm33's solution:
1
2
3
4
5
6
7
8
9
10
(fn rdctns
  ([f xs]
   (lazy-seq
     (when-let [s (seq xs)]
       (rdctns f (first s) (next s)))))
  ([f v xs]
   (cons v
         (lazy-seq
           (when-let [s (seq xs)]
             (rdctns f (f v (first s)) (rest s)))))))
dwelte's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [of & vs]
  ((fn rrr [f xs current]
     (lazy-seq
      (if (empty? xs)
        (list (f current))
        (cons
         (f current)
         (rrr
          f
          (rest xs)
          (conj current (first xs)))))))
   (if (empty? (rest vs)) (partial reduce of (first (last vs)))  (partial reduce of (first vs)))
   (if (empty? (rest vs)) (rest (last vs)) (last vs))
   []))
dzholev's solution:
1
2
3
4
5
(fn my-reducers
  ([f s] (my-reducers f (first s) (rest s)))
  ([f in s] (cons in (if (empty? s)
                               []
                               (lazy-seq (my-reducers f (f in (first s)) (rest s)))))))
echevarria's solution:
1
2
3
4
5
6
(fn my-reduce 
 ([ f [a & r]] (my-reduce f a r))
 ([ f a r]
    (if (empty? r)
        (list a)
        (cons a (lazy-seq (my-reduce f (f a (first r)) (next r)))))))
ericw's solution:
1
2
3
4
5
6
(fn my-reductions                                                                                                                                       
    ([f coll] (my-reductions f (first coll) (rest coll)))                                                                       
    ([f val coll] (if (empty? coll)                                                                                                                     
        [val]                                                                                                                   
        (let [new-val (f val (first coll))]                                                                                                             
            (cons val (lazy-seq (my-reductions f new-val (rest coll))))))))
featalion's solution:
1
2
3
4
5
6
7
8
(fn rd
  ([f coll]
   (if-let [sq (seq coll)]
     (rd f (first sq) (rest sq))
     (list (f))))
  ([f init coll]
   (cons init (lazy-seq (when-let [sq (seq coll)]
                          (rd f (f init (first sq)) (rest sq)))))))
finsternis's solution:
1
2
3
(fn my-reductions
  ([f [x & xs]] (my-reductions f x xs))
  ([f v [x & xs]] (lazy-seq (cons v (when x (my-reductions f (f v x) xs))))))
flububb's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn seq-reduce
  ([f s]
    (seq-reduce f (first s) (rest s)))
  ([f r s]
    (cons r (seq-reduce true f r s)))  
  ([_ f r [a & s]]
    (if (nil? s)
      [(f r a)]
      (lazy-seq
        (cons 
          (f r a) 
          (seq-reduce true f (f r a) s))))))
garyxia's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn my-reduce
 
  ([op input] (my-reduce op (first input) (rest input)))
 
  ([op result input]
 
  (lazy-seq
    (if (empty? input) (list result)
      (cons result
            (my-reduce op
                 (op result (first input))
                 (rest input)))))))
geekerzp's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn my-reductions
    ([f coll]
     (lazy-seq
      (if-let [s (seq coll)]
        (my-reductions f (first s) (rest s))
        (list (f)))))
    ([f init coll]
     (cons init
           (lazy-seq
            (when-let [s (seq coll)]
              (my-reductions f (f init (first s)) (rest s)))))))
glchapman's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(letfn [(myreductions
    ([f coll] 
        (when (seq coll) (myreductions f (first coll) (rest coll))))
    ([f zero coll]
        (lazy-seq
            (if (seq coll)
                (cons zero (myreductions f (f zero (first coll)) (rest coll)))
                (list zero)
            ))))]
 
  myreductions
)
goaranger's solution:
1
2
3
(fn myreductions
  ([f se] (myreductions f (first se) (rest se)))
  ([f a se] (cons a (lazy-seq (if (first se) (myreductions f (f a (first se)) (rest se)))))))
gpittarelli's solution:
1
2
3
4
5
6
7
8
(fn reductions'
  ([op l] (reductions' op (first l) (rest l)))
  ([op acc l]
   (let [[[x] xs] (split-at 1 l)
         val (op acc x)]
     (if-not (empty? xs)
       (cons acc (lazy-seq (reductions' op val xs)))
       (list acc val)))))
happycrisis's solution:
1
2
3
4
5
(fn rr 
  ([f s] (rr f (first s) (rest s)))
  ([f init s] 
   (lazy-seq (cons init (when (not (empty? s)) 
                          (rr f (f init (first s)) (rest s)))))))
hisba's solution:
1
2
3
4
(fn mreductions
    ([func start vec] (mreductions func (cons start vec)))
    ([func [v_first v_sec & v_rest]]
     (cons v_first (lazy-seq (when v_sec (mreductions func (cons (func v_first v_sec) v_rest)))))))
icamts's solution:
1
2
3
4
5
(fn r 
  ([f c] 
   (lazy-seq (if-let [s (seq c)] (r f (first s) (rest s)) (list (f)))))
  ([f a c] 
   (cons a (lazy-seq (when-let [s (seq c)] (r f (f a (first s)) (rest s)))))))
immo's solution:
1
Scored 177, before 4clojure started saving solutions.
jarlax's solution:
1
2
3
4
5
6
7
(fn !
  ([f [x & xs]] (! f x xs))
  ([f e [x & xs]]
    (let [n (f e x)]
      (if (not-empty xs)
        (cons e (lazy-seq (! f n xs)))
        [e n]))))
jedo's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn reduc 
  ([f coll]
        (reduc f (first coll) (rest coll))
    )
    ([f arg coll]
        (letfn [(iter [left right]
            (cond (empty? right) right
                  :else (let [v (f (last left) (first right))]
                        (cons v (lazy-seq (iter (list v) (rest right))))
                )
            )
        )]
        (cons arg (iter (list arg) coll))
        )
    )
)
jeff_terrell's solution:
1
2
3
4
5
6
7
8
(fn _
  ([f xs] (_ f (first xs) (rest xs)))
  ([f x0 xs]
   (lazy-seq
     (if (empty? xs)
       [x0]
       (cons x0
             (_ f (f x0 (first xs)) (rest xs)))))))
johncowie's solution:
1
2
(fn r ([f i v] (conj (let [x (atom i)] (for [y v] (swap! x #(f % y)))) i))
      ([f v] (r f (first v) (rest v))))
jomicoll's solution:
1
2
3
4
5
6
7
8
(fn rf
  ([f coll] (rf f (first coll) (rest coll)))
  ([f init coll]
   (lazy-seq 
    (if (empty? coll)
      (list init)
      (cons init
        (rf f (f init (first coll)) (rest coll)))))))
jorendorff's solution:
1
2
3
4
5
6
7
8
(fn r
  ([f s] (if (empty? s)
           nil
           (r f (first s) (rest s))))
  ([f v s]
   (cons v (lazy-seq (if (empty? s)
                       '()
                       (r f (f v (first s)) (rest s)))))))
jslavin's solution:
1
2
3
4
5
6
7
8
(fn myreduce
  ([f coll] (myreduce f (first coll) (rest coll)))
  ([f init coll]
   (if (nil? (first coll))
     (lazy-cat (vector init))
     (when-let [s (seq coll)]
       (lazy-cat (vector init) (myreduce f (f init (first s)) (rest s)))
       ))))
kohyama's solution:
1
2
3
(fn d
  ([f x [h & r]] (cons x (if h (lazy-seq (d f (f x h) r)))))
  ([f [h & r]] (d f h r)))
kopychenko's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn sequence-reductions [& args]
   (letfn [(red [f vv & aa] 
             (lazy-seq
              (let [a (if (empty? aa) (first vv) (first aa))
                    v (if (empty? aa) (rest vv) vv)]
                
                (if (empty? v) [a]
                    (cons a (red f (rest v) (f a (first v)))))
 
                ))) 
 
             (handler
              ([f v]
                 (red f v))
              ([f a v]
                 (red f v a)))]
           
           (apply handler args)))
blucas's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn prob60
  ([f coll] 
   (prob60 f (first coll) (rest coll)))
  ([f v coll] 
   (if (seq coll)
     (let [next-v (f v (first coll))
           next-coll (rest coll)
           ]
       (cons v (lazy-seq (prob60 f next-v next-coll)))
       )
     (cons v (lazy-seq '())))))
brendan's solution:
1
2
3
(fn r
  ([f [x & xs]] (r f x xs))
  ([f v [x & xs]] (lazy-seq (cons v (when x (r f (f v x) xs))))))
kuze's solution:
1
2
3
4
5
6
7
8
9
(fn myReductions
  ([fun init coll]
    (lazy-seq
        (if (seq coll)
          (let [newInit (fun init (first coll))]
            (cons init (myReductions fun newInit (rest coll))))
          (cons init []))))
  ([fun coll]
    (rest (myReductions fun 0 coll))))
lackita's solution:
1
2
3
4
5
6
7
8
9
(fn redctns
  ([fun coll] (redctns fun (first coll) (rest coll)))
  ([fun start coll] ((fn helper [p c]
                       (if (empty? c)
                         [p]
                         (cons p
                               (lazy-seq (helper (fun p (first c))
                                                 (rest c))))))
                     start coll)))
lambda4fun's solution:
1
2
3
4
5
6
(fn r
  ([f acc xs] (cons acc
                    (lazy-seq
                     (if (seq xs)
                       (r f (f acc (first xs)) (rest xs))))))
  ([f xs] (r f (first xs) (rest xs))))
lasthemy's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn redux
    ([f coll]
       (if (seq coll)
         (redux f (first coll) (rest coll))
         )
     )
    ([f init coll]
      (cons init
            (lazy-seq
             (when (seq coll)
               (redux f (f init (first coll)) (rest coll))
               )
             )
            )
     )
    )
lbarrett's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(letfn
  [(red
     ([f carry l]
      (if (= '() l)
        (list carry)
        (lazy-seq
          (let [v (f carry (first l))]
            (cons carry (red f v (rest l)))))))
     ([f l]
      (if (= '() l)
        '()
        (red f (first l) (rest l)))))]
  red)
leetwinski's solution:
1
2
3
4
5
6
7
8
(letfn
  [(my-red [f i [h & t :as ls]]
    (let [h-p (f i h)]
      (if (empty? t) [h-p]
        (lazy-cat [h-p] (my-red f h-p t)))))]
    (fn
      ([f [h & t]] (cons h (my-red f h t)))
      ([f i [h & t :as ls]] (cons i (my-red f i ls)))))
littlejp2046's solution:
1
2
3
4
5
6
7
(fn red 
  ([f l] (red f (first l) (rest l)))
  ([f s l] 
    (lazy-seq
      (if (empty? l)
        [s]
        (cons s (red f (f s (first l)) (rest l)))))))
malvert's solution:
1
2
3
4
5
(fn [a b & [c]]
  (let [r (if (nil? c) b (cons b c))]
    (map
      #(reduce a (take % r))
      (map #(+ 1 %2) r (range)))))
matiasl's solution:
1
2
3
4
5
6
7
8
(fn r 
  ([f sq] 
   (r f (first sq) (rest sq))) 
  ([f a sq] 
   (lazy-seq 
    (cons a 
          (when (not (empty? sq)) 
            (r f (f a (first sq)) (rest sq)))))))
maximental's solution:
1
2
3
4
5
(fn g
  ([f [x & s]] (g f x s))
  ([f a [x & s]] 
    (lazy-seq       
        (cons a (if x (g f (f a x) s))))))
mbakhterev's solution:
1
(fn R ([f S] (let [[x & X] S] (if x (R f x X) (list (f))))) ([f i S] (cons i (lazy-seq (let [[x & X] S] (if x (R f (f i x) X)))))))
meerwolf's solution:
1
2
3
4
5
6
7
8
9
10
(fn reductions--lazy
  ([f init coll]
   (if (seq coll)
     (lazy-seq
      (cons init (reductions--lazy f (f init (first coll)) (rest coll))))
     (list init)))
  ([f coll]
   (if (seq coll)
     (reductions--lazy f (first coll) (rest coll))
     (list (f)))))
mfikes's solution:
1
2
3
4
5
6
7
8
9
(fn red [f b & c]
  (let [int-red (fn int-red [f coll acc]
                  (lazy-seq
                    (if (seq coll)
                      (let [next-val (f acc (first coll))]
                        (cons next-val (int-red f (rest coll) next-val))))))]
    (if c
      (cons b (int-red f (first c) b))
      (cons (first b) (int-red f (rest b) (first b))))))
minitrue's solution:
1
2
3
4
5
6
7
(fn g
  ([f [x & xs]]
      (g f x xs))
  ([f i [x & xs]]
    (cons i
      (if x
        (lazy-seq (g f (f i x) xs))))))
mkahn's solution:
1
2
3
4
5
6
7
8
9
(fn newreductions
  ([f init coll]
   (if (seq coll)
     (cons init (lazy-seq (newreductions f (f init (first coll)) (rest coll))))
     (vector init)))
  ([f coll]
   (if (seq coll)
     (lazy-seq (newreductions f (first coll) (rest coll)))
     '())))
mobiusloop's solution:
1
2
3
4
(fn red
  ([f l] (red f (first l) (rest l)))
  ([f i l] (cons i (lazy-seq (if (empty? l) '() (red f (f i (first l)) (rest l))))))
)
mononite's solution:
1
2
3
4
(fn my-reductions
  ([f xs] (if (empty? xs) xs (my-reductions f (first xs) (rest xs))))
  ([f i xs] 
   (cons i (if (empty? xs) xs (lazy-seq (my-reductions f (f i (first xs)) (rest xs)))))))
mouse's solution:
1
2
3
4
5
6
7
8
9
(fn r
    ([f i s] (r f (list* i s)))
    ([f   s] (map #(reduce f %)
                  ((fn b [x [h & t]]
                     (lazy-seq
                      (cons (conj x h)
                            (when (seq t) (b (conj x h) t))) ))
                   [] s)))
    )
mwaldowski's solution:
1
2
3
4
5
6
7
8
9
(fn my-reductions
  ([f coll]
   (my-reductions f (first coll) (rest coll)))
  ([f val coll]
   (if-let [first (first coll)]
     (cons val (lazy-seq (my-reductions f
                                        (f val first)
                                        (rest coll))))
     (list val))))
nagi's solution:
1
2
3
4
5
6
7
8
(fn reduc
  ([func seq]
   (reduc func (first seq) (rest seq)))
  ([func val seq]
   (cons val
         (if (empty? seq)
           '()
           (lazy-seq (reduc func (func val (first seq)) (rest seq)))))))
nikelandjelo's solution:
1
2
3
4
5
6
7
8
(fn my-reduct
             ([fnn init args]
             (if (empty? args)
               [init]
               (lazy-cat [init]
                 (my-reduct fnn (fnn init (first args)) (rest args)))))
             ([fnn args]
               (my-reduct fnn (first args) (rest args))))
noiseehc's solution:
1
2
3
4
5
6
7
(fn red 
   ([f [a b & coll]] (cons a (red f (f a b) coll)))
   ([f res coll] (if (empty? coll) 
                  (list res)
                  (let [[cur & r] coll
                        next (f res cur)] 
                    (lazy-seq (cons res (red f next r)))))))
norman's solution:
1
2
3
4
5
6
7
8
(fn reduct
  ([f items]
     (reduct f (first items) (rest items)))
 
  ([f prior items]
     (if (seq items)
       (lazy-seq (cons prior (reduct f (f prior (first items)) (rest items))))
       (list prior) )))
nothsaevets's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
(fn reducto
           ([f vals]
            (reducto f (first vals) (rest vals)))
           ([f init vals]
            (cons init
                  ((fn inner
                     [acc src]
                     (when (seq src)
                       (let [[head tail] ((juxt first rest) src)
                             result (f acc head)]
                         (cons result
                               (lazy-seq (inner result tail))))))
                    init vals))))
owk4057's solution:
1
2
3
4
5
6
(fn myf
  ([f i coll]
   (if (empty? coll)
     (list i)
     (cons i (lazy-seq (myf f (f i (first coll)) (rest coll))))))
  ([f coll] (myf f (first coll) (rest coll))))
ownwaterloo's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn scanl
  ([f coll]
     (lazy-seq
      (if-let [s (seq coll)]
        (scanl f (first s) (rest s))
        (list (f)))))
  ([f init coll]
     (cons init
           (lazy-seq
            (when-let [s (seq coll)]
              (scanl f (f init (first s)) (rest s)))))))
ozan's solution:
1
2
3
4
5
6
7
8
9
(fn seq-reductions                                                                                                                                                                                                                       
  ([f xs] (seq-reductions f (first xs) (rest xs)))                                                                                                                                                                                         
  ([f a xs]                                                                                                                                                                                                                                
   (lazy-seq                                                                                                                                                                                                                               
    (let [[b & others] xs                                                                                                                                                                                                                  
          comb (f a b)]                                                                                                                                                                                                                    
      (if (empty? others)                                                                                                                                                                                                                  
        (cons a [comb])                                                                                                                                                                                                                    
        (cons a (seq-reductions f comb others)))))))
pukeface's solution:
1
2
3
4
5
6
7
(fn R ([f a [x & r]]
         (cons a
               (if x
                 (lazy-seq (R f (f a x) r))
                 [])))
      ([f [x & r]]
       (R f x r)))
quant1's solution:
1
2
3
4
5
(fn red 
  ([f [x1 & r]] (red f x1 r))
  ([f x0 [x1 & r]] 
    (if (nil? x1) (list x0)
      (lazy-seq (cons x0 (red f (f x0 x1) r))))))
rodmax's solution:
1
2
3
4
5
6
7
8
9
10
(fn myred
    ([fcn aseq] (myred fcn (first aseq) (rest aseq)))
    ([fcn accum aseq] 
       (if (empty? aseq)
         (vector accum)
         (lazy-seq
          (cons 
           accum
           (myred fcn (fcn accum (first aseq)) (rest aseq))))
         )))
sbondaryev's solution:
1
2
3
4
5
6
(fn f
  ([op a] (f op (first a) (rest a)))
  ([op a b]
   (if (seq b)
     (lazy-seq (cons a (f op (op a (first b)) (rest b))))
     [a])))
shiro's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn cust-reductions
  ([f coll] (cust-reductions f (first coll) (next coll)))
  ([f init coll]
    (if (seq coll)
      (cons init 
        (lazy-seq 
          (cust-reductions 
            f
            (f init (first coll))
            (next coll))))
      (cons init (lazy-seq '())))))
sheldon's solution:
1
(fn r ([f c] (r f (first c) (rest c))) ([f i c] (if (empty? c) (cons i nil) (lazy-seq (cons i (r f (f i (first c)) (rest c)))))))
silverio's solution:
1
2
(fn red ([f [h & t]] (red f h t))
  ([f v [h & t]] (cons v (if (not (nil? h)) (lazy-seq (red f (f v h) t))))))
skyrem's solution:
1
2
3
4
5
6
7
8
(fn myred
  ([f coll]
  (myred f (first coll) (rest coll)))
  ([f arg coll]
   (lazy-seq
    (cons arg
          (if (empty? coll) []
            (myred f (f arg (first coll)) (rest coll)))))))
soul_awaker's solution:
1
2
3
4
5
6
7
(fn f
  ([op col] (f op (first col) (rest col)))
  ([op init [h & t]]
    (if (nil? h)
        [init]
        (concat [init]
          (lazy-seq (f op (op init h) t)))) ))
staafl2's solution:
1
2
3
4
5
6
7
8
9
10
11
(fn reds
  ([r s xs]
    (if
      (empty? xs)
      [s]
      (lazy-seq
        (cons
          s
          (reds r (r s (first xs)) (rest xs))))))
  ([r xs]
    (reds r (first xs) (rest xs))))
syeerzy's solution:
1
2
3
4
5
6
7
(fn r
  ([f [h & b]] (r f h b))
  ([f i [h & b]]
   (cons i 
         (lazy-seq
            (when h 
              (r f (f i h) b))))))
tclamb's solution:
1
2
3
4
5
6
7
(fn reductions'
  ([f s] (reductions' f (first s) (rest s)))
  ([f i s]
   (lazy-seq
    (if-let [x (first s)]
      (cons i (reductions' f (f i x) (rest s)))
      (list i)))))
thegeez's solution:
1
2
3
4
5
6
7
(fn r
    ([f [init & args]]
       (r f init args))
    ([f init args]
       (cons init (lazy-seq
                   (when args
                     (r f (f init (first args)) (next args)))))))
zzamboni's solution:
1
2
3
(fn my-reductions
  ([fun coll] (my-reductions fun (first coll) (rest coll)))
  ([fun init coll] (cons init (lazy-seq (when (seq coll) (my-reductions fun (fun init (first coll)) (rest coll)))))))
zoltanjarai's solution:
1
2
3
4
5
6
7
8
9
(fn __
  ([f l]
   (__ f (first l) (rest l)))
  ([f s l]
   (if (empty? l)
     [s]
     (let [t (f s (first l))]
       (cons s
             (lazy-seq (__ f t (rest l))))))))
zipzop's solution:
1
2
3
4
5
6
7
8
(fn r
  ([f xs] (r f (first xs) (rest xs)))
  ([f v xs]
    (lazy-seq 
      (cons v
        (if (empty? xs) 
          [] 
          (r f (f v (first xs)) (rest xs)))))))
yusubori's solution:
1
2
3
4
5
(fn red
  ([f coll] (red f (first coll) (rest coll)))
  ([f init coll]
   (if (empty? coll) [init]
     (lazy-seq (cons init (red f (f init (first coll)) (rest coll)))))))
ydash's solution:
1
2
3
4
5
6
7
(fn r
  ([f l] (r f (first l) (rest l)))
  ([f i l]
   (if (empty? l)
     [i]
     (lazy-seq (cons i
                     (r f (f i (first l)) (rest l)))))))
vpeurala's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
; (defn- make-accumulator ([function] { :function function, :steps [] }) ([function initial-value] { :function function, :steps [], :value initial-value }))
 
; (defn- update-accumulator [accumulator new-value] (if (contains? accumulator :value) (let [result-value ((:function accumulator) (:value accumulator) new-value)] { :function (:function accumulator), :value result-value, :steps (conj (:steps accumulator) result-value) }) { :function (:function accumulator), :value new-value, :steps (conj (:steps accumulator) new-value) }))
 
; (defn- reduct-seq [accumulator collection] (if (empty? collection) () (let [new-accumulator (update-accumulator accumulator (first collection))] (cons (:value new-accumulator) (lazy-seq (reduct-seq new-accumulator (rest collection)))))))
 
(fn reduct 
  ([function collection]
   (letfn [
     (make-accumulator ([function] { :function function, :steps [] }) ([function initial-value] { :function function, :steps [] }))
     (update-accumulator [accumulator new-value] (if (contains? accumulator :value) (let [result-value ((:function accumulator) (:value accumulator) new-value)] { :function (:function accumulator), :value result-value, :steps (conj (:steps accumulator) result-value) }) { :function (:function accumulator), :value new-value, :steps (conj (:steps accumulator) new-value) }))
     (reduct-seq [accumulator collection] (if (empty? collection) () (let [new-accumulator (update-accumulator accumulator (first collection))] (cons (:value new-accumulator) (lazy-seq (reduct-seq new-accumulator (rest collection)))))))]                
   (reduct-seq (make-accumulator function) collection)))
  ([function initial-value collection] 
   (letfn [
     (make-accumulator ([function] { :function function, :steps [] }) ([function initial-value] { :function function, :steps [] }))
     (update-accumulator [accumulator new-value] (if (contains? accumulator :value) (let [result-value ((:function accumulator) (:value accumulator) new-value)] { :function (:function accumulator), :value result-value, :steps (conj (:steps accumulator) result-value) }) { :function (:function accumulator), :value new-value, :steps (conj (:steps accumulator) new-value) }))
     (reduct-seq [accumulator collection] (if (empty? collection) () (let [new-accumulator (update-accumulator accumulator (first collection))] (cons (:value new-accumulator) (lazy-seq (reduct-seq new-accumulator (rest collection)))))))]
   (reduct-seq (make-accumulator function initial-value) (cons initial-value collection)))))
 
 
 
 
 
 
 
 
 
 
 
 
 
 
; (defn make-accumulator ([function] { :function function, :steps [] }) ([function initial-value] { :function function, :steps [], :value initial-value }))
 
; (defn update-accumulator [accumulator new-value] (if (contains? accumulator :value) (let [result-value ((:function accumulator) (:value accumulator) new-value)] { :function (:function accumulator), :value result-value, :steps (conj (:steps accumulator) result-value) }) { :function (:function accumulator), :value new-value, :steps (conj (:steps accumulator) new-value) }))
 
; (defn reduct-seq [accumulator collection] (if (empty? collection) () (let [new-accumulator (update-accumulator accumulator (first collection))] (cons (:value new-accumulator) (lazy-seq (reduct-seq new-accumulator (rest collection)))))))
 
; (defn reduct ([function collection] (reduct-seq (make-accumulator function) collection)) ([function initial-value collection] (reduct-seq (make-accumulator function initial-value) collection)))
v_bogdanov's solution:
1
2
3
4
5
6
(fn f ([g c]
  (let [fc (first c)]
    (if (empty? (drop 2 c)) 
        (cons fc [(g fc (last c))])
        (cons fc (lazy-seq (f g (cons (g fc (second c)) (drop 2 c))))))))
      ([g x0 c] (f g (cons x0 c))))
unionx's solution:
1
2
3
4
5
6
7
(fn reduction1
  ([f col]
     (reduction1 f (f (first col)) (rest col)))
  ([f val col]
     (if (empty? col)
       (list val)
       (cons val (lazy-seq (reduction1 f (f val (first col)) (rest col)))))))
trxeste's solution:
1
2
3
4
5
6
7
8
(fn reduce-
  ([f coll]
    (reduce- f (first coll) (next coll)))
  ([f init [h & t :as coll]]
    (cons init
      (lazy-seq
        (if (seq coll)
          (reduce- f (f init h) t))))))
transfinite's solution:
1
2
3
4
5
6
7
8
(fn [f a & b] 
  (let [coll (if b (first b) a) 
           f (if b
               (fn [x y] (reduce f a (take (inc x) coll)))
               (fn [x y] (reduce f (take (inc x) coll))))]
    (if b
      (cons a (keep-indexed f coll)) 
      (keep-indexed f coll))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)