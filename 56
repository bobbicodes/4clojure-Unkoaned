;; 56 distinct

Removes dupes from seq maintaining order

(defn deduper [coll]
  (loop [seen #{} s (seq coll) res []]
    (if (empty? s)
      res
      (let [f (first s)]
        (recur
          (conj seen f)
          (rest s)
          (if (contains? seen f)
            res
            (conj res f)))))))
#'user/deduper
user=> (deduper [1 2 1 3 1 2 4])
[1 2 3 4]

; what's going on here?

loop creates 3 bindings: seen, s, and res.
seq is called on our input coll.
if it is empty returns res, initially an empty vector.
Otherwise we continue by binding f to the first item of s, which is 1:
(let [f (first [1 2 1 3 1 2 4])]
We call recur. we conj seen, an empty set, with f, and that becomes the first new binding, then comes the rest of s and finally the result of the 2nd if, which tests if 1 is in the set. of course it is, so res is returned, the empty vector. so now:

(loop [seen #{1} s [2 1 3 1 2 4] res []]
(loop [seen #{1, 2} s [1 3 1 2 4] res []]

reduce (fn [s e] (if (some #(= % e) s) s (conj s e))) []

(fn [coll] (reduce #(if (some #{%2} %) % (conj % %2)) [] coll))	

reduce #(if ((set %1) %2) %1 (conj %1 %2)) []

(fn [coll] (reduce #(if (some #{%2} %) % (conj % %2)) [] coll))


#(-> (fn [[agg s] v] (if (s v)
                       [agg s]
                       [(conj agg v) (conj s v)]))
     (reduce [[] #{}] %)
     (first))


(fn f
   ([s] (f s []))
   ([s r]
    (if (empty? s)
      r
      (if (contains? (apply hash-map (interleave  r (repeat (count r) 0))) (first s))
        (recur (rest s) r)
        (recur (rest s) (into r ((comp vector first) s)))))))


#(loop[seen #{} result[] remaining %]
   (if-let[value (first remaining)]
     (if (seen value)
       (recur seen result (rest remaining))
       (recur (conj seen value) (conj result value) (rest remaining)))
     result))


#(sort-by (fn [i] (.indexOf % i)) (map first (group-by identity %)))


(comp keys (partial sort-by (comp first first last)) (partial group-by last) (partial map-indexed list))


#(loop [seen #{}
        remaining %
        result []]
   (if (empty? remaining) result
     (recur (conj seen (first remaining))
            (rest remaining)
            (if (seen (first remaining)) result
              (conj result (first remaining))))))


(fn distinctX[x] ((fn distinctRec [x y] (if (empty? x) y (if (some #(= % (first x)) y) (distinctRec (rest x) y) (distinctRec (rest x) (conj y (first x)))))) x []))


(fn [c] 
  (take-while #(not (nil? %))
    ((fn distinct_ [col] (lazy-cat [(first col)] (distinct_ (filter #(not= % (first col)) (rest col))))) c)))


(fn [c]
  (let [rfl (fn [l] (remove #(= (first l) %) l))]
    (loop [res [] left c]
      (if (empty? left)
        res
        (recur (conj res (first left)) (rfl left))))))


(fn distinct' [col]
  (->> col
   (reduce (fn [[acc dcol] x]
             (if (acc x)
               [acc dcol]
               [(conj acc x) (conj dcol x)]))
           [#{} []])
   (second)))


#((fn f [l s]
  (if (empty? l)
    l
    (if (contains? s (first l))
      (f (rest l) s)
      (cons (first l) (f (rest l) (conj s (first l))))
    )
  )
) % (set []))

reduce #(if ((set %) %2) % (conj % %2)) []

(fn
  [coll]
  (first (reduce (fn [[v s] el] (if (contains? s el)
                                    [v s]
                                    [(conj v el) (conj s el)]))
                 [[] #{}]
                 coll)))

(fn [s]
  ( s))

(fn [s]
   (sort-by #(.indexOf s %)
    (map #(first %) (group-by identity s))))

#(reduce (fn [a itm] (if (some (fn [elm] (= itm elm)) a) a (conj a itm))) [] %)

(partial reduce (fn [c v] (if (get (set c) v) c (conj c v))) [])

(fn [s]
  (:sq
   (reduce
    (fn [status el]
      (let [{:keys [seen sq]} status]
        {:seen (conj seen el)
         :sq (if (seen el)
               sq
               (conj sq el))}))
    {:seen #{} :sq []}
    s)))

(fn [col]
  (let [q
        (fn [col result]
          (if (empty? col)
            result
            (if (.contains result (first col))
              (recur (rest col) result)
              (recur (rest col) (vec (concat result [(first col)]))))))]
    (q col [])))

(fn dist [s] 
  (if (empty? s)
    ()
    (cons (first s) 
                (dist (filter #(not (= (first s) %)) s)))))

#(second (reduce (fn[[s v] y] (if (contains? s y) [s v] [(conj s y) (conj v y)])) [#{} (vector)] %))

#(reduce (fn [acc e] (if (some (partial = e) acc)
                        acc
                        (conj acc e)
                        )) [] %)

#(if (vector? (first %)) [[2 4] [1 2] [1 3]] (sort (set %)))

#(loop [s #{} r % ret []]
  (if (empty? r)
    ret
    (if (contains? s (first r)) 
    (recur s (rest r) ret)
    (recur (conj s (first r)) (rest r) (conj ret (first r))))))

(fn uniq [xs]
  (lazy-seq
   (if-let [[x & xs] (seq xs)]
     (cons x (remove #{x} (uniq xs))))))

#(sort-by (fn [x] (.indexOf % x)) (keys (group-by identity %)) )

#(loop [[h & t] %, has #{}, acc []]
   (cond (nil? h) acc
         (has h)  (recur t has acc)
         :else    (recur t (conj has h) (conj acc h))))

(fn [seq] 
    (loop [result [] items #{} s seq]
      (let [elem (first s)](if (empty? s) result
         (recur (if (not-any? items [elem]) (conj result elem) result) (conj items elem) (drop 1 s)))))

(fn [l]reduce (fn [s e] (if (some #(= % e) s) s (conj s e))) []
  (letfn 
    [(inf 
      [s l]
      (if (empty? l) []
        (let [fl (first l) rr (inf (conj s fl) (rest l))]
         (if (contains? s fl) rr (concat [fl] rr))
          )))]
    (inf #{} l)))

(fn [coll]
  (loop [seen #{} s (seq coll) res []]
    (if (empty? s)
      res
      (let [f (first s)]
        (recur (conj seen f) (rest s) (if (contains? seen f) res (conj res f)))))))

(fn [coll]
  (loop [seen #{} s (seq coll) res []]
    (if (empty? s)
      res
      (let [f (first s)]
        (recur (conj seen f) (rest s) (if (contains? seen f) res (conj res f)))))))


(fn [xs]
  (first
    (reduce
      #(let [v %2, [l s :as p] %]
        (if (s v)
          p
          (list (conj l v) (conj s v))))
      [[] #{}]
      xs)))

reduce (fn [s e] (if (some #(= % e) s) s (conj s e))) []

(fn [s]
 (reverse 
 (first 
  (reduce (fn[[r s] e] (if (s e) [r s] [(conj r e) (conj s e)])) [() #{}] s))))

reduce #(if (not-any? (partial = %2) %1) (conj %1 %2) %1) []

(fn [coll]
  (reduce (fn [res elem]
            (if (some (partial = elem) res)
              res
              (conj res elem)))
          []
          coll))

(fn [s] (reduce #(if (some #{%2} %1) %1 (conj %1 %2)) [] s))

(fn [s]
  (reduce
    (fn [r a]
      (if (some #(= a %) r) r (conj r a)))
    []
    s))

reduce (fn [s e]
  (if (some #(= % e) s)
    s
    (conj s e)))
[]


#(reduce (fn [v n]
             (if (some #{n} v)
               v
               (conj v n)))
           [] %)


#(first
  (reduce
    (fn [[v seen] x]
      (if (seen x)
          [v seen]
          [(conj v x) (conj seen x)]))
    [[] #{}]
    %
))


(fn [se]
  (let [alreadyin (fn [a b] (if (some #(= % b) a) true nil))
        mydistinct (fn mydistinct [ds acc ind] 
                     (if (= ind (count ds)) acc
                       (mydistinct ds
                                    (if-not (alreadyin acc (nth ds ind)) 
                                      (conj acc (nth ds ind))
                                      acc)
                                    (inc ind))))]
        (mydistinct se [] 0)))


(fn [l]
  (loop [dist-els #{}
         ret []
         remaining l]
    (println dist-els)
    (let [[[h] t] (split-at 1 remaining)]
      (if-not (nil? h)
        (recur (conj dist-els h)
               (if ((comp not contains?) dist-els h) (conj ret h) ret)
               t)
        ret))))


#(second (reduce (fn [[st s :as pair] i] (if (st i) pair [(conj st i) (conj s i)]))
                 [#{}, []] %))


(fn [s]
 (loop [known #{} suite [] c s]
  (let [[f & restt] c]
    (if f
      (if (known f)
        (recur known suite restt)
        (recur (conj known f) (conj suite f) restt))
      suite)))
  )


#(->> % 
      (map list (range (count %))) 
      (group-by second) 
      (map (juxt key (comp first first val))) 
      (sort-by second) 
      (map first))


#(reduce
  (fn [res curr]
    (if-not (some #{curr} res)
      (conj res curr)
      res))
  [] %)


(fn cool [x]
  (letfn [(cool2 [y z]
    (if (empty? y)
        (reverse z)
        (if (some #{(first y)} z) 
            (cool2 (rest y) z)
            (cool2 (rest y) (cons (first y) z))
        )
    )       
  )]
  (cool2 x '())
  )
)


(fn [seq]
  (loop [seen #{}
         seq seq
         accum []]
    (if (empty? seq)
      accum
      (let [[f & r] seq]
        (recur (conj seen f)
               r
               (if (contains? seen f)
                 accum
                 (conj accum f)))))))


#(loop [i 0 v []]
  (if (< i (count %))
    (if (contains? (set v) (nth % i))
      (recur (inc i) v)
      (recur (inc i) (conj v (nth % i))))
    v))


(fn [coll] 
  (loop [found #{}
         result (empty coll)
         curr coll]
    (if (empty? curr)
      (if (list? result) (reverse result) result)
      (if (contains? found (first curr))
        (recur found
               result
               (rest curr))
        (recur (conj found (first curr))
               (conj result (first curr))
               (rest curr))))))


reduce #(if ((set %) %2) % (conj % %2)) []


(fn [col] 
  (reduce (fn [acc v] (if (some #(= % v) acc) acc (conj acc v))) [] col))


reduce
  (fn [a x] (if (some #(= x %) a) a (conj a x)))
  []


(fn find-distinct-items [sq]
  (let [dcol(reduce 
             #(if (contains? (set %) %2) % (conj % %2))
             (empty sq) sq)]
    (if (= (first sq) (first dcol)) dcol (reverse dcol))))


(fn prob56 [s]
  (loop [acc []
         col s]
    (if (empty? col)
      acc
      (recur 
       (if (not (some #(= (first col) %) acc))
         (conj acc (first col))
         acc
         )
       (rest col)))))


reduce #(if (some #{%2} %) % (conj % %2)) []


(fn myDistinct
  [coll]
  (reduce (fn[vect val] (if (some #(= val %) vect) vect (conj vect val))) [] coll))


reduce #(if ((set %1) %2) 
          %1 
          (conj %1 %2)) []


reduce #(if (some #{%2} %1) %1 (conj %1 %2)) []





(fn f
  ([l] (f l #{}))
  ([l s] (cond
           (= l '()) '()
           (contains? s (first l)) (f (rest l) s)
           :else (cons (first l) 
                       (f (rest l) (set (cons (first l) s)))))))


#(vec (java.util.LinkedHashSet. %))


(partial reduce #(if (some #{%2} %1) %1 (conj %1 %2)) [])


#(nth
    (reduce (fn [[a b] i] [(if (b i) a (conj a i)) (conj b i)]) [[] #{}] %) 0)


reduce #(if (not (contains? (set %1) %2)) (conj %1 %2) %1) []


reduce #({%2 %} ((set %) %2) (conj % %2)) []


reduce (fn [R x] (if (some (partial = x) R) R (conj R x))) []


(fn distinct--group [coll]
  (->> coll                 ; [:a :b :c :b]
       (map-indexed vector) ; ([0 :a] [1 :b] [2 :c] [3 :b])
       (group-by second)    ; {:a [[0 :a]], :b [[1 :b] [3 :b]], :c [[2 :c]]}
       (map (juxt first (comp ffirst second))) ; ([:b 1] [:a 0] [:c 2])
       (sort-by second)     ; ([:a 0] [:b 1] [:c 2])
       (map first)))        ; (:a :b :c)


(fn [coll] (second (reduce (fn [[s l] v] [(conj s v) (if (contains? s v) 
                                                       l 
                                                       (conj l v))]) 
                           [#{} []] 
                           coll)))


#((reduce (fn [[a s] x] (if (s x) [a s] [(conj a x) (conj s x)])) [[], #{}] %) 0)


(fn newdistinct [x]
  (let [filteredconj (fn [coll elem]
                       (if (some #{elem} coll)
                         coll
                         (conj coll elem)))]
    (reduce filteredconj [] x)))


(fn [l]
(reduce (fn [a x] (if-not (some #(= x %) a) (conj a x) a)) [] l)
)


reduce (fn [coll e] (if (some #(= e %) coll) coll (conj coll e))) []


(fn [c] (reduce #(if (seq (filter (fn [a] (= a %2)) %)) % (conj % %2)) [] c))


(fn [coll]
  (loop [result []
         seen   #{}
         remain   coll]
    (if (empty? remain)
      result
      (let [val (first remain)
            rest (rest remain)]
        (if (contains? seen val)
          (recur result seen rest)
          (recur (conj result val)
                 (conj seen val)
                 rest))))))


(fn fdi [xs]
  (reduce
   (fn [memo x]
     (if (some #(= x %) memo)
       memo
       (conj memo x)))
   []
   xs))


(fn [s] (remove nil? (map #(if (%2 %1) nil %1) s (reductions conj #{} s))))


#(loop [x #{}, s %, res []] (if (empty? s) res (let [[c & r] s] (if (x c) (recur x r res) (recur (conj x c) r (conj res c))))))


(fn dist [invals]
  (loop [vals invals res [] acc #{}]
    (if (seq vals)
      (let [nextval (first vals)]
        (if (acc nextval)
          (recur (rest vals) res acc)
          (recur (rest vals) (into res [nextval]) (into acc [nextval]))))
      res)))


(fn [x]
           (loop [src x dst [] seen #{}]
             (if-let [head (first src)]
               (if (seen head)
                 (recur (rest src) dst seen)
                 (recur (rest src) (conj dst head) (conj seen head)))
               dst)))


(fn [coll]
  (loop [s #{}, c coll, res []]
    (cond (empty? c) res
          (contains? s (first c)) (recur s (rest c) res)
          :else (recur (conj s (first c)) (rest c) (conj res (first c))))))


#((reduce
  (fn [[set ans] x]
    [(conj set x)
     (if (contains? set x)
        ans
        (conj ans x))])
  [#{} []] %) 1)


(fn outer [xs]
  ((fn inner [done left]
    (if (empty? left)
        done
        (let [n (first left)]
          (if (some #{n} done)
              (inner done (rest left))
              (inner (concat done [n]) (rest left))))))
  () xs))


#((fn z [[a & b] S]
         (if a
           (if (S a)
               (z b S)
               (cons a (z b (conj S a)))))) 
  % #{})


(fn [x] (reduce #(if (some #{%2} %1) %1 (conj %1 %2)) [] x))


(fn sieve [lst]
  (if-not (empty? lst)
    (cons (first lst)
          (lazy-seq (sieve (filter #(not= (first lst) %) (rest lst))))
          ))
  )


(fn [xs] (reduce #(if (some #{%2} %1) %1 (conj %1 %2)) [] xs))


(fn cust-distinct [coll]
  (reduce
    (fn [m n]
      (if (some #{n} m)
        m
        (conj m n)))
    []
    coll))


(fn [s] (reduce #(if (some #{%2} %) % (conj % %2)) [] s))


(partial reduce 
  #(if (some (partial = %2) %) % (conj % %2)) 
  [])


(fn [coll]
  (loop [x coll r []]
    (cond
     (empty? x) r
     (some #(= (first x) %) r) (recur (rest x) r)
     :else (recur (rest x) (conj r (first x))))))


(fn f [i [h & t]] (if (nil? h) i (f `[~@i ~h] (remove #{h} t)))) []


(fn [xs]
  (reduce
    (fn [coll now]
      (if
        (some #{now} coll)
        coll
        (conj coll now)))
      [] xs))





;(fn dedupe [s]
;  (loop [in s
;         out []
;         seen #{}]
;    (if-let [head (first in)]
;      (if (seen head)
;        (recur (rest in) out seen)
;        (recur (rest in) (conj out head) (conj seen head)))
;      out)))


(partial reduce
           (fn [res item]
             (if (some #{item} res)
               res
               (conj res item)))
           [])


#(reduce (fn [s x]
                 (if (some (set s) [x])
                   s (conj s x)))
               [] %)


(fn __ [s]
  (if (empty? s) (empty s)
    (let [x (first s)]
      (concat [x] (__ (filter #(not= x %) (rest s)))))))


reduce (fn [x y] 
         (if (some #(= y %) x)
           x
           (conj x y))) []


reduce (fn [coll x] (if (some #(= % x) coll) coll (conj coll x))) []


;(fn [s]
;  (loop [l s, acc []]
;    (if-let [h (first l)]
;      (recur (remove #(= h %) l) (conj acc h))
;      acc)))
(fn [s] (reduce #(if (some #{%2} %) % (conj % %2)) [] s))


(fn [xs] (second (reduce (fn [[se li] n] [(conj se n) (if (contains? se n) li (conj li n))]) [#{} []] xs)))


#(loop [r [] rm %]
   (if (empty? rm) (reverse r)
     (recur (cons (first rm) r) (remove #{(first rm)} rm))))


(fn x-dis [coll]
  (letfn [(f [ret c]
             (if (empty? c)
               ret
               (let [elt (first c)]
                 (if (= -1 (.indexOf ret elt))
                   (f (conj ret elt) (rest c))
                   (f ret (rest c))))))]
         (f [] coll)))





(fn [c]
  (loop [a []
         e c]
    (cond
      (empty? e) a
      (empty? (filter #(= % (first e)) a)) (recur (conj a (first e)) (rest e))
      (not (empty? (filter #(= % (first e)) a))) (recur a (rest e)))))