;; 78 trampoline [m]

(= (letfn [(triple [x] #(sub-two (* 3 x)))
          (sub-two [x] #(stop?(- x 2)))
          (stop? [x] (if (> x 50) x #(triple x)))]
    (__ triple 2))
  82)
(= (letfn [(my-even? [x] (if (zero? x) true #(my-odd? (dec x))))
          (my-odd? [x] (if (zero? x) false #(my-even? (dec x))))]
    (map (partial __ my-even?) (range 6)))
  [true false true false true false])

(fn [f & args] (loop [f (apply f args)] (if (fn? f) (recur (f)) f)))

#(->> (%1 %2)
      (iterate (fn [f] (f)))
      (drop-while fn?)
      (first))

(fn tr
  [f & args]
  (let [x (apply f args)]
    (if (fn? x)
      (recur x ())
      x)))

(fn [f & args]
  (let [result (apply f args)]
    (if (fn? result)
      (recur result ())
      result)))

(fn [& as]
  (let [r (apply (first as) (rest as))]
    (if (fn? r) (recur [r]) r)))
aceeca1's solution:
1
#((fn [x] (if-not (fn? x) x (recur (x)))) (%1 %2))
adereth's solution:
1
2
3
(fn [f x]
  (loop [x (f x)]
    (if (fn? x) (recur (x)) x)))
aferrandi's solution:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn trampX [f & n]
    (let [res (apply f n)]
        (if (not (fn? res))
            res
            ((fn trampRec [f]
    (let [res (f)]
        (if (not (fn? res))
            res
            (trampRec res)
        )
    )
) res)
        )
    )
)
aguirre's solution:
1
2
3
4
(fn tramp [x & args]
  (loop [y (apply x args)]
    (if (fn? y) (recur (y))
      y)))
alanforr's solution:
1
2
3
4
5
6
7
8
9
(letfn [(funky [g]
           (let [ret (g)]
             (if (fn? ret)
               (recur ret)
               ret)))]
  (fn
    ([f] (funky f))
    ([f & args]
       (funky #(apply f args)))))
allenl's solution:
1
2
3
(fn my-tramp [f & args]
  (let [res (apply f args)]
    (if (fn? res) (recur res nil) res)))
andthorn's solution:
1
2
3
4
5
(fn me [f & p]
  (loop [r (apply f p)]
    (if (fn? r)
      (recur (r))
      r)))
anjensan's solution:
1
(fn t [f & a] (let [r (apply f a)] (if (fn? r) (t r) r)))
astangl's solution:
1
2
3
4
5
6
7
(fn
  [f & args]
  (let [ret1 (apply f args)]
    (loop [ret ret1]
      (if (fn? ret)
          (recur (ret))
          ret))))
austintaylor's solution:
1
2
3
4
5
(fn [f & args]
  (loop [f (apply f args)]
    (if (fn? f)
      (recur (f))
      f)))
awebb's solution:
1
2
3
(fn [f & args] 
  (loop [x (apply f args)]
    (if (fn? x) (recur (x)) x) ))
bendykst's solution:
1
(fn [f & args] (loop [fctn (apply f args)] (if (fn? fctn) (recur (fctn)) fctn)))
benhammond's solution:
1
2
3
(fn [f & args]
  (loop [f1 (apply f args)]
    (if (fn? f1) (recur (f1)) f1)))
benizi's solution:
1
2
3
4
5
(fn [f & args]
  (loop [v (apply f args)]
    (if (fn? v)
      (recur (v))
      v)))
bobuhiro11's solution:
1
2
3
4
5
(fn mytrampoline [f & args]
  (let [result (apply f args)]
    (if (fn? result)
      (mytrampoline result)
      result)))
burner's solution:
1
2
3
4
5
(fn tramp [f & args]
        (loop [f (apply f args)]
          (if (fn? f)
            (recur (f))
            f)))
caterpillar's solution:
1
2
3
4
5
(fn [ f & args]
  (let [r (apply f args)]
   (if (ifn? r)
     (recur r ())
     r)))
cc787's solution:
1
2
3
4
5
(fn [f v]
  (loop [result (f v)]
  (if-not (fn? result)
    result
    (recur (result)))))
chunchangshao's solution:
1
#(loop [x (% %2)] (if (fn? x) (recur (x)) x))
ctzsm's solution:
1
2
3
4
(fn tra ([f]
  (let [ret (f)]
    (if (fn? ret) (recur ret) ret)))
    ([f & args] (tra #(apply f args))))
dan7es's solution:
1
2
3
4
5
(fn tramp [f & args]
  (->> (apply f args)
       (iterate #(%))
       (drop-while ifn?)
       first))
daniels's solution:
1
2
3
(fn [x & y] 
  ((fn t [a] 
     (if (ifn? a) (t (a)) a)) (apply x y)))
daowen's solution:
1
2
#(loop [res (apply % %&)]
   (if (fn? res) (recur (res)) res))
del680202's solution:
1
2
3
4
5
6
7
(fn [f & args]
    (loop [r (apply f args)]
      (if (not (fn? r)) r
        (recur (r))
      )
    )
)
deping's solution:
1
2
3
4
(fn ! [x & xs] 
  (if (ifn? x) 
    (! (apply x xs))
    x))
devm33's solution:
1
2
3
(fn __
  ([f] (let [r (f)] (if (fn? r) (__ r) r)))
  ([f & args] (__ #(apply f args))))
dwelte's solution:
1
(fn tramp [f & args] (if (fn? f) (tramp (apply f args)) f))
dzholev's solution:
1
#((fn [f] (if (fn? f) (recur (f)) f)) (%1 %2))
echevarria's solution:
1
2
3
4
5
(fn my-trampoline [f & xs]
    (let [ r (apply f xs) ]
        (if (not (fn? r))
            r
            (recur r ()))))
ericw's solution:
1
2
3
(fn my-trampoline                                                                                                                                       
    ([x] (if (fn? x) (my-trampoline (x)) x))                                                                                    
    ([x & args] (my-trampoline (apply x args))))
featalion's solution:
1
2
3
4
5
(fn [f & args]
  (loop [res (apply f args)]
    (if (fn? res)
      (recur (res))
      res)))
finsternis's solution:
1
2
3
(fn [f & args]
  (loop [v (apply f args)]
    (if (ifn? v) (recur (v)) v)))
flububb's solution:
1
2
3
(fn tramp
  ([f] (if (fn? f) (recur (f)) f))
  ([f & args] (tramp (apply f args))))
garyxia's solution:
1
2
3
4
5
6
(fn
  [f & args]
  (loop [res (apply f args)]
    (if (fn? res)
      (recur (res))
      res)))
geekerzp's solution:
1
2
3
4
5
6
7
8
(fn my-trampoline
    ([f]
     (let [ret (f)]
       (if (fn? ret)
         (recur ret)
         ret)))
    ([f & args]
     (my-trampoline #(apply f args))))
glchapman's solution:
1
2
3
4
5
6
7
8
9
(letfn [
  (mytrampoline
    ([f]
        (if (fn? f) (recur (f)) f))
    ([f & args]
        (mytrampoline (apply f args)))
  )]
 mytrampoline
)
goaranger's solution:
1
2
3
4
5
(fn mytrampoline [f & args]
  (let [retval (if args (apply f args) (f))]
    (if (fn? retval)
      (mytrampoline (apply f args))
      retval)))
gpittarelli's solution:
1
2
3
4
5
(fn tramp [f & args]
  (loop [res (apply f args)]
    (if (fn? res)
      (recur (res))
      res)))
happycrisis's solution:
1
2
3
4
(fn [f n] (->> (f n) 
               (iterate #(if (fn? %) (%) %))
               (drop-while fn?)
               first))
hisba's solution:
1
2
3
(fn mtramp 
  ([f & args] (let [r (apply f args)] (if (fn? r) (mtramp r) r)))
  ([f] (let [r (f)] (if (fn? r) (mtramp r) r))))
icamts's solution:
1
2
3
4
5
6
7
8
(fn tramp
  ([f]
     (let [ret (f)]
       (if (fn? ret)
         (recur ret)
         ret)))
  ([f & args]
     (tramp #(apply f args))))
immo's solution:
1
Scored 42, before 4clojure started saving solutions.
jarlax's solution:
1
2
3
4
(fn tramp [f & args]
  (let [rec (apply f args)]
    (loop [f rec]
      (if (fn? f) (recur (f)) f))))
jedo's solution:
1
2
3
4
5
6
7
8
9
(fn tramp [f & args]
  (let [f (apply f args)]
        (loop [f f]
            (if (fn? f) (recur (f))
                f
            )
        )
    )
)
jeff_terrell's solution:
1
2
3
4
5
(fn [f & args]
  (loop [a (apply f args)]
    (if (fn? a)
      (recur (a))
      a)))
johncowie's solution:
1
2
3
4
5
(fn [f & args]
  (loop [nf (apply f args)]
    (if (fn? nf)
      (recur (nf))
      nf)))
jomicoll's solution:
1
2
3
4
5
(fn [f & args]
  (loop [x (apply f args)]
    (if-not (fn? x) 
      x
      (recur (x)))))
jorendorff's solution:
1
#(if (ifn? %) (recur (apply % %&) ()) %)
jslavin's solution:
1
2
3
4
5
6
7
8
9
10
11
12
(fn mytramp
  ([f] 
   (let [retf (f)]
     (if (fn? retf)
     (recur retf)
     retf
     ))
    )
  ([f & args]
   (mytramp #(apply f args))
    )
  )
kohyama's solution:
1
2
3
(fn [f & args]
  (loop [g (apply f args)]
    (if (fn? g) (recur (g)) g)))
kopychenko's solution:
1
2
3
4
5
6
7
8
(fn reimplement-trampoline [f & args]
  (letfn [(tr [f] 
            (loop [f f]
               (if (fn? f)
                 (recur (f))
                 f)))]
 
    (tr #(apply f args))))
blucas's solution:
1
2
3
4
5
6
7
8
(fn prob78 
  [f & args]
  (if (empty? args)
    (let [ret (f)]
      (if (fn? ret)
        (prob78 ret)
        ret))
    (prob78 #(apply f args))))
brendan's solution:
1
2
3
#(loop [g (apply % %&)]
    (if (fn? g) (recur (g))
      g))
kuze's solution:
1
2
3
4
5
6
(fn myTrampoline
  [fun & params]
  (loop [newFun (apply fun params)]
    (if (not (fn? newFun))
      newFun
      (recur (newFun)))))
lackita's solution:
1
2
3
(fn trmpln [f & args]
  (let [r (apply f args)]
    (if (fn? r) (trmpln r) r)))
lambda4fun's solution:
1
(fn t [f & args] (let [r (apply f args)] (if (fn? r) (t r) r)))
lasthemy's solution:
1
2
3
4
5
6
7
8
(fn [f & args]
  (loop [f (apply f args)]
    (if (fn? f)
      (recur (f))
      f
      )
    )
  )
lbarrett's solution:
1
2
3
4
5
(fn [f & args]
  (loop [f (apply f args)]
    (if (fn? f)
      (recur (f))
      f)))
leetwinski's solution:
1
2
3
4
5
(fn [f & args]
  (loop [r (apply f args)]
    (if (fn? r)
      (recur (r))
      r)))
littlejp2046's solution:
1
2
3
4
5
(fn t [f & l]
  (let [r (apply f l)]
    (if (fn? r)
      (t r)
      r)))
malvert's solution:
1
(comp #(if (fn? %) (recur (%)) %) #(apply %1 %&))
matiasl's solution:
1
2
3
4
(fn [f & args] 
  (if (fn? f) 
    (recur (apply f args) nil)
    f))
maximental's solution:
1
#(loop [f (% %2)] (if (fn? f) (recur (f)) f))
mbakhterev's solution:
1
#(loop [g (apply % %&)] (if (fn? g) (recur (g)) g))
meerwolf's solution:
1
2
3
4
5
6
(fn bounce
  [f & args] {:pre [(fn? f)]}
  (loop [x (apply f args)]
    (if (fn? x)
      (recur (x))
      x)))
mfikes's solution:
1
(fn [f & args] ((fn [x] (if (fn? x) (recur (x)) x)) (apply f args)))
minitrue's solution:
1
2
3
(fn [f & args]
  (loop [ret (apply f args)]
    (if (fn? ret) (recur (ret)) ret)))
mkahn's solution:
1
2
3
4
(fn newtrampoline [f & x]
        (if (not (fn? (apply f x)))
          (apply f x)
          (newtrampoline (apply f x))))
mobiusloop's solution:
1
(fn t [f & a] (first (drop-while fn? (iterate #(if (fn? %1) (%1) %1) (apply f a)))))
mononite's solution:
1
2
3
4
5
(fn [f & args]
  (loop [r (apply f args)]
    (if (fn? r)
      (recur (r))
      r)))
mouse's solution:
1
(fn t [f & a] (let [r (apply f a)] (if (fn? r) (t r) r)))
mwaldowski's solution:
1
2
3
4
5
(fn [f & args]
  (loop [f (apply f args)]
    (if (fn? f)
      (recur (f))
      f)))
nagi's solution:
1
2
3
4
5
(fn tramp [f & args]
  (let [result (apply f args)]
    (if (fn? result)
      (tramp result)
      result)))
nikelandjelo's solution:
1
2
(fn [f & args]                                                                                                                      
           (first (drop-while fn? (iterate (fn [f] (f)) (apply f args)))))
noiseehc's solution:
1
(fn [f & args] (loop [res (apply f args)] (if (fn? res) (recur (res)) res)))
norman's solution:
1
2
3
4
5
(fn bounce [f & args]
  (loop [result (apply f args)]
    (if (fn? result)
      (recur (result))
      result)))
nothsaevets's solution:
1
2
3
4
5
(fn [f & args]
           (loop [f (apply f args)]
             (if (fn? f)
               (recur (f))
               f)))
owk4057's solution:
1
2
3
(fn myf2 [f & args]
  (loop [f (apply f args)]
    (if (fn? f) (recur (f)) f)))
ownwaterloo's solution:
1
2
3
(fn [f & xs]
  (loop [y (apply f xs)]
    (if (fn? y) (recur (y)) y)))
ozan's solution:
1
2
3
4
5
6
7
8
(fn tramp
  ([f]
   (let [ret (f)]
     (if (fn? ret)
       (recur ret)
       ret)))
  ([f & args]
   (tramp #(apply f args))))
pukeface's solution:
1
2
3
(fn [f & args]
    (#(if (fn? %) (recur (%)) %)
      (apply f args)))
quant1's solution:
1
(fn [f & x] (loop [r (apply f x)] (if (fn? r) (recur (r)) r)))
rodmax's solution:
1
2
3
4
5
6
(fn [ f & args ]
     (if 
         (ifn? f)
       (recur (apply f args) ())
       f
       ))
sbondaryev's solution:
1
2
3
4
#(loop [res (apply % %&)]
   (if (fn? res)
     (recur (res))
     res))
shiro's solution:
1
2
3
4
5
6
(fn cust-tramp [f & args]
  (let [result (apply f args)]
    (loop [f result]
      (if (fn? f)
        (recur (f))
        f))))
sheldon's solution:
1
(fn t [f & a] (if (fn? f) (t (apply f a)) f))
silverio's solution:
1
2
#(loop [x (apply % %&)]
   (if (fn? x) (recur (x)) x))
skyrem's solution:
1
2
3
4
5
6
7
(fn mytramp
  ([f] 
   (if
     (fn? (f)) (mytramp (f))
     (f)))
  ([f & args]
   (mytramp #(apply f args))))
soul_awaker's solution:
1
2
3
4
(fn g
      ([f] (if (fn? f) (recur (f)) f)) 
      ([f & s]
        (g #(apply f s))))
staafl2's solution:
1
2
3
4
5
6
7
8
(fn [f & args]
  (first
    (drop-while
      fn?
      (reductions
        (fn [a _] (a))
        (apply f args)
        (range)))))
syeerzy's solution:
1
2
3
(fn [f a]
  (loop [r (f a)]
    (if (fn? r) (recur (r)) r)))
tclamb's solution:
1
2
3
4
5
6
7
(fn trampoline'
  ([f & args]
      (trampoline'
       (apply f args)))
  ([f] (if (fn? f)
         (recur (f))
         f)))
thegeez's solution:
1
2
3
4
(fn t [f & args]
    (if (fn? f)
      (t (apply f args))
      f))
zzamboni's solution:
1
2
3
4
5
(fn my-trampoline [f & args]
  (loop [ret (apply f args)]
    (if (fn? ret)
      (recur (ret))
      ret)))
zoltanjarai's solution:
1
2
3
4
(fn __ [f & args]
  (let [x (apply f args)]
    (if (fn? x) (__ x)
      x)))
zipzop's solution:
1
2
3
4
5
(fn t [f & args]
  (let [g (apply f args)]
    (if (fn? g)
      (t g)
       g)))
yusubori's solution:
1
2
3
4
5
(fn [f & xs]
  (loop [r (apply f xs)]
    (if (fn? r)
      (recur (r))
      r)))
ydash's solution:
1
2
3
4
#(loop [x (% %2)]
   (if (fn? x)
     (recur (x))
     x))
vpeurala's solution:
1
(fn my-trampoline [f & xs] (if (fn? (apply f xs)) (my-trampoline (apply f xs)) (apply f xs)))
v_bogdanov's solution:
1
2
3
4
5
6
7
8
(fn tramp
  ([f]
     (let [ret (f)]
       (if (fn? ret)
         (recur ret)
         ret)))
  ([f & args]
     (tramp #(apply f args))))
unionx's solution:
1
2
3
4
5
(fn tramp [f & args]
  (let [ret (apply f args)]
    (if (fn? ret)
      (tramp ret)
      ret)))
trxeste's solution:
1
(fn [f & args] (loop [f (apply f args)] (if (fn? f) (recur (f)) f)))
transfinite's solution:
1
2
3
4
5
(fn t [f & args]
  (cond
   args (t (apply f args))
   (fn? f) (t (f))
   :else f))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)