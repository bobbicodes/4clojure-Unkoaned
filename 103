;; 103 k-combinations [m]

Takes seq of n elements, returns all possible sets
consisting of k distinct elements taken from S.
The number of k-combinations for a seq is equal to
the binomial coefficient.

(defn k-comb [k S]
(if (zero? k)
    #{#{}}
    (set (mapcat (fn [e]
    (map (fn [t] (conj t e))
      (k-comb (dec k) (disj S e)))) S))))
#'user/k-comb
user> (k-comb 1 #{4 5 6})
#{#{6} #{5} #{4}}
user> (k-comb 10 #{4 5 6})
#{}
user> (k-comb 2 #{0 1 2})
#{#{0 1} #{1 2} #{0 2}}
user> (k-comb 3 #{0 1 2 3 4})
#{#{0 4 3} #{0 1 4} #{4 3 2} #{0 1 2} #{0 1 3} #{1 3 2} #{0 3 2} #{1 4 3} #{1 4 2} #{0 4 2}}
user> (k-comb 4 #{[1 2 3] :a "abc" "efg"})
#{#{"efg" "abc" [1 2 3] :a}}
user> (k-comb 2 #{[1 2 3] :a "abc" "efg"})
#{#{[1 2 3] :a} #{"efg" :a} #{"abc" :a} #{"abc" [1 2 3]} #{"efg" "abc"} #{"efg" [1 2 3]}}

(fn combinations [k s]
  (cond (zero? k) #{#{}}
    (empty? s) #{}
    :else (set (clojure.set/union
      (map #(conj % (first s))
            (combinations (dec k) (rest s)))
      (combinations k (rest s))))))

(defn k-comb [k S]
(if (zero? k)
    #{#{}}
    (set (mapcat (fn [e]
    (map (fn [t] (conj t e))
      (k-comb (dec k) (disj S e)))) S))))

hypirion's solution ;; Ingenious!
In the i. loop takes out all the
possible elements of the original set
(elt init in the for loop) produced from 
all the possible sets of i+1 n-1 elements

(def k-comb
  (fn ([n init]
    (let [i (- (count init) n)]
      (if (neg? i)
        #{}
        (loop [sets [init], i i]
          (println (str "i: " i))
          (if (pos? i)
            (recur (for [elt init, set sets
                        :when (contains? set elt)]
                     (do (println set elt)
                         (disj set elt)))
              (dec i)) (into #{} sets))))))))

(fn [n s]
  (let [all (fn c1 [n s]
              (cond
                (zero? n) #{}
                (= 1 n) (reduce #(conj %1 #{%2}) #{} s)
                :else (reduce
                        (fn [acc x]
                          (into acc
                            (map #(into x %) (c1 1 s))))
                        #{}
                        (c1 (dec n) s))))]
    (set (filter #(= n (count %)) (all n s)))))

(fn ff [n xs]  
  (if (zero? n)
    #{#{}}
    (set (for [x xs
               y (ff (dec n) (disj xs x))]
           (conj y x)))))

(fn [c s]
  (if (< (count s) c)
    #{}
    (if (= (count s) c)
      (conj #{} s)
      (loop [s s result (set (map (comp set vector) s))]
        (if (empty? s)
          (set (filter #(= (count %) c) result))
          (recur (rest s) (into result (map #(into % (vector (first s))) result))))))))

#(cond
  (> %1 (count %2)) #{} ;one short cut
  (= %1 (count %2)) #{%2} ;another short cut
  :else (loop [result #{#{}} round 0] ;an iterative solution
          (if (= round %1) result
            (recur (apply conj #{}
                          (for [x result y %2 :when (not (contains? x y))]
                            (conj x y)))
                   (inc round)))))
 
;a recursive solution
;(fn kCombination[k S]
;  (cond
;   (= k 0) #{}
;   (= k 1) (apply conj #{}
;                   (for [item S]
;                     #{item}))
;   (= k (count S)) #{S}
;   (> k (count S)) #{}
;   :else (apply conj #{}
;                (for [x (kCombination (dec k) S) y S :when (not (contains? x y))]
;                  (conj x y)))))

(letfn [(pset [s]
  (set
    (if (>= 1 (count s)) [(set s) #{}]
      (concat
        [s]
        [(set [(first s)])]
        (pset (set (rest s)))
        (map #(set (cons (first s) %)) (pset (set (rest s))))
      ))))]
  (fn [n s] (set (filter #(= n (count %)) (pset s)))))
aceeca1's solution:

1
2
3
4
5
6
7
8
9
10
11
(letfn [
    (comb [n s] (cond 
        (zero? n) [#{}]
        (> n (count s)) []
        true (let [
            s1 (first s)
            sn (disj s s1)
            comb1 (comb n sn)
            comb2 (for [i (comb (dec n) sn)] (conj i s1))]
            (concat comb1 comb2))))]
    (comp set comb))
adereth's solution:

1
2
3
4
5
6
7
8
9
10
(fn [n s]
  (let [subsets (fn [s]
            (loop [result []
               remaining s]
              (if (seq remaining)
             (recur (concat [[(first remaining)]] result (map #(conj % (first remaining)) result)) (rest remaining))
                     result)))]
    (apply hash-set (map #(apply hash-set %) (filter #(= n (count %)) (subsets s))))
    )
  )
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn kCombinationK [k s]
    (letfn [
        (removeI [v n]
            (vec (concat (subvec v 0 n) (subvec v (inc n))))
            )
        (kCombinationRec [k v]
            (if (or (empty? v) (zero? k))
                [#{}]
                (let [
                    indexes (range 0 (count v))
                    newK (dec k)
                    ]
                    (mapcat (fn[i] (map #(conj % (get v i)) (kCombinationRec newK (removeI v i)) )) indexes)
                )
            )
        )
        ]
        (if (> k (count s)) 
            #{}
            (set (kCombinationRec k (vec s)))
        )
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
(fn [n xs]
     (->> 
       (map #(set [%]) xs)
       (iterate (fn [prevs] 
                  (into #{} (for [prev prevs
                                 x xs] (conj prev x)))))
       (#(nth % n))
       (filter #(= n (count %)))
       (into #{})))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [n s]
  (letfn [(thingaddf [ps leftover] (map #(conj % (first leftover)) ps))
          (thingadder [[ps leftover]] 
                      [(set (conj (concat ps (thingaddf ps leftover)) #{(first leftover)}))
                       (rest leftover)])
          (powerset [ss]
                    (-> (drop-while #(not-empty (second %)) 
                                    (iterate thingadder [#{#{}} ss]))
                        first first))
          (k-combinations [k ss] (set (filter #(= k (count %)) (powerset ss))))]
    (k-combinations n s)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn f [n col]
  (->>
   ((fn f' [acc n col]
      (let [i (first col), r (rest col)]
        (if (or (nil? i) (zero? n)) ; n==0
          acc                                                          
          (clojure.set/union (f' (map #(conj (set %) i) acc) (dec n) r)
                             (f' acc n r)))))
    #{#{}} n col)
   (filter #(= n (count %)))
   (set)))
andthorn's solution:

1
2
3
4
5
6
7
8
(fn [n s]
  (let [f (fn f [s]
            (if (empty? s)
              #{#{}}
              (set (concat (map #(conj % (first s)) (f (next s))) (f (next s))))))
        ]
    (set (filter #(= n (count %)) (f s)))
    ))
anjensan's solution:

1
2
3
4
5
6
7
(fn f [n s]
  (set
    (if (== 1 n)
      (map hash-set s)
      (let [z (f (dec n) s)]
        (for [x s, t z :when (not (t x))]
          (conj t x))))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn
  [n s]
  (if (or (> n (count s))
          (< n 1))
    #{}
    (letfn [(next-set-n-elements
              [x]
              (let [smallest (bit-and x (- x))
                    ripple (+ x smallest)
                    smallest' (bit-and ripple (- ripple))
                    ones (dec (bit-shift-right (quot smallest' smallest) 1))]
                (bit-or ripple ones)))
            (select-via-bits
              [x]
              (set (second (reduce (fn [[bs s] e]
                                    (let [bs' (bit-shift-right bs 1)]
                                      (if (odd? bs)
                                        [bs' (conj s e)]
                                        [bs' s]))) [x []] s))))]
      (let [x (dec (bit-shift-left 1 n))
            ns (take-while #(and (> % 0)
                                 (< % (bit-shift-left 1 (count s))))
                           (iterate next-set-n-elements x))]
        (set (map select-via-bits ns))))))
austintaylor's solution:

1
2
3
4
5
6
(fn [x s]
  (letfn [(powerset [s]
    (reduce (fn [ps x]
      (reduce (fn [ps s]
        (conj ps (conj s x))) ps ps)) #{#{}} s))]
    (set (filter #(= x (count %)) (powerset s)))))
awebb's solution:

1
2
3
4
5
6
(fn [k s]
  (let [ps    
          (loop [a #{ #{} } [h & t] (seq s)]
            (if (nil? h) a 
              (recur (into a (for [x a] (conj x h)))  t)  ))]
    (set (filter #(= k (count %)) ps))))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
(fn kcom [n s]
  (letfn 
    [(ksets [n root [head & tail]]
      (cond
        (zero? n) [root]
        (nil? head) nil
        :else (concat
                (ksets (dec n) (conj root head) tail)
                (ksets n root tail))))]
    (set (map set (map (partial remove nil?) (ksets n [] (apply list s)))))))
benhammond's solution:

1
2
3
4
(fn [n si]
  (set (reduce (fn [acc n] (filter #(= n (count %)) (mapcat (fn [v] (set (map (fn [s] (conj s v)) acc))) si)))
                    (repeat (count si) #{})
                    (range 1 (inc n)))))
benizi's solution:

1
2
3
4
5
6
(fn [n items]
  (let [powerset (reduce (fn [sets el]
                           (into sets (map #(conj % el) sets)))
                         #{#{}}
                         items)]
    (into #{} (filter #(= n (count %)) powerset))))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn p [k s]
  (apply hash-set (cond
    (= k (count s))
    #{(apply hash-set s)}
    (= k 0)
    #{}
    (> k (count s))
    #{}
    (= k 1)
    (apply hash-set (map (fn [x] #{x}) s))
    :else
    (let [f (first s)
          l (rest s)]
      (clojure.set/union
       (map (fn [sett] (conj sett f)) (p (dec k) l))
       (apply hash-set (p k l)))))))
burner's solution:

1
2
3
4
5
6
7
8
(letfn [(subseqs [s]
                (if (empty? s)
                  [#{}]
                  (let [rseqs (subseqs (rest s))]
                    (concat [#{(first s)}] (map #(cons (first s) %) rseqs)
                            rseqs))))]
        (fn [n s]
          (set (map set (filter #(= (count %) n) (subseqs s))))))
caterpillar's solution:

1
2
3
4
5
6
7
#(let[elements (vec %2)
      numOfElements (count elements)]
   (loop[c 0 n (dec %1) r (into #{} (map (fn[x] (into #{} (list x))) %2))]
     (cond
       (>= n numOfElements) #{}
       (= c n) r
       :else (recur (inc c) n (into #{} (for [com r e elements :when (not (contains? com e))] (conj com e)))))))
cc787's solution:

1
(fn [x y] (set (filter #(= (count %) x) (reduce (fn [acc e] (into acc (map #(conj % e) acc))) #{#{}} y))))
chunchangshao's solution:

1
2
3
4
5
6
7
8
#(case %
   1 #{#{4} #{5} #{6}}
   10 #{}
   3 #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4} #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}}
   4 #{#{[1 2 3] :a "abc" "efg"}}
   2 (if (= 3 (count %2)) 
       #{#{0 1} #{0 2} #{1 2}}
       #{#{[1 2 3] :a} #{[1 2 3] "abc"} #{[1 2 3] "efg"} #{:a "abc"} #{:a "efg"} #{"abc" "efg"}}))
ctzsm's solution:

1
2
(fn[n s]
  (set (filter #(= n (count %)) (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn combinations [k sets]
  (cond
   (zero? k)
   #{#{}}
     
   (< (count sets) k)
   #{}
     
   :else
   (->> (combinations (dec k) sets)
        (mapcat #(map (partial conj %) sets))
        (filter (comp (partial = k) count))
        set)))
daniels's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [a b] 
  (let [superset (fn superset [x] 
                   (if (= 1 (count x))
                     #{ #{(first x)} #{}}
                     (apply merge 
                            (superset (rest x)) 
                            (map #(into #{} (conj % (first x))) (superset (rest x))) )))] 
    (into #{}
          (filter 
           #(= a (count %)) 
           (superset b)))))
daowen's solution:

1
2
3
4
5
(fn k-combos [n items]
  (if (zero? n) [#{}]
    ((comp set mapcat)
      #(for [i (k-combos (dec n) (disj items %))] (conj i %))
      items)))
del680202's solution:

1
2
3
4
5
6
7
8
9
(fn [n elems]
  (if (> n (count elems)) #{}
    (loop [r (for [e elems] #{e}) dn (dec n)]
      (if (zero? dn) (set (filter #(= n (count %)) r))
       (recur (for [e elems er r](conj er e)) (dec dn))
      )
    )
  )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn ! [n s] 
  (letfn [(tf [n p f] 
              (if (zero? n) #{p}
                (if (empty? f) #{}
                  (clojure.set/union 
                   (! n (rest f))
                   (map (partial cons (first f)) 
                        (tf (dec n) 
                            (conj (vec p) (first f)) 
                            (rest f)))
                   ))))]
    (set (map set (tf n [] (vec s))))))
devm33's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn __ [n s]
  (if (or (= n 0) (empty? s) (> n (count s)))
    #{}
    (if (= 1 n)
      (set (map hash-set s))
      (when-let [xs (seq s)]
        (set (mapcat
               (fn [i]
                 (let [ni (nth xs i)]
                   (let [sbs (__ (dec n) (drop (inc i) xs))]
                     (map (fn [nxs] (conj nxs ni)) sbs))))
               (range (- (count xs) (dec n)))))))))
dwelte's solution:

1
2
3
4
5
6
(fn f
  ([k src] (if (< (count src) k) #{} (f k src #{#{}})))
  ([k src acc]
    (if (= k 0)
      acc
      (recur (dec k) src (into #{} (for [a acc s src :when (not (contains? a s))] (conj a s)))))))
dzholev's solution:

1
2
3
4
5
(fn [n s]
  (set 
    (filter 
      #(= (count %) n)
      (reduce (fn [r e] (into r (map #(conj % e) r))) #{#{}} s))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn [k s]
    (let [n (count s)
          pow-2 (fn p2 [k] (if (= 0 k) 1 (* 2 (p2 (dec k)))))
          rec-int-to-set (fn ris [n c r] 
                            (if (= 0 n) 
                                r 
                                (ris 
                                    (bit-shift-right n 1) 
                                    (inc c) 
                                    (if (= 1 (bit-and 0x01 n)) (conj r c) r))))
          int-to-set #(rec-int-to-set %1 0 #{})
          brute-k-combinations (fn [n k]
            (cond 
                (> k n) #{}
                (= k 0) #{#{}}
                (= k n) (conj #{} (set (range n)))
                :else
                    (filter #(= k (count %1)) (map int-to-set (range (pow-2 n))))))
          get-fun (fn [s] (fn [is] (set (map #((vec s) %1) is))))
          xfer (get-fun s)
    ]
        (set (map xfer (brute-k-combinations n k)))))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(letfn [                                                                                                                                                
    (count-bits [n] (loop [c 0 v n] (if (zero? v) c (recur (inc c) (bit-and v (- v 1))))))                                      
    (which-bits [n]                                                                                                                                     
        (loop [n' n bits [] i 0]                                                                                                
            (if (zero? n')                                                                                                                              
                bits                                                                                                            
                (recur                                                                                                                                  
                    (bit-shift-right n' 1)                                                                                      
                    (if (= 1 (bit-and n' 1)) (conj bits i) bits)                                                                                        
                    (inc i)))))                                                                                                 
    (gen-k-combinations [k s]                                                                                                                           
        (if (> k (count s))                                                                                                     
            #{}                                                                                                                                         
            (let [s' (seq s)                                                                                                    
                combinations  (                                                                                                                         
                    ->> (range (bit-shift-left 1 (count s')))    ; get all numbers from 0 to 2^(count s)                        
                        (filter #(= k (count-bits %)))           ; filter in those numbers with k bits set                                              
                        (map which-bits)                         ; figure out which bits are high                               
                        (map (fn [comb] (map #(nth s' %) comb))) ; pick those combinations of elements out of s                                         
                        (map set))]                              ; turn them into sets                                          
                (set combinations))))]                                                                                                                  
        gen-k-combinations                                                                                                      
)
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
(letfn [(k-combinations
         [k s]
         (cond
          (= k 0) '(())
          (empty? s) '()
          :else (concat (map
                         #(cons (first s) %)
                         (k-combinations (dec k) (rest s)))
                        (k-combinations k (rest s)))))]
  (fn [k s]
    (set (map set (k-combinations k s)))))
finsternis's solution:

1
2
3
4
5
6
7
8
(fn kc [k s]
  (cond
   (zero? k) #{#{}}
   (empty? s) #{}
   :else (let [s1 (first s) rs (disj s s1)]
           (clojure.set/union
            (kc k rs)
            (set (map #(conj % s1) (kc (dec k) rs)))))))
flububb's solution:

1
2
3
4
5
6
7
8
9
(fn k-comb [n s]
  (loop [k n, r #{#{}}]
    (if (< k 1)
      r
      (recur 
        (dec k)
        (set (filter (comp not nil?)
            (for [x r y s]
              (if (contains? x y) nil (conj x y)))))))))
garyxia's solution:

1
2
(fn [k s]
  (set (filter #(= k (count %)) (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s))))
geekerzp's solution:

1
2
3
4
(fn [k s]
    (set (filter #(= k (count %))
                 (reduce #(concat %1 (map (fn [x] (set (conj x %2))) %1))
                         #{#{}} s))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn k-comb [k items]
    (let [items (vec items)
          num-items (count items)
          generate
            (fn generate [k fst res]
                (if (zero? k)
                    (list res)
                    (mapcat #(generate (dec k) (inc %) (conj res (items %))) (range fst num-items))
                ))
        ]
        (set (generate k 0 #{}))
    ))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn bleh [k S]
  (let [fola (fn fola [darray tarray acc]
               (let [farray (if (and (empty? acc) 
                                (> (count darray) (count tarray)))
                                        (flatten (cons (repeat (- (count darray) (count tarray)) "0") tarray)) 
                                tarray)]
                        (if (> (count darray) 0) 
                                (if (= (first farray) "1") 
                                        (fola (rest darray) (rest farray) (conj acc (first darray))) 
                                        (fola (rest darray) (rest farray) acc)) 
                        acc)))
        n (count S)]
        (set (map #(set %) (filter #(not (not %)) 
                (for [i (range 1 (inc (int (Math/pow 2 n))))]
                                (if (= k (count (filter #(= % "1") (clojure.string/split (Integer/toString i 2) #""))))
                                        (fola S (rest (clojure.string/split (Integer/toString i 2) #"")) []))))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [k els']
   (cond (= (count els') k)
         #{els'}
         (> k (count els'))
         #{}
         :else
         (apply (comp set list) ((fn f [x els]
                                   (println x els)
                                   (if (= (dec x) k)
                                     (map #(disj els %) els)
                                     (mapcat #(f (dec x) (disj els %))
                                             els))) (count els') els'))))
happycrisis's solution:

1
2
#(nth (iterate (fn [ss] (set (remove nil? (for [s ss x %2] (if (s x) nil (conj s x))))))
               [#{}]) %)
hisba's solution:

1
2
3
4
(fn gkc [n s]
  (if (> n (count s)) #{}
         (set (filter #(= n (count %))
                      (reduce (fn [k i] (into k (cons #{i} (map #(merge % i) k)))) #{#{}} s)))))
icamts's solution:

1
2
3
4
5
6
7
(fn [k s]
  (letfn [(step [s] (for [e s] (disj s e)))
          (comb-it [d ss]
                   (if (= 0 d) ss
                     (recur (dec d) (reduce into #{} (map step ss)))))]
    (let [n (count s)] 
      (if (or (< n k) (zero? k)) #{} (comb-it (- n k) (hash-set s))))))
immo's solution:

1
2
3
4
5
6
7
(fn [n s] 
  (letfn [(f [x] (set (map #(disj x %) x)))]
      (loop [t #{s} m (count s)]
          (cond
        (> n m) #{}
        (= n m) t
              1 (recur (apply clojure.set/union (map f t)) (dec m))))))
jarlax's solution:

1
2
3
4
5
6
7
8
9
(fn k-comb [n s]
  (cond
    (zero? n) #{#{}}
    (> n (count s)) #{}
    :else (let [x (first s)
                xs (-> s rest set)]
            (into
              (k-comb n xs)
              (map #(conj % x) (k-comb (dec n) xs))))))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn combinations [n coll]
  (let [apply-sets (fn [coll] (into #{} (map #(hash-set %) coll)))
          setcoll (apply-sets coll)
          merge-combinations (fn [original subs]
            (reduce #(clojure.set/union %1 %2) 
                (for [x subs]
                    (into #{} (for [y original] (conj x y)))
                )
            )
        )]
    (if (= n 1) setcoll
        (into #{} (filter #(= n (count %)) (loop [res setcoll iters 1]
            (if (= iters n) res
                (recur (merge-combinations coll res) (inc iters))
            )
        )))
    )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
(fn f [k s]
  (if (= k 1)
    (set (map #(set [%]) s))
    (set (mapcat (fn [item]
                   (let [subs (f (dec k) (disj s item))]
                     (set (map #(conj % item) subs))))
                 s))))
johncowie's solution:

1
2
3
4
5
6
7
(fn [n s]
  (letfn [(p [s]
             (if (empty? s)
               #{#{}}
               (set (flatten (for [i (p (rest s))]
                               [(set (cons (first s) i)) i])))))]
    (set (filter (fn [c] (= (count c) n)) (p s)))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn combinations
  [k coll]
  (letfn [(comb-aux
           [m start]
           (if (= 1 m)
             (for [x (range start (count coll))]
               (list x))
             (for [x (range start (count coll))
                   xs (comb-aux (dec m) (inc x))]
               (cons x xs))))]
    (let [indices (comb-aux k 0)
          coll (vec coll)]
      (into #{}
            (map (fn [idxs] (into #{} (map coll idxs))) indices)))))
jorendorff's solution:

1
2
3
4
5
(comp set (fn c [k s]
            (if (= k 0) #{#{}}
              (if-let [[e & f] (seq s)]
                (into (c k f) (for [u (c (dec k) f)] (conj u e)))
                #{}))))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn kcomb [c s]
  (letfn [(power [s] (set (loop [[f & r] (seq s) p '(#{})]
                            (if f (recur r (concat p (map #(conj % f) p)))
                                  p))))
          ]
    (let [power-sets (power s)
          filtered-sets (filter  #(= (count  %) c) power-sets)
          ]
      (into #{} filtered-sets)
      )
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
(fn [n s]
  (set
    (filter #(= n (count %))
      (reduce
        (fn [a x] (into a (map #(conj % x) a)))
        #{#{}}
        s))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn generating-k-combinations [l s]
  (letfn [(power-set [s]
            (letfn [(sp-set [s] (reduce 
                                 
                                 (fn [a x]
                                   (conj a (disj s x)))
 
                                 #{} s))]
 
              (conj (loop [a #{} s #{s}]
                      (let [[ar,rr] (reduce (fn [[a,ns] x]
                                              (let [r (sp-set x)]
                                                [(into a r), (into ns r)]))
 
                                            [a,#{}] s)]
                        (if (= rr #{})
                          ar
                          (recur ar rr)))) s)
              ))]
    (set (filter #(= (count %) l) (power-set s)))))
blucas's solution:

1
2
3
4
5
6
7
8
9
(fn prob103
  [num seq]
  (set (map set   
            (cond
              (= num 0) '(())
              (empty? seq) '()
              :else (concat 
                     (map (fn [it] (cons (first seq) it)) (prob103 (dec num) (rest seq)))
                     (prob103 num (rest seq)))))))
brendan's solution:

1
2
3
4
5
6
7
(fn [k s] 
  (set (filter #(= k (count %))
   (nth
     (iterate 
       #(into #{#{}} (for [x s y %] (into #{x} y)))
       (map hash-set s)) 
     k))))
kuze's solution:

1
2
3
4
5
6
(fn my-k-combinations
  [k s]
  (loop [result (map #(hash-set %) s) i 0]
    (if (or (= i k) (> i k))
      (set (filter #(= (count %) k) result))
      (recur (set (mapcat (fn [x] (map #(conj x %) s)) result)) (inc i)))))
lackita's solution:

1
2
3
4
(fn choose [k s]
  (cond (< (count s) k) #{}
        (= (count s) k) #{s}
        :else (set (apply concat (map #(choose k (disj s %)) s)))))
lambda4fun's solution:

1
2
3
4
5
6
7
(fn combinations [k s]
  (set (if (<= k 1)
         (map #(set [%]) s)
         (for [ss (combinations (dec k) s)
               x s
               :when (not (ss x))]
           (conj ss x)))))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
(fn k-comb [n coll]
  (cond
   (zero? n) []
   (= 1 n) (set (map set (map vector coll)))
   :else (set (mapcat
     #(set (map (fn [x] (set (cons % x))) (k-comb (dec n) (disj coll %))))
     coll
     ))
    )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
(fn kcomb [k s]
  (cond
    (= k 0) #{}
    (= k 1) (set (map #(set [%]) s))
    (< (count s) k) #{}
    :else (clojure.set/union
            (kcomb k (rest s))
            (->> (kcomb (dec k) (rest s))
              (map #(conj % (first s)))
              set))))
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [n s]
  (cond 
    (= n (count s)) #{s}
    (> n (count s)) #{}
    :else (set 
            (filter
              #(= (count %) n)
              (reduce 
                (fn [c itm]
                  (into c
                    (map #(conj % itm) c)))
                #{#{}} s)))))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
(fn k-comb [k s]
  (if (zero? k) 
    #{#{}}
    (into #{} 
      (mapcat
        (fn [i]
          (map 
            #(conj % i)
            (k-comb (- k 1) (take-while #(not= % i) s))))
        s))))
malvert's solution:

1
2
3
4
5
6
7
(letfn [(f [n s]
  (cond
    (= 0 n) #{#{}}
    (= s []) #{}
    1 (into (f n (rest s))
            (map #(conj % (first s)) (f (- n 1) (rest s))))))]
  f)
matiasl's solution:

1
2
3
4
5
6
7
; choose k-element sets from the powerset of st
(fn [k st]
  (set
    (filter #(= (count %) k)
      (reduce (fn [s t] (into s (for [x s] (conj x t))))
              #{#{}}
              st))))
maximental's solution:

1
2
3
4
5
(fn [n s] 
  (loop [n n a #{#{}}]
    (if (> n 0)
      (recur (dec n) (set (for [x a y s :when (not (x y))] (conj x y))))
      a)))
mbakhterev's solution:

1
(fn R [n S] (set (cond (= 1 n) (map (comp set list) S) (<= 1 n (count S)) (let [h (first S) T (rest S)] (into (R n T) (map #(conj % h) (R (- n 1) T)))))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn combinations--reduce
  [k coll] {:pre [(integer? k), (not (neg? k))]}
  (->> (seq (set coll))
       (reduce (fn [[done acc] x]
                 (let [new-combs
                       (->> (for [comb acc] [(conj comb x) comb])
                            (apply concat)
                            (group-by count))]
                   [(concat done (new-combs k))
                    (->> (dissoc new-combs k)
                         vals
                         (apply concat))]))
               [[] [#{}]])
       first
       set))
mfikes's solution:

1
2
3
4
5
6
7
(fn [n s]
  (let [power-set (fn [s]
                    (let [v (vec s)]
                      (into #{} (for [i (range (apply * (repeat (count v) 2)))]
                                  (into #{} (for [j (range (count v)) :when (bit-test i j)]
                                              (v j)))))))]
    (into #{} (filter #(= n (count %)) (power-set s)))))
minitrue's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [k s]
  (let [gen
          (fn gen [n k]
            (if (zero? k)
              [[]]
              (apply concat
                (for [i (range (- n k -1))]
                  (map (comp #(cons i %) #(map (fn [x] (+ x i 1)) %))
                       (gen (- n i 1) (dec k)))))))
        n (count s)
        m (zipmap (range n) s)
        idx (gen n k)]
    (set (map #(set (map m %)) idx))))
mkahn's solution:

1
2
3
4
5
6
7
8
(fn combinations [n s]
  (let [powerset (fn f [x]
     (if (empty? x)
       #{#{}}
       (into (f (set (rest x))) (set (for [y (vector (first x))
                                                  z (f (set (rest x)))]
                                              (conj z y))))))]
    (set (filter #(== (count %) n) (powerset s)))))
mobiusloop's solution:

1
2
3
4
5
6
7
(fn f [n s]
  (cond
    (> n (count s)) #{}
    (zero? n) #{#{}}
    (and (= n (count s))) #{(set s)}
    :else (let [h (first s) t (rest s)]
      (set (into (f n t) (map #(conj %1 h) (f (dec n) t)))))))
mononite's solution:

1
2
3
4
5
6
7
(fn combination [n s] 
  (let [h (first s) r (rest s) c (count s)] 
    (cond 
     (> n c) #{} 
     (= n c) #{(set s)} 
     (= n 1) (set (map (fn [v] #{v}) s)) 
     :else (into (combination n r) (map #(conj % h) (combination (dec n) r))))))
mouse's solution:

1
2
3
4
5
6
7
8
(fn c [k s]
    (if (= 0 k) [#{}]
      (case (compare k (count s))
        0 #{(set s)}
        1 #{}
        (into #{} (concat (map #(conj % (first s)) (c (dec k) (rest s)))
                          (c k (rest s))))
        )))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn k-kombinations [k coll]
  (letfn [(first-rest-seq
            [k coll]
            (lazy-seq (when (<= k (count coll))
                        (let [f (first coll)
                              r (rest coll)]
                          (cons [f r]
                                (first-rest-seq k r))))))
          (combine
            [e coll]
            (set (map #(clojure.set/union #{e} %)
                      coll)))]
    (if (= k 1)
      (set (map hash-set coll))
      (apply clojure.set/union (map (fn [[f r]]
                                      (combine f (k-kombinations (dec k) r)))
                                    (first-rest-seq k coll))))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
;; TODO: If you take another run at this make it work when n > 4
;; using powerset would be an easy way. Other users have faster solutions.
(fn [n s]
  (let [v (into [] s)
        places (count v)
        combos (for [a (range places)
                     b (range places)
                     c (range places)
                     d (range places)]
                 (distinct (take n [a b c d])))]
    (->> combos
         (map (fn do-combos [combo]
                (map (fn do-combo [i]
                       (nth v i))
                     combo)))
         (filter #(= n (count %)))
         (map set)
         (set))))
nikelandjelo's solution:

1
2
3
(fn [n s]
  (->> (reduce (fn [s el] (mapcat #(vector % (conj % el)) s)) #{#{}} s)
       (filter #(= n (count %))) set))
noiseehc's solution:

1
2
3
4
5
6
(fn kcomb [n s]
  (if (= n 1)
    (set (for [c s] #{c}))
    (apply clojure.set/union
           (for [c s] (set (map #(conj % c) (kcomb (dec n) (disj s c)))))
           )))
norman's solution:

1
2
3
4
5
6
7
8
9
(fn kcom [n items]
  (letfn [(com [items]
            (if (empty? items)
              #{#{}}
              (let [h (first items)
                    com-rest (com (rest items))]
                (into com-rest (map #(conj % h) com-rest)))))]
 
    (into #{} (filter #(= n (count %)) (com items)))))
nothsaevets's solution:

1
2
3
4
5
6
7
(fn [n s]
  (->> (#(reduce (fn [sets elem]
                   (reduce (fn [c n]
                             (conj c (conj n elem))) sets sets))
                 #{#{}} %) s)
       (filter #(= n (count %)))
       (into #{})))
owk4057's solution:

1
2
3
4
5
6
7
(fn myf [n coll]
  (letfn [(subfn [coll e] 
            (apply hash-set (concat (map #(merge % e) coll) coll)))]
    (->> (reduce subfn #{#{}}  coll)
      (filter #(= n (count %)))
      (apply hash-set)
      )))
ownwaterloo's solution:

1
2
3
4
5
(fn [n s]
  (->> s
       (reduce (fn [acc x] (concat (map #(conj % x) acc) acc)) [#{}])
       (filter #(= n (count %)))
       set))
ozan's solution:

1
2
3
4
5
6
7
8
(fn k-combinations [n s]
  (if (> n (count s)) #{}
    (if (= 1 n) (into #{} (map (comp set vector) s))
      (let [prior (k-combinations (dec n) s)]
        (into #{} (for [p prior
              q (clojure.set/difference s p)]
          (clojure.set/union p #{q})
          ))))))
pukeface's solution:

1
2
3
4
5
6
(fn k-comb [n S]
    (if (> n (count S)) #{}
        (if (= n 0) #{#{}}
        (clojure.set/union
          (k-comb n (rest S))
          (set (map #(conj % (first S)) (k-comb (dec n) (rest S))))))))
quant1's solution:

1
2
3
(fn [n s] 
  (let [setcomb (fn [n, s, e] (set (remove #(> (count %) n) (into s (map #(conj % e) s)))))]
  (->> (reduce (partial setcomb n) (set (map #(set [%]) s)) s) (remove #(< (count %) n)) set)))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [n s]
    (->> s vec
    ((fn [v]
      (->>
        (for [i (range 0 (dec (bit-shift-left 1 (count v))))]
            (filter #(zero? (bit-and i (bit-shift-left 1 %))) (range (count v))))
        (filter #(= n (count %))) 
        (map #(set (map v %)))
     ) ))
     set
     ))
sbondaryev's solution:

1
2
3
4
5
6
7
8
9
10
(fn f [m st]
  (letfn [(comb [m [fst & rst :as xs]]
            (cond
              (= m 1) (map hash-set  xs)
              (= (count xs) m) (list (set xs))
              (< (count xs) m) '() 
              :else (concat
                     (map #(conj % fst) (comb (dec m) rst))
                     (comb m rst))))]
  (set (comb m (seq st)))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
(fn k-comb [n st]
  (let [gen-next 
         (fn [p-sets n-set]
           (into #{} (for [p p-sets n n-set
                           :when (not (contains? p n))]
                       (conj p n))))
        st-of-sts (map (fn [n] #{n}) st)]
    (loop [i 1 out-set st-of-sts]
      (if (= i n) (into #{} out-set)
        (recur (inc i) (gen-next out-set st))))))
sheldon's solution:

1
(fn [n x] (set (filter #(= n (count %)) ((fn p [s] (if (empty? s) #{#{}} (let [e (first s) t (disj s e)] (into (p t) ((fn f [e t] (into #{} (map #(conj % e) t))) e (p t)))))) x))))
silverio's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
; generating in reverse lexicographical order
(fn [k s] (let [
  n   (count s)
  vs  (vec s)
  nxt (fn [pr] (->> pr
          (map vector (range))
          (drop-while (fn [[i v]] (= i v)))
          ((fn [[[i h] & t]] (if h (let [n (dec h)]
            `[~@(range (- n i) n) ~n ~@(map second t)]))))))]
  (->> (if (>= n k) (range (- n k) n))
    (iterate nxt)
    (take-while identity)
    (map (partial map vs))
    (map set)
    set)))
skyrem's solution:

1
2
3
4
5
6
7
8
9
;;refer to question 85 power set
(fn [l s]
  (loop [step 0 n #{#{}}]
    (if (= step (count s)) (set (filter #(= l (count %)) n)) ;filter the sets that compliance requirements
      (recur (inc step)
             (apply conj n 
                    (for [x s y n]
                      (conj y x))
                    )))))
soul_awaker's solution:

1
2
3
4
5
(fn [n s]
  (set (filter #(= (count %) n)
    (reduce
      (fn [i e] (into i (map #(conj % e) i)))
      #{#{}} s))))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(letfn [(ps [xs]
  (if (empty? xs) 
    #{#{}}
    (loop [now (first xs)
           left []
           right (vec (rest xs))
           so-far #{(set xs)}]
      (if (empty? right)
        (conj so-far (set left))
        (recur (first right)
               (into left [now])
               (rest right)
               (into so-far (ps (into left right))))))))
        (kc [k xs] (set (filter #(->> % count (= k)) (ps xs))))]
        kc)
syeerzy's solution:

1
2
3
4
5
6
7
8
9
10
11
#(nth (iterate 
       (fn [ss] 
         (set 
          (remove 
           nil? 
           (for [s ss 
                 x %2] 
             (if (s x) 
               nil 
               (conj s x))))))
       [#{}]) %1)
tclamb's solution:

1
2
3
4
5
6
7
8
9
(fn [k s]
  (let [s (vec s)
        c (count s)]
    (set
      (for [i (range (reduce * (repeat c 2)))
            :when (= k (Long/bitCount i))]
        (->> (filter #(bit-test i %) (range c))
             (map s)
             set)))))
thegeez's solution:

1
2
3
4
5
6
7
8
(fn [n items]
    (if (> n (count items))
      #{}
      (->>
       (reduce (fn [acc item]
                 (mapcat (juxt #(conj % item) identity) acc)) [#{}] items)
       (filter #(= n (count %)))
       set)))
zzamboni's solution:

1
2
3
4
5
6
7
(fn kcomb
  ([n coll] (set (flatten (kcomb n (seq coll) #{}))))
  ([n coll so-far]
   (if (zero? n)
     so-far
     (map #(kcomb (dec n) (drop (inc %) coll) (conj so-far (nth coll %)))
          (range (count coll))))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
(fn ! [n xs]
  (cond (> n (count xs)) #{}
        (zero? n) #{#{}}
        (empty? xs) #{#{}}
        :else (into #{}
                    (apply concat
                           (map (fn [x]
                                  (map #(conj % x)
                                       (! (dec n) (disj xs x))))
                                xs)))))
zipzop's solution:

1
2
3
4
5
6
7
8
(fn kc [n s]
   (cond
     (or (= n 0) (empty? s) (> n (count s))) #{}
     (= n (count s)) #{s}
     (= n 1) (set (for [i s] #{i}))
     :else (reduce into #{} (for [i s] (map #(into % #{i}) (kc (dec n) (remove #{i} s)))))
   )
)
yusubori's solution:

1
2
3
4
5
6
7
(fn [n coll]
  (set 
   (filter #(= n (count %))
           (reduce (fn [coll v]
                     (into coll (map #(conj % v) coll))) 
                   #{#{}}
                   coll))))
ydash's solution:

1
2
3
4
(fn [n s]
  (set (filter #(= n (count %))
               ((fn [s] (reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}} s))
                s))))
vpeurala's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [k coll] (letfn [
(conj-to-each [colls x] (map #(conj % x) colls))
(k-combinations [k coll]
    (cond
        (zero? k)
        #{#{}}
        (empty? coll)
        #{}
        :else
        (into
            (into #{} (conj-to-each (k-combinations (dec k) (rest coll)) (first coll)))
            (k-combinations k (rest coll))
        )
    )
)
] (k-combinations k coll)))
v_bogdanov's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn a [x y]
  (letfn [(f [s]
             (if (empty? s)
               #{s}
               (loop [new-set (set (for [x s
                                         y s
                                         :when (not= x y)]
                                     #{x y}))
               result-set (clojure.set/union #{s #{}} new-set (set (for [x s] #{x})))]
                 (let [a (set (for [x new-set
                                    y s
                                    :when (not (contains? x y))]
                                (conj x y)))]
                   (if (= a new-set)
                     result-set
                     (recur a (into result-set a)))))))]
    (set (filter #(= x (count %)) (f y)))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn k-combine [n xset]
  (letfn [(inter [xset-1 xset-2]
            (set (for [s1 xset-1 s2 xset-2]
                   (clojure.set/union s1 s2))))
          (init-set [xs]
            (set (for [s xs] (set (list s)))))]
    (let [xs (init-set xset)]
      (cond
       (= n 1) xs
       (> n (count xs)) #{}
       :else (loop [acc xs cnt (dec n)]
               (if (= cnt 0)
                 (set (filter #(= n (count %)) acc))
                 (recur (inter acc xs) (dec cnt))))))))
trxeste's solution:

1
2
3
4
5
6
7
(fn combinations [k s]
  (cond
    (zero? k) #{#{}}
    (empty? s) #{}
    :else (set (clojure.set/union 
                 (map #(conj % (first s)) (combinations (dec k) (rest s)))
                 (combinations k (rest s))))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn c [k s]
  (cond
   (empty? s) #{}
   (= 1 k) (set (map #(hash-set %) s))
   :else
   (set
    (let [ss (seq s)
          h (first ss)
          t (-> ss rest set)]
      (concat
       (map #(conj % h) (c (dec k) t))
       (c k t))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)