;; 82 Word Chains [h]

A set of words ordered so that each word differs by
only one letter from the words directly before and after it.
Can be either an insertion, a deletion, or a substitution:
cat -> cot -> coat -> oat -> hat -> hot -> hog -> dog

Takes a sequence of words, and returns true
if they can be arranged into one continous word chain,
and false if they cannot.

(= true (__ #{"hat" "coat" "dog" "cat" "oat" "cot" "hot" "hog"}))
(= false (__ #{"cot" "hot" "bat" "fat"}))
(= false (__ #{"to" "top" "stop" "tops" "toss"}))
(= true (__ #{"spout" "do" "pot" "pout" "spot" "dot"}))
(= true (__ #{"share" "hares" "shares" "hare" "are"}))
(= false (__ #{"share" "hares" "hare" "are"}))
(fn find-chain [words]
  (let [lev (fn lev [s1 s2]
              (cond (empty? s1) (count s2)
                    (empty? s2) (count s1)
                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))
                    :else (inc (min (lev (rest s1) s2)
                                    (lev s1 (rest s2))
                                    (lev (rest s1) (rest s2))))))
        neighbors (fn [words word] (filter #(= (lev word %) 1) words))
        chain (fn chain [graph visited root]
                (let [visited (conj visited root)
                      neigh (remove visited (graph root))]
                  (if (= visited words) 
                    true
                    (some (partial chain graph visited) neigh))))
        graph (into {} (for [w words] [w (neighbors words w)]))]
    (true? (some (partial chain graph #{}) words))))

(fn [xs]
  (letfn [(one-d [[a & a-rest] [b & b-rest :as bs]]
            (if (= a b)
              (recur a-rest b-rest)
              (= (apply str a-rest) (apply str bs))))
          (chains? [l r]
            (let [[count-l count-r] (map count [l r])]
              (cond
                (= count-l count-r) (= 1 (apply + (map #(if (= %1 %2) 0 1) l r)))
                (= 1 (- count-l count-r)) (one-d l r)
                (= -1 (- count-l count-r)) (one-d r l)
                :else false)))
          (transitions []
            (->>
              (for [x xs y xs :when (chains? x y)] [x y])
              (group-by first)
              (reduce-kv #(assoc %1 %2 (map second %3)) {})))
          (moves
            ([trs] (moves trs (keys trs)))
            ([trs keys]
             (if (empty? trs)
               true
               (some true? (map #(if-let [chain (get trs %1)]
                                   (moves (dissoc trs %1) chain))
                                keys)))))]
    (or (moves (transitions)) false)))

(fn
 [sss]
 (let
  [vec-remove
   (fn [coll pos] (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))
   one-letter-difference
   (fn
    [w1 w2]
    (let
     [w1c (count w1) w2c (count w2) w1s (seq w1) w2s (seq w2)]
     (if
      (= w1c w2c)
      (if
       (=
        1
        (count
         (filter
          (fn* [p1__2893#] (= p1__2893# false))
          (map (fn* [p1__2894# p2__2895#] (= p1__2894# p2__2895#)) w1s w2s))))
       w2
       "")
      (if
       (< w1c w2c)
       (if
        (<
         0
         (count
          (filter
           #{true}
           (map
            (fn* [p1__2896#] (= (apply str p1__2896#) w1))
            (map
             (fn* [p1__2897#] (vec-remove (vec w2s) (first p1__2897#)))
             (map-indexed (fn [i e] (vector i e)) w2s))))))
        w2
        "")
       (if
        (<
         0
         (count
          (filter
           #{true}
           (map
            (fn* [p1__2898#] (= p1__2898# w2))
            (map
             (fn* [p1__2899#] (clojure.string/replace-first w1 p1__2899# ""))
             w1s)))))
        w2
        "")))))
   combinations
   (fn
    combinations
    [s r]
    (if
     (empty? (rest s))
     (vector (conj r (first s)))
     (mapcat
      (fn*
       [p1__2900#]
       (combinations (remove #{p1__2900#} s) (conj r p1__2900#)))
      s)))]
  (<
   0
   (count
    (filter
     #{true}
     (map
      (fn*
       [p1__2901#]
       (= (last p1__2901#) (reduce one-letter-difference p1__2901#)))
      (combinations sss [])))))))

(fn [wordSet]
  (letfn[(nextChainLink? [str1 str2];check if str2 and str1 could be linked together
                         (let [[s1 s2] (if (< (count str1) (count str2)) [str1 str2] [str2 str1])
                               s1Len (count s1), s2Len (count s2)]
                           (cond
                            (> (- s2Len s1Len) 1) false
                            (= s2Len s1Len) (= 1 (count (remove true? (map = s1 s2)))) ;only one letter difference
                            :else (some true? ;some true?
                                        (map #(= (seq s1) %);compare if s1 = s2
                                             (for [r (range s2Len)]
                                               (concat (take r s2) (drop (inc r) s2))))))))];remove one letter from the longer string
    (let [wordCount (count wordSet)]
      (loop [chains (for [w wordSet] [#{w} w])];initially the chains grow at each word, first element is the visited word, second one is the last word on the chain
        (let [extendedChains (for [[visited lastWord] chains word wordSet :when (and (nil? (visited word)) (nextChainLink? lastWord word))]
                               [(conj visited word) word])];if the word has not been visited and is one step away, extend the chain
          (cond
           (empty? extendedChains) false;cannot extend the chain any more
           (not-any? #(= wordCount %) (map (comp count first) extendedChains)) (recur extendedChains);keep extending the chains
           :else true))))));found a chain has cover the input set

(let [
  tourable?
    (fn [g]
      (<= (* 2 (count g))
        (reduce +
          (map #(count (val %)) g))))
 
  dist
    (fn [w1 w2]
      (letfn [
               (dist [d w1 w2]
                 (cond
                   (empty? w1) (count w2)
                   (empty? w2) (count w1)
                   :else
                   (min
                     (inc (d d (rest w1) w2))
                     (inc (d d w1 (rest w2)))
                     (+ (if (= (first w1) (first w2)) 0 1)
                       (d d (rest w1) (rest w2))))))]
        (dist (memoize dist) w1 w2)))]
  (fn [words]
    (tourable?
      (reduce (fn [m w] (assoc m w (filter #(= 1 (dist w %)) words))) {} words))))
aceeca1's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(letfn [
    (dis [x1 x2] (cond 
        (= 0 (count x1)) (count x2)
        (= 0 (count x2)) (count x1)
        true (apply min (remove nil? [
            (inc (dis (rest x1) (rest x2)))
            (inc (dis x1 (rest x2)))
            (inc (dis (rest x1) x2))
            (when (= (first x1) (first x2)) (dis (rest x1) (rest x2)))]))))
    (begin-chain [x] (cond
        (= 1 (count x)) [(first x)]
        true (for [i x :when (seq (filter #(> 2 (dis i %)) (begin-chain (disj x i))))] i)))
    (is-chain [x] (boolean (seq (begin-chain x))))] is-chain)
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
(fn wc [w]
  (let [ld (fn [a b] ((reduce (fn [acc [i j]]
                                (assoc acc [i j]
                                       (if (zero? (min i j))
                                         (max i j)
                                         (min (inc (acc [(dec i) j]))
                                              (inc (acc [i (dec j)]))
                                              (+ (acc [(dec i) (dec j)])
                                                 (if (= (nth a (dec i))
                                                        (nth b (dec j)))
                                                   0 1))))))
                              {}
                              (sort-by #(apply + %)
                                       (for [i (range (inc (count a)))
                                             j (range (inc (count b)))]
                                         [i j])))
                      [(count a) (count b)]))
        adjacent? (fn [w1 w2] (= 1 (ld w1 w2)))
        adjacencies (zipmap (vec w) (for [word (vec w)] (apply hash-set (filter #(adjacent? word %) (vec w)))))
        wc? (fn [ws] (every? identity (map adjacent? ws (rest ws))))
        adjacent? (fn [w1 w2] ((adjacencies w1) w2))
        perms (fn perms [things prev]
                (lazy-seq
                 (if (= 1 (count things))
                   (list things)
                   (for [head things
                         tail (perms (disj things head) head)
                         :when (or (nil? prev)
                                   (adjacent? head prev))]
                     (cons head tail)))))
        ]
 
    (not (nil? (first (filter wc? (perms w nil)))))
 
    ))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
(fn chainX[x]
    (letfn[
        (different [ai bi]
            (= ai bi)
        )
        (substitution[a b]
            (and 
                (= (count a)(count b))
                (= (count (filter false? (map different a b))) 1)
            )
        )
        (removeS[s n]
            (str (subs s 0 n) (subs s (inc n)))
            )
        (inserted [a b]
            (if
                (= (inc (count a))(count b))
                (let [idx (first (filter #(not= (get a %)(get b %)) (range (count b))))]
                    (= a (removeS b idx))
                )
                false
            )
        )   
        (chained[a b]
            (or
                (substitution a b)
                (inserted a b)
                (inserted b a)
            )
        )
        (chainRec[w x]
            (if (empty? x)
                true
                (not (not-any? (fn[w1] (and (chained w w1) (chainRec w1 (disj x w1)))) x))
            )
 
        )
 
 
        ]
 
        (not (not-any?  (fn[w] (chainRec w (disj x w))) x))
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn chainable? [xs]
  (let [can-chained? (fn [from_] (fn  [to_]                        
          ((fn iter [[from-first & from-rest :as from] [to-first & to-rest :as to] changed]
             (cond (and (empty? from) (empty? to)) true
                   (= from to) true
                   changed false
                   (empty? from) (iter from to-rest true) ;insert from/delete to
                   (empty? to) (iter from-rest to true) ;insert to/delete from
                   :else (or (iter from to-rest true) ;insert from/delete to
                             (iter from-rest to true) ;insert to/delete from
                             (iter from-rest to-rest (not= from-first to-first))))) ;modify or equals
          (seq from_) (seq to_) false)))
        chainable-graph (->> xs
                          (map (fn [x] {x (filter (can-chained? x) (filter (partial not= x) xs))}))
                          (into {}))
        or_ (fn ([x y] (or x y)) ([] false) )
        depth-maximal-from? (fn [x]
                              ((fn rec-traverse [xs x]
                                 (if (= 1 (count xs)) true
                                   (->> (chainable-graph x)
                                        (filter (partial contains? xs))
                                        (map (partial rec-traverse (disj xs x)))
                                        (reduce or_))))
                              xs x))]
    (->> xs
      (map depth-maximal-from?)
      (reduce or_))))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
(fn [words]
  (letfn [(one-diff? [w1 w2]
            (let [fronts (fn [w] (map #(take % w) (range 1 (inc' (count w)))))
                  backs (fn [w] (map #(drop % w) (range (count w))))
                  fw1 (fronts w1)
                  fw2 (fronts w2)
                  bw1 (backs w1)
                  bw2 (backs w2)
                  froverlap (clojure.set/intersection (set fw1) (set fw2))
                  boverlap (clojure.set/intersection (set bw1) (set bw2))
                  largestfover (last (sort-by count froverlap))
                  largestbover (last (sort-by count boverlap))
                  candidate (apply str (concat largestfover largestbover))
                  dl (- (count w1) (count w2))
                  lengths? (and (> dl -2) (< dl 2))
                  ldbyone (= 1 (- (count w1) (count candidate)))
                  samelength (= (count w1) (count w2))]
              (cond
               (not lengths?) false
               (or (= candidate w1) (= candidate w2)) true
               (and ldbyone samelength) true
               :else false)))
          (all-splits [s] (map #(split-at % s) (range (inc (count s)))))
          (put-in-each-slot [a s] (map #(concat (first %) [a] (last %)) (all-splits s)))
          (next-perm [a ps] (mapcat #(put-in-each-slot a %) ps))
          (perms [s]
            (loop [inthing (first s) res [[]] left (rest s)]
              (if (empty? left)
                (next-perm inthing res)
                (recur (first left) (next-perm inthing res) (rest left)))))
          (chain? [ws]
            (let [oned? (map #(one-diff? (nth ws %) (nth ws (inc %))) (-> ws count dec range))]
              (every? identity oned?)))]
      (-> (filter chain? (perms words)) empty? not)))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
(fn f [ws]
  (letfn [(differ-one [w1 w2]
            ((fn differ-one' [w1 w2 diffs]
               (let [[c1 & w1r] w1
                     [c2 & w2r] w2]
                 (cond (> diffs 1)               false
                       (and (not c1) (not c2))   (= diffs 1)
                       (= c1 c2)                 (differ-one' w1r w2r diffs)
                       :else                     (or (differ-one' w1 w2r (inc diffs)) ;w1 has del
                                                     (differ-one' w1r w2 (inc diffs)) ;w2 has del
                                                     (differ-one' w1r w2r (inc diffs)) ;substitution
                                                     ))))
             w1 w2 0))
 
          (find-differ-by-one [w words]
            (filter #(and (differ-one w %)) words))
 
          (find-differ-by-one-chain [words]
            (println "===============================")
            (println "words:" words)
            (if (= (count words) 0)
              true
              (let [[w & wr] (seq words)
                    _ (println "w wr:" w wr)
                    next-words (find-differ-by-one w words)
                    _ (println "next-words" next-words)]
                (some #(= % true) (map find-differ-by-one-chain next-words)))))
          
          (f' [w ws]
            "Return true is w is start of chain that connects all of ws"
            (println "w ws:" w ws)
            (if (= (count ws) 0)
              true
              (if-let [dw (set (find-differ-by-one w ws))]
                (some #(f' % (-> ws
                                 (disj %))) dw))))]
      (if (some #(f' % (disj ws %)) ws) true false)))
andthorn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [w]
  (let [f (fn f [x y] (and (= (inc(count x)) (count y))(contains? (set (map #(apply str (keep-indexed (fn [i e] (if (not= % i) e)) y)) (range 0 (count y)) ))x)))
        g (fn g [x y]
          (if (= (count x) (count y))
            (loop [x x yl y c 0]
              (if x
                (recur (next x) (next yl) (if (= (first x) (first yl)) c (inc c) ))
                (if (= 1 c) y)))
            (if (or (f x y) (f y x))
              y
              )))
        h (map-indexed #(vector %2 (filter identity (map (partial g %2) w))) w)
        i (fn i [g x k]
            (if (= (count x) (count w))
              true
              (some identity (concat (map #(i g (conj x %) (apply disj (set(get g %)) x)) k)))))]
  (not (nil? (i (apply hash-map (apply concat h)) #{} (map first h))))))
anjensan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [c]
    (let [sp (fn [[af & ar :as a] [bf & br :as b]] 
               (if (= af bf)
                 (recur ar br)
                 [a b]))
          t (fn [a b]
              (let [[a b] (sp a b)
                    [a b] (sp (reverse a) (reverse b))]
                (and (<= (count a) 1) (<= (count b) 1))))
          g (fn g [s v]
              (or
                (empty? v)
                (some #(and (t s %) (g % (disj v %))) v)))]
        (boolean (some identity (map #(g % (disj c %)) c)))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn
  [coll]
  (letfn [(dels [s]
            (set (for [x (range (count s))]
                   (str (subs s 0 x) (subs s (inc x))))))
          (canpair
            [w1 w2]
            (or (and (= (count w1) (count w2))
                     (= 1 (apply + (map #(if (= % %2) 0 1) w1 w2))))
                (and (= (count w1) (inc (count w2)))
                     (contains? (dels w1) w2))
                (and (= (inc (count w1)) (count w2))
                     (contains? (dels w2) w1))))
          (find-sol-r [v s fs]
            (if (seq s)
              (let [h (first s)
                    t (rest s)
                    p (peek v)]
                (if (or (nil? p)
                        (canpair p h))
                  (or (find-sol-r (conj v h) (disj fs h) (disj fs h))
                      (find-sol-r v t fs))
                  (find-sol-r v t fs)))
              (= (count coll) (count v))))]
    (find-sol-r [] (set coll) (set coll))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
(fn [s]
  (letfn [(distance [a b]
    (loop [scores [[a b 0]]]
      (let [finished (filter (fn [[a b _]] (and (empty? a) (empty? b))) scores)]
        (if (seq finished)
          (apply min (map last finished))
          (recur (mapcat (fn [[a b score]]
            (if (= (first a) (first b))
              [[(rest a) (rest b) score]]
              (concat
                (if (empty? a) [] [[(rest a) b (inc score)]])
                (if (empty? b) [] [[a (rest b) (inc score)]])
                (if (or (empty? a) (empty? b)) [] [[(rest a) (rest b) (inc score)]]))))
            scores))))))
    (chains [chain]
      (let [left (apply disj s chain)]
        (mapcat (fn [word] (concat
          (if (= 1 (distance word (first chain)))
            [(vec (cons word chain))] [])
          (if (= 1 (distance word (last chain)))
            [(conj chain word)] [])))
          left)))]
    (loop [possible-chains (map vector s) previous []]
      (print possible-chains)
      (cond
        (some #(= (count %) (count s)) possible-chains)
          true
        (= previous possible-chains)
          false
        true
          (recur (mapcat chains possible-chains) possible-chains)))))
awebb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn wc [s]
  (letfn 
    [(insertion? [w1 w2] 
      (and (= (-> w1 count inc) (-> w2 count))
        (loop [w1 w1, w2 w2, i 0]
          (cond 
            (> i 1) false
            (empty? w1) true
            (= (first w1) (first w2)) (recur (next w1) (next w2) i)
            :else (recur w1 (next w2) (inc i))  ))))
     (deletion? [w1 w2] 
       (insertion? w2 w1))
     (substitution? [w1 w2]
       (and (= (count w1) (count w2))
          (->> [w1 w2] (apply map not= ) (filter identity) count (= 1)) ))
     (follows? [w1 w2] 
       (some identity ((juxt insertion? deletion? substitution?) w1 w2)))
     (follow-seq [w1 ws]
       (filter (partial follows? w1) ws))
     (follow-tree [v words]
        (for [x v] (cons x (follow-tree (follow-seq x words) (remove #(= x %) words)  ))))
     (max-depth [tree]
        (if (and (seq? tree) (not-empty tree)) (inc (apply max (map max-depth tree))) 0)) ]
    (= (-> s count inc) (max-depth (follow-tree s s)))))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn chain [words]
  (letfn 
    [ (chain-helper [words next-start]
        (chain?
          next-start
          (remove #(= next-start %) words)))
      (adjacent? [n [q-head & q-tail :as q] [r-head & r-tail :as r]]
        (cond
          (neg? n) false
          (and (nil? q-head) (nil? r-head)) true
          (or  (nil? q-head) (nil? r-head)) (adjacent? (dec n) q-tail r-tail)
          (= q-head r-head) (adjacent? n q-tail r-tail)
          :else
            (or
              (adjacent? (dec n) q-tail r-tail)
              (adjacent? (dec n) q      r-tail)
              (adjacent? (dec n) q-tail r))))
      (chain? [start words]
       (let
         [out-going (for [word words :when (adjacent? 1 start word)] word)]
         (cond
           (empty? words)     true
           (empty? out-going) false
           :else (some identity (map (partial chain-helper words) out-going))))) ]
    (true? (some identity (map (partial chain-helper words) words)))))
benhammond's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [s-coll]
    (let [eq-step? (fn [s1 s2] (= 1 (count (filter not (map = (seq s1) (seq s2))))))
          embiggen (fn [s] (map (fn [c] (clojure.string/join "_" (map clojure.string/join (split-at c s)))) (range (inc (count s)))))
          single-step? (fn [s1 s2] (case (apply - (map count [s1 s2]))
                                     0 (eq-step? s1 s2)
                                     1 (some (partial eq-step? s1) (embiggen s2))
                                     -1 (some (partial eq-step? s2) (embiggen s1))
                                     false))
          lookup (reduce (fn [m s] (assoc m s (set (filter (partial single-step? s) s-coll)))) {} s-coll)
          non-repeating? (fn [sv] (= (count sv) (count (set sv))))
          single-aug (fn [sv] (if-let [nv (get lookup (last sv))] (mapv (partial conj sv) nv)))
          multi-aug (fn [svv] (set (filter non-repeating? (filter (complement nil?) (mapcat single-aug svv)))))
          distinct-chains (loop [i (dec (count s-coll)) svv (map vector (keys lookup))]
                            (if (zero? i) (set (map set svv)) (recur (dec i) (multi-aug svv))))
          ]
      (not (nil? (some (partial = s-coll) distinct-chains)))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
(fn [words]
  (letfn [(by-subs? [a b]
            (and (= (count a) (count b))
                 (= 1 (count (filter true? (map not= a b))))))
          (by-addn? [a b]
            (let [[la lb] (map count [a b])]
              (and (= (inc la) lb)
                   (let [drops (map (fn [i]
                                      (apply str
                                             (concat
                                              (take i b)
                                              (drop (inc i) b))))
                                    (range (inc lb)))]
                     (some #{a} drops))
                   true)))
          (by-deln? [a b] (by-addn? b a))]
    (let [neighbors (apply merge-with into
                          (for [w words
                                w2 words
                                :when (not= w w2)
                                :when (some #(% w w2) [by-subs? by-addn? by-deln?])]
                            {w #{w2}}))
          nexts (fn [path]
                  (let [l (last path)]
                    (for [w (neighbors l)
                          :when (not ((set path) w))]
                      (conj path w))))
          paths (iterate
                 (fn [paths]
                   (into #{} (mapcat nexts paths)))
                 (set (map vector words)))
          reachable (nth paths (dec (count words)))
          sets (into #{} (map set reachable))]
      (if (sets words) true false))))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(fn [s]
  (let [
        vec-remove
        (fn vec-remove
          [coll pos]
          (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))
        p
        (fn p [str1 str2]
          (let [len1 (count str1)
                len2 (count str2)]
            (cond (zero? len1) len2
                  (zero? len2) len1
                  :else
                  (let [cost (if (= (first str1) (first str2)) 0 1)]
                    (min (inc (p (rest str1) str2))
                         (inc (p str1 (rest str2)))
                         (+ cost
                            (p (rest str1) (rest str2))))))))
        q
        (fn q [word s]
          (let [v (vec s)]
            (if (empty? v) true
              (some true? (for [i (range (count v))]
                            (if (= (p (nth v i) word) 1)
                              (q (nth v i) (vec-remove v i))
                              false))))))
        ]
    (true? (some true? (for [i (range (count (vec s)))]
                         (q (nth (vec s) i) (vec-remove (vec s) i)))))))
burner's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(letfn [(substitute? [w1 w2]
                (or (and (empty? w1) (empty? w2))
                    (and (= (first w1) (first w2))
                         (substitute? (rest w1) (rest w2)))
                    (= (rest w1) (rest w2))))
              (insert? [w1 w2]
                (or (and (empty? w1) (= (count w2) 1))
                    (and (= (first w1) (first w2))
                         (insert? (rest w1) (rest w2)))
                    (= (seq w1) (rest w2))))
              (delete? [w1 w2] (insert? w2 w1))
              (next? [w1 w2] (or (substitute? w1 w2) (insert? w1 w2) (delete? w1 w2)))
              (chain [w words] 
                (if (empty? words) [w]
                    (cons w (apply max-key count [] 
                                 (map (fn [nw] (chain nw (remove #(= % nw) words)))
                                      (filter #(next? w %) words))))))]
        (fn [words] 
          (= (apply max (map #(count (chain % (remove (fn [x] (= % x)) words))) 
                             words))
             (count words))))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
;same as the wordladder from leetcode
;it looks like a string problem, but is actually a graph problem.
#(let [numOfNodes (count %)
       removeLetterAt (fn [s i]
                        (str (subs s 0 i) (subs s (inc i))))
       oneLetterDifferent? (fn [s1 s2]
                             (cond
                              (= s1 s2) false
                              (= (count s1) (count s2)) (loop[ind 0]
                                                          (cond (>= ind (count s1)) false
                                                                (= (removeLetterAt s1 ind) (removeLetterAt s2 ind)) true
                                                                :else (recur (inc ind))))
                              :else (let[[ss ls](if(< (count s1) (count s2)) [s1 s2] [s2 s1])]
                                      (loop[ind 0]
                                        (cond (>= ind (count ls)) false
                                              (= (removeLetterAt ls ind) ss) true
                                              :else (recur (inc ind)))))))
       buildGraph (fn [words]
                    (into #{} (for[w1 words w2 words :when (oneLetterDifferent? w1 w2)] [w1 w2])))
       growPath (fn [g]
                  (loop[paths g]
                    (let [np (set (concat (for [p paths [a b] g :when (= a (last p))]
                                            (if (some (fn[x] (= b x)) p) p (conj p b)))))]
                      (if (= np paths) np
                        (recur np)))))]
   (= numOfNodes (apply max (map count (growPath (buildGraph %))))))
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [arg]
   (letfn [(reststr [x] (apply str (rest x)))
           (conn? [x y]
             (cond (= (first x) (first y)) (conn? (reststr x) (reststr y))
                   (> (count x) (count y)) (= (reststr x) y)
                   (< (count x) (count y)) (= x (reststr y))
                   (= (count x) (count y)) (= (reststr x) (reststr y))
                   ))
           (chain? [x xs]
             (if (empty? (disj xs x))
               true
               ((complement not-any?) true? (map #(chain? % (disj xs x))
                                                 (filter #(conn? x %) (disj xs x)))))
             )]
     ((complement not-any?) true? (map #(chain? % arg) arg))))
chunchangshao's solution:

1
2
3
4
#(case (count %) 
   (8 6) true 
   5 (if (some #{"share"} %) true false)
   false)
ctzsm's solution:

1
2
3
4
5
6
7
8
9
(fn [s] (letfn
           [(find-path [paths v seen] (if (seen v) seen (for [u (paths v)] (find-path paths u (conj seen v)))))
            (edit-dist [a b] (cond (not b) (count a) (not a) (count b) 
                                   :else (let [ra (next a) rb (next b)] 
                                           (if (= (first a) (first b)) 
                                             (edit-dist ra rb) 
                                             (+ 1 (min (edit-dist ra rb) (edit-dist ra b) (edit-dist a rb)))))))]
           (let [m (into {} (for [u s] [u (filter #(= 1 (edit-dist u %)) s)]))]
             (if (some (fn [u] (some #(= % s) (flatten (find-path m u #{})))) s) true false))))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(letfn [(levenshtein [step xs ys]
          (cond
           (empty? xs)
           (count ys)
           
           (empty? ys)
           (count xs)
           
           :else
           (let [[x & sub-xs] xs
                 [y & sub-ys] ys
                 cost (if (= x y) 0 1)]
             (min (inc (step step sub-xs ys))
                  (inc (step step xs sub-ys))
                  (+ cost (step step
                                sub-xs
                                sub-ys))))))]
  
  (let [step (memoize levenshtein)]
    (letfn [(chain? [word word-set]
              (or (empty? word-set)
                  (some #(and (= 1 (step step word %))
                              (chain? % (disj word-set %)))
                        word-set)))]
      
      (fn word-chain? [word-set]
        (or (some #(chain? % (disj word-set %))
                  word-set)
            false)))))
daniels's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [x]
  (let [issub? (fn [a b]
                 (and 
                  (= (count a) (count b)) 
                  (= 1 (reduce + (map #(if (= % %2) 0 1) a b)))))
        isdel? (fn [a b]
                 (and
                  (= (dec (count a)) (count b))
                  (loop [x a y b c 0]
                    (if (and (empty? x) (empty? y) (= 1 c) )
                      true
                      (if (= (first x) (first y)) 
                        (recur (rest x) (rest y) c) 
                        (if (> c 0) false (recur (rest x) y (inc c))))))))
        isone? #(or (isdel? % %2) (isdel? %2 %) (issub? % %2))]
    (loop [r [(first x)] i (rest x) f []]
      (if (and (or (nil? i) (empty? i)) (empty? f))
        true
        (if (or (empty? i) (nil? i))
          false
          (if (isone? (first r) (first i))
            (recur (cons (first i) r) (concat (rest i) f) [])
            (if (isone? (last r) (first i))
              (recur (conj (into [] r) (first i)) (concat (rest i) f) [])
              (recur r (rest i) (conj f (first i))))))))))
daowen's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [all-words]
  (letfn [(neighbors? [a b]
            (let [[[cx x] [cy y]] (sort (map (juxt count str) [a b]))]
              (case (- cy cx)
                0 (= 1 (reduce + (map #(if (= % %2) 0 1) x y)))
                1 (let [n (count (take-while #(apply = %) (map list x y)))]
                    (= (subs x n) (subs y (inc n))))
                false)))
          (spans? [words root]
             (let [words (disj words root)
                   neighbors (filter #(neighbors? % root) words)]
               (or (empty? words) (some #(spans? words %) neighbors))))]
    (boolean (some #(spans? all-words %) all-words))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn _ 
   ([words] 
       ;(for [w words] (_ [w] (disj words w)))
       (= (count words) (last (sort (flatten(for [w words] (_ [w] (disj words w)))))) )
   )
   ([chain words]
     (let [find-next (fn [node words](filter (fn [w](if (< (count w) (count node)) (if (>(- (count node) (count w)) 1) false(not= nil (re-find (re-pattern (apply str (concat ".?" (interpose ".?" w) ".?"))) node)))(if (= (count w) (count node)) (<= (count (for [i (range (count node)) :when (not= (nth w i) (nth node i))]i)) 1)(if (> (- (count w) (count node)) 1) false(not= nil (re-find (re-pattern (apply str (concat ".?" (interpose ".?" node) ".?"))) w)))))) words))
         next_words (find-next (last chain) words)]
       (if (empty? next_words) (count chain)
          (for [w next_words] (_ (conj chain w) (disj words w)))
       )
     )
   )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(fn [words] 
  (letfn [
    (hoppable [w1 w2] 
      (let [l1 (count w1) l2 (count w2)] 
        (if (= l1 l2)
          (>= 1 (count (filter (fn [[l1 l2]] (not= l1 l2)) (map vector w1 w2))))
          (if (= 1 (Math/abs (- l1 l2))) 
            (let [w1longer (> l1 l2)
                  lw (if w1longer w1 w2)
                  sw (if w1longer w2 w1)
                  lwl (count lw)
                  lwv (vec lw)] 
              (<= 1 (count (filter #(= (seq sw) %)
                                   (concat [(drop 1 lwv)] [(drop-last lwv)] 
                                           (map 
                                            (fn [p] (concat (subvec lwv 0 p) (subvec lwv (inc p) lwl))) 
                                            (range 1 (dec lwl)) 
                                            ))
                                   ))))
            false))))
    ]
    (let [n (count words)
           nindexmap (zipmap words (range n))
           adj (map (fn [w] (map (partial hoppable w) words)) words)
           neibs (map #(set (map first (filter (fn [x] (second x)) (map-indexed vector %)))) adj)
           myorreducer #(or %1 %2)]
      (letfn [
        (searchlet [lastn visited]
          (if (= n (count visited)) true
            (let [nextset (clojure.set/difference (nth neibs lastn) visited)]
              (if (empty? nextset) false
                (reduce myorreducer (map #(searchlet % (conj visited %)) nextset))
                ))))
        ]
        (reduce myorreducer (map #(searchlet % #{%}) (range n)))
      ))))
devm33's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn [words]
  (letfn [(neighbors? [a b]
            (if (= (count a) (count b))
              (= 1 (count (filter not (map = a b))))
              (loop [as (seq a)
                     bs (seq b)
                     d 0]
                (let [feq (= (first as) (first bs))]
                  (if (and (empty? as) (empty? bs))
                    (< d 2)
                    (if (and (> 0 d) (not feq))
                      false
                      (let [ashort (< (count as) (count bs))]
                        (recur
                          (if (or feq (not ashort)) (rest as) as)
                          (if (or feq ashort) (rest bs) bs)
                          (if feq d (inc d))))))))))]
    (letfn [(find-neighbor [n xs] (some #(when (neighbors? % n) %) xs))]
      (let [fw (rand-nth (seq words))]
        (loop [fst fw lst fw xs (disj words fw)]
          (if (empty? xs)
            true
            (let [nfst (find-neighbor fst xs)]
              (let [nlst (find-neighbor lst (if nfst (disj xs nfst) xs))]
                (if (not (or nfst nlst))
                  false
                  (let [rf (or nfst fst) rl (or nlst lst)]
                    (recur rf rl (disj xs rf rl))))))))))))
dwelte's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(let [
sub? (fn [p n]
  (= 1 (reduce + (map #(if (not= % %2) 1 0) p n))))
 
del? (fn [p n]
  (if (= (first p) (first n))
    (recur (rest p) (rest n))
    (= (seq (rest p)) (seq n))))
 
one-away? (fn [p n]
  (cond
    (nil? p) true
    (= (count p) (count n)) (sub? p n)
    (= (dec (count p)) (count n)) (del? p n)
    (= (inc (count p)) (count n)) (del? n p)
    :else false))
 
connected? (fn c? [p s]
  (if (empty? s)
    true
    (if (some #(and (one-away? p %) (c? % (disj s %))) s) true false)))]
 
(fn [s] (connected? nil s)))
dzholev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s]
    (let [dif-1? (fn dif-1? [a b] (cond
                                    (= (first a) (first b)) (dif-1? (rest a) (rest b))
                                    (= (seq a) (rest b)) true
                                    (= (seq b) (rest a)) true
                                    (= (rest a) (rest b)) true
                                    :else false))
          candidates (fn [h r] (filter #(dif-1? h %) r))
          traverse (fn traverse [e s]
                     (if (empty? s)
                       true
                       (boolean (some #(traverse % (disj s %)) (candidates e s)))))]
      (boolean (some #(traverse % (disj s %)) s))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
(fn [s]
    (let [
        distance=1?
        (fn [w1 w2]
         (let
          [[l1 l2] (map count [w1 w2])
          check (fn [m [a & wa :as w1] [b & wb]] ; insert (m=true) ; else subst
              (if (not= a b)
               (if (not= (if m (seq w1) wa) wb)
                false
                true)
               (recur m wa wb)))]
          (cond 
           (= w1 w2) false
           (= l1 l2) (check false w1 w2) ; substitution ?
           (> l1 l2) (recur w2 w1)
           (= 1 (- l2 l1)) (check true w1 w2) ; insertion ?
           :else false)))
        g (reduce
            (fn [h e] 
                    (assoc h e (set (filter (partial distance=1? e) s))))
            {} s)]
    ((fn rec-wordchain? [ l v ws ]
        (cond
            (= l 0) (do
                    (println "l = " l "; v = " v "; ws =" ws)
                    true)
            (empty? ws) false
            :else (reduce 
                    #(or %1 (rec-wordchain? (dec l) (conj v %2) (apply disj (g %2) v))) 
                    false ws)))
    (count s) [] s)))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
(letfn [                                                                                                                                                
    (is-linked?                                                                                                                                         
        ([[a b]] (is-linked? a b))                                                                                                                      
        ([a b] (let [ca (count a) cb (count b)]                                                                                 
            (cond                                                                                                                                       
                (=  a  b) true                    ; identity                                                                    
                (= ca cb) (is-subs? a b)          ; substitution                                                                                        
                (= -1 (- ca cb)) (is-inse? a b)   ; 1 insertion                                                                 
                (=  1 (- ca cb)) (is-dele? a b)   ; 1 deletion                                                                                          
                :else false))))                   ; everything else                                                             
    (is-subs? [a b] (= 1 (reduce (fn [acc [x y]] (+ acc (if (= x y) 0 1))) 0 (partition 2 (interleave a b)))))                                          
        ; we only need to check after the first difference since we've                                                          
        ; already checked that they are only 1 character difference                                                                                     
    (is-dele? [a b] (let [i (first (keep identity (map #(if (not= %1 %2) %3) a b (range))))]                                    
                        (if (nil? i)                                                                                                                    
                            true                                                                                                
                            (= (subs a (inc i)) (subs b i)))))                                                                                          
    (is-inse? [a b] (is-dele? b a))                                                                                             
    (all-pairs [s] (for [x s y s :when (< (.compareTo x y) 0)] [x y]))                                                                                  
    (linked-pairs [s] (let [l (filter is-linked? (all-pairs s))                                                                 
                           r (map (fn [[a b]] [b a]) l)]                                                                                                
                        (set (concat l r))))                                                                                    
    (make-chains [s]                                                                                                                                    
        (let [links (linked-pairs s)]                                                                                           
            (loop [chains links]                                                                                                                        
                (let [chains' (into chains (for [[a b] links c chains :when (and (= b (first c)) (not (some #{a} c)))] (cons a c)))]
                    (if (= chains chains')                                                                                                              
                        chains'                                                                                                 
                        (recur chains'))))))                                                                                                            
    (longest-chain [s] (last (sort-by count (make-chains s))))                                                                  
    (is-chainable? [s] (= (count s) (count (longest-chain s))))]                                                                                        
        is-chainable?)
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(letfn [(rm-at [idx word-seq]
          (let [[l r] (split-at idx word-seq)]
            (concat l (rest r))))
        (chained-words? [w1 w2]
          (= 1 (count
                (remove
                 false?
                 (if-not (= (count w1) (count w2))
                   (let [[w-l w-h] (sort-by count [(seq w1) (seq w2)])]
                     (map #(= w-l (rm-at % w-h)) (range (count w-h))))
                   (map #(not= %1 %2) w1 w2))))))
        (chain? [word words]
          (let [chain (filter #(chained-words? word %) words)]
            (if (seq chain)
              (some true? (map #(chain? % (disj words %)) chain))
              (empty? words))))]
  (fn [words]
    (true? (some true? (map #(chain? % (disj words %)) words)))))
finsternis's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [words]
  (letfn [(count-neq [w1 w2] (count (filter #(apply not= %) (map list w1 w2))))
          (remove-at [w i] (str (subs w 0 i) (subs w (inc i))))
          (remove-each [w] (map #(remove-at w %) (range (count w))))
          (subst? [w1 w2] (and (= (count w1) (count w2)) (= 1 (count-neq w1 w2))))
          (insert? [w1 w2] (boolean (some #{w1} (remove-each w2))))
          (connected? [w1 w2] (or (subst? w1 w2) (insert? w1 w2) (insert? w2 w1)))
          (connected-to [w] (for [w2 words :when (connected? w w2)] w2))
          (any? [s] (boolean (some true? s)))
          (graph [words] (into {} (set (for [w words] [w (connected-to w)]))))
          (dfs [graph word unv]
            (let [unv' (disj unv word) nbs (filter unv' (graph word))]
              (if (empty? unv') true (any? (for [w nbs] (dfs graph w unv'))))))]
    (any? (for [w words] (dfs (graph words) w words)))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
(fn chain? [s]
  (letfn [(rotate [s]
            (take (count s)
              (iterate #(cons (last %) (butlast %)) s)))
          (permutate [s]
            (if (= 1 (count s))
              [s]
              (reduce
                (fn [r a] 
                  (concat r (map
                              #(cons (first a) %)
                              (permutate (rest a)))))
                []
                (rotate s))))
          (deletion? [a b]
            (let [split (partial map #(if (= %1 %2) %1 nil))]
              (= b
                (clojure.string/join
                  (concat
                    (split a b)
                    (reverse (split (reverse a) (reverse b))))))))
          (legal-pair?  [a b]
            (let [ca (count a) cb (count b)]
              (case (Math/abs (- ca cb))
                0 (= 1 (reduce + (map #(if (not= %1 %2) 1 0) a b)))
                1 (if (> ca cb)
                    (deletion? a b)
                    (deletion? b a))
                false)))
          (legal-chain? [s]
            (every?
              identity
              (map 
                #(legal-pair? %1 %2)
                s
                (rest s))))]
  (not (nil? 
      (some
        legal-chain?
        (permutate (nth (rotate s) 2))))))) ; nth prevents 4clj time out
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [words]
  (letfn [(next? [word-c word-n]
            (case (- (count word-c) (count word-n))
              1 (true? (some #(= (seq word-n) %) (map #(concat (take % word-c) (next (drop % word-c))) (range 0 (count word-c)))))
              -1 (true? (some #(= (seq word-c) %) (map #(concat (take % word-n) (next (drop % word-n))) (range 0 (count word-n)))))
              0 (= 1 (count (filter false? (map #(= %1 %2) word-c word-n))))
              false))
          (chain [word searched-word words]
            (let [nexts (filter #(and (next? word %) (nil? (searched-word %))) words)]
              (if (seq nexts)
                (true? (some true? (map #(chain % (set (cons % searched-word)) words) nexts)))
                (= (count searched-word) (count words)))))]
    (true? (some true? (map #(chain % #{%} words) words)))))
geekerzp's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn [s]
    (letfn [(diff-one-char? [w1 w2]
              (cond
                (= (count w1) (count w2)) (= 1 (count
                                                (filter false?
                                                        (map #(= % %2) w1 w2))))
                :else (let [max-w (max-key count w1 w2)
                            min-w (min-key count w1 w2)]
                        (some #(= (seq min-w) %)
                              (map #(concat (take % max-w) (drop (inc %) max-w))
                                   (range (count max-w)))))))
 
            (chain? [ws]
              (every? true?
                      (map (partial apply diff-one-char?) (partition 2 1 ws))))
 
            (permutations [s]
              (lazy-seq
               (if (seq (rest s))
                 (apply concat (for [x s]
                                 (map #(cons x %) (permutations (remove #{x} s)))))
                 [s])))]
      (boolean (some chain? (permutations s)))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
(fn word-chain [words]
    (let [char-at (fn [w i] (if (< i (count w)) (nth w i) \0))
          stail (fn [w i] (if (< i (count w)) (subs w i) ""))
          differ-by-one
            (fn [w1 w2]
                (loop [i 0]
                    (if (not= (char-at w1 i) (char-at w2 i))
                        (let [tail1 (stail w1 (inc i))
                              tail2 (stail w2 i)]
                            (or (= tail1 tail2)                             ; match after delete from w1
                                (= (str (char-at w2 i) tail1) tail2)        ; match after replace
                                (= (str (char-at w2 i) (stail w1 i)) tail2)  ; match after insert
                            ))
                        (recur (inc i))
                    )))
          followers
            (fn [word]
                [word (set (filter #(differ-by-one word %) (disj words word)))])
          followmap (into {} (map followers words))
          chains
            (fn chains [chain followers unused] (lazy-seq 
                (if (empty? unused)
                    (list chain)
                    (for [word followers
                          :when (unused word)
                          c (chains (conj chain word) (followmap word) (disj unused word))]
                        c
                    ))))
        ]
        (boolean (seq (chains [] words words)))
    ))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
(fn __ [i]
(letfn [(removen [n f l]
 (loop [x l i 0 acc []]
       (if (empty? x) acc
           (let [fel (f (first x))]
        (recur (rest x) (if fel (inc i) i)
               (if (and fel (< i n)) acc (conj acc (first x))))))))
(links [l r]
 (let [la (clojure.string/split l #"")
       ra (clojure.string/split r #"")]
   (if (= (count la) (count ra))
       (loop [f ra s la diff 0]
             (if (empty? f) (= diff 1)
             (recur (rest f) (rest s)
            (if (not= (first f) (first s))
                (inc diff)
                 diff))))
    (loop [f (if (> (count ra) (count la)) ra la)
           s (if (< (count la) (count ra)) la ra)]
           (if (empty? s) (= 1 (count f))
               (recur (removen 1 #(= % (first s)) f)
              (rest s)))))))
(addc [v c]
 (loop [vv v acc c]
  (if (empty? vv) (flatten acc)
   (recur (rest vv)
      (if (empty? acc) (conj acc (first vv))
          (if (= (count acc) 1)
              (if (links (first vv) (first acc))
              (conj acc (first vv)) acc)
          (let [sc (links (first vv) (first acc))
                ec (links (first vv) (last acc))] 
            (if (or sc ec)
                (if sc (into [(first vv)] acc)
                       (conj acc (first vv)))
                   acc))))))))]
 (loop [v (sort-by count (into [] i)) 
        prevanswer [] 
    answer (addc v [])]
   (if (or (empty? v) (= (count prevanswer) (count answer)))
       (= (into #{} answer) i) 
       (let [newv (into [] (clojure.set/difference (into #{} v) (into #{} answer)))]
            (recur newv answer (addc newv answer)))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
; This is probably NP-Complete (hamiltonian path should reduce to it, 
; though the reducer is a little trickier than I first thought).
(fn chain-exists? [words]
    (let [words-close? (fn words-close? [a b]
                           (cond (= (first a) (first b))
                                 (if-not (nil? (first a))
                                         (words-close? (subs a 1) (subs b 1))
                                         true)
                                 (empty? a) (= 1 (count b))
                                 (empty? b) (= 1 (count a))
                                 (not= (first a) (first b))
                                 (or (= (subs a 1) (subs b 1))
                                     (= a (subs b 1))
                                     (= (subs a 1) b))))
                       edges (filter #(apply words-close? %1)
                                     (mapcat #(%1 words)
                                             (map (fn [w]
                                                      (fn [words]
                                                          (->> words
                                                               (filter #(and (not= w %1)
                                                                             (< 0 (compare %1 w))))
                                                               (map vector (repeat w)))))
                                                  words)))
                       f (fn f' [cur-word remaining-words remaining-edges]
                             (if (empty? remaining-words)
                                 true
                               (let [cur-edges (filter (comp not empty?
                                                             (partial filter
                                                                      (partial = cur-word)))
                                                       remaining-edges)]
                                 (if (empty? cur-edges)
                                     false
                                   (some #(let [next-word (first (filter
                                                                  (partial not= cur-word) %1))]
                                            (f' next-word
                                                (filter (partial not= next-word) remaining-words)
                                                (filter (partial not= %1) remaining-edges)))
                                         cur-edges)))))]
      (boolean
       (some #(f %1 (filter (partial not= %1) words) edges)
             words))))
happycrisis's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn [s]
  (let [letters (reduce into #{} s)]
    (letfn [(dels [s] (map #(str (subs s 0 %) (subs s (inc %))) (range (count s))))
            (subts [s] (for [i (range (count s)) c letters]
                         (str (subs s 0 i) c (subs s (inc i)))))
            (insrts [s] (for [i (range (inc (count s))) c letters]
                          (str (subs s 0 i) c (subs s i))))
            (diffs [s] (clojure.set/union (dels s) (subts s) (insrts s)))]
      (let [m (map (fn [x] [x  (set (filter (disj s x) (diffs x)))]) s)
        m (into {} m)]
        (letfn [(dfs [x seen]  
          (if (= (inc (count seen)) (count s))
            true
            (when-let [ss (remove seen (m x))] 
              (some #(dfs % (conj seen x)) ss))))]
          (true?  (some #(dfs % #{}) s)))))))
hisba's solution:

1
2
3
4
5
6
7
8
9
(fn wc? ([ws] (not (nil? (some #(wc? (disj ws %) %) ws))))
  ([ws w]
   (let [wd1? (fn [a b] (let [[fa & ra] a [fb & rb] b]
             (cond (= a b) true
                   (= fa fb) (recur ra rb)
                   :else (or (= ra rb) (= ra (seq b)) (= rb (seq a))))))]
   (if (empty? ws) true
     (some #(wc? (disj ws %) %)
           (filter #(wd1? w %) ws))))))
icamts's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
(fn [ws]
  (let [chains? (fn [w1 w2]
                  (cond 
                    (and (or (empty? w1) (= 1 (count w1))) 
                         (or (empty? w2) (= 1 (count w2)))) true
                    (= (first w1) (first w2)) (recur (next w1) (next w2))
                    (= (last w1) (last w2)) (recur (butlast w1) (butlast w2))
                    :else false))
        mc? (memoize (fn [w1 w2] (if (nil? w1) true (chains? w1 w2))))
        insertions (fn [ps w]
                     (let [ins (fn [[ls rs] w] 
                                 (if (and (mc? (last ls) w) (mc? (first rs) w))
                                   (concat ls (list w) rs)))]
                       (filter identity 
                               (into [] (for [i (range (inc (count ps)))]
                                          (ins (split-at i ps) w))))))
        solutions (fn [ss]
                (if 
                  (or (empty? ss) (some (comp empty? first) ss)) ss  
                  (recur 
                    (set (mapcat (fn [s]
                                   (let [cw (first s)] 
                                     (mapcat (fn [w] 
                                               (let [rw (disj cw w) 
                                                     ps (second s)]
                                                 (map #(list rw %) 
                                                      (insertions ps w)))) 
                                             cw))) 
                                 ss)))))]
    (boolean (seq (solutions (hash-set (list ws '())))))))
immo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [s]    
  (let [pair? (fn [w1 w2]
                    (cond 
                        (nil? w1) true
                        (= (count w1) (count w2)) 
                            (= 1 (count (filter false? (map = w1 w2))))
                        (= 1 (Math/abs (- (count w1) (count w2))))
                            (let [[shorter longer] (sort #(< (count %1) (count %2)) [w1 w2])]
                                (re-matches
                                    (re-pattern (str ".?" (apply str (interpose ".?" shorter)) ".?"))
                                    longer))
                        :else false))                       
         chainable? (fn chainable? [w rem]
                        (if (empty? rem)    
                            true
                            (some
                                (fn [x] (chainable? x (clojure.set/select #(not= x %) rem)))
                                (filter (partial pair? w) rem))))]                              
        (boolean (chainable? nil s))))
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [words]
  (letfn [(drop-char [w pos] (str (subs w 0 pos) (subs w (inc pos))))
          (mods [w] (map #(drop-char w %) (range (count w))))
          (subs? [w1 w2] (= 1 (apply + (map #(if (= %1 %2) 0 1) w1 w2))))
          (adds? [w1 w2] (some #(= % w2) (mods w1)))
          (near? [w1 w2]
            (cond
              (nil? w1) true
              (= (count w1) (count w2)) (subs? w1 w2)
              :else (or (adds? w1 w2) (adds? w2 w1))))
          (chain? [x xs]
            (if (empty? xs)
              true
              (->> xs
                   (filter #(near? x %))
                   (map #(chain? % (disj xs %)))
                   (reduce #(or %1 %2) false))))]
    (chain? nil words)))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
(fn wordchain? [coll]
  (letfn [
    (equal-length-check [w1 w2] 
        (let [w1 (vec w1) w2 (vec w2)]
             (->> (range 0 (count w1))
                  (filter #(= (assoc w2 %1 (get w1 %1)) w1))
                  (count)
                  (< 0)
             )
        )
    )
    (unequal-length-check [w1 w2]
        (let [sorted (sort-by count [w1 w2]) w1 (-> sorted first vec) w2 (-> sorted second vec)]
            (->> (range 0 (count w2))
                 (map #(concat (subvec w2 0 %1) (subvec w2 (inc %1))))
                 (filter #(= % w1))
                 (count)
                 (< 0)
            )
        )
    )
    (connected-words [word coll]
        (filter #(seq %) (for [other coll]
            (let [wcount (count word) ocount (count other) diff (- wcount ocount)]
                (cond (or (= diff 1) (= diff -1)) (if (unequal-length-check word other) other ())
                      (= wcount ocount) (if (equal-length-check word other) other ())
                      :else ()
                )
            )
        ))
    )
    (chain-iter [current left possible]
        (cond (empty? left) true
              (empty? possible) false
              :else (for [p possible] 
                        (let [removed  (remove #{p} left)]
                            (chain-iter p removed (connected-words p removed))
                        )
                    )
        )
    )]
    (loop [remaining (rest coll) current (first coll)]
        (let [left (remove #{current} coll) possible (connected-words current left)]
            (cond (some #{true} (filter #(true? %) (flatten (chain-iter current left possible)))) true
                  (empty? remaining) false
                  :else (recur (rest remaining) (first remaining))
            )
        )
    )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(fn [ws]
  (letfn [(near? [word1 word2]
            (loop [w1 word1
                   w2 word2
                   e? false]
              (cond
                (every? empty? [w1 w2])    word1
                (= w1 w2)                  word1
                (= (first w1) (first w2))  (recur (rest w1) (rest w2) e?)
                (true? e?)                 false
                (= (first w1) (second w2)) (recur (rest w1) (nthrest w2 2) true)
                (= (second w1) (first w2)) (recur (nthrest w1 2) (rest w2) true)
                :else                      (recur (rest w1) (rest w2) true))))
 
          (stitch [item ve valid?]
            (let [v (conj (vec (cons item ve)) item)]
              (first
                (for [i (range (dec (count v)))
                      :when (and (near? (nth v i) item)
                                 (near? (nth v (inc i)) item))]
                  [item
                   (vec (concat (subvec ve 0 i)
                                [item]
                                (subvec ve i)))]))))
 
          (match? [seen ws]
            (if-let [[w seen] (some #(stitch % seen near?) ws)]
              [seen (disj ws w)]))]
 
    (loop [seen [(first ws)]
           ws (disj ws (first ws))]
      (if (empty? ws)
        true
        (if-let [[seen ws] (match? seen ws)]
          (recur seen ws)
          false)))))
johncowie's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [v]
  (let [one-off? (fn [s t]
          (if (= (count s) (count t))
              (= 1 (count (clojure.set/difference (set s) (set t))))
             (let [r (sort-by count [s t])]
               (reduce #(or %1 %2)
                  (map #(= (first r) %)
                   (for [i (range 0 (count (second r)))]
                     (apply str (concat (take i (second r)) (drop (inc i) (second r))))))))))
        f (fn f [s v]
              (if (empty? v)
                true
                (for [x (filter #(one-off? s %) v)]
                  (f x (remove #{x} v)))))]
    (not (empty?  (flatten  (for [x v] (f x (remove #{x} v))))))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
(fn word-chain? [words]
  (letfn [(adjacent?
            ([a b] (adjacent? a b 0))
            ([a b dist]
             (cond (> dist 1) false
                   (and (nil? a) (nil? b)) true
                   
                   (= (first a) (first b))
                   (adjacent? (next a) (next b) dist)
                   
                   :else
                   (or (adjacent? (next a) (next b) (inc dist))
                       (adjacent? a (next b) (inc dist))
                       (adjacent? (next a) b (inc dist))))))
          
          (connected? 
            [mat node]
            (letfn [(walk 
                      [node visits]
                      (let [tgts      (mat node)
                            visits    (conj visits node)
                            unvisited (clojure.set/difference tgts visits)]
                        (if (== (count words) (count visits)) true
                          (some true? (map #(walk % visits) unvisited)))))]
            (walk node #{})))
          
          (adjacency-mat 
            [words]
            (reduce (fn [ret [a b]]
                      (-> (update-in ret [a] conj b)
                          (update-in [b] conj a)))
                    (into {} (map #(vector % #{}) words))
                    (for [i (range (count words))
                          j (range (inc i) (count words))
                          :let [a (words i)
                                b (words j)]
                          :when (adjacent? a b)]
                      [a b])))]
    (let [words-vec (vec words)
          mat (adjacency-mat words-vec)]
      (boolean (some (partial connected? mat) words)))))
jorendorff's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [words]
    (letfn [(any? [s]
              (not (not-any? identity s)))
            (grow? [a b]
              (not (not-any? #(= a (str (subs b 0 %) (subs b (inc %)))) (range (count b)))))
            (step? [a b] (case (- (count a) (count b))
                           0 (= 1 (apply + (map #(if (= %1 %2) 0 1) a b)))
                           -1 (grow? a b)
                           1 (grow? b a)
                           false))
            (chain? [w r]
              (or (empty? r)
                  (any? (for [x r]
                          (and (step? w x)
                               (chain? x (disj r x)))))))]
      (any? (for [w words]
              (chain? w (disj words w))))))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn word-chain? [words]
  (letfn [(levenshtein-distance [s t]
                                (cond (= 0 (count s)) (count t)
                                      (= 0 (count t)) (count s)
                                      :otherwise
                                      (let [cost (if (= (last s) (last t)) 0 1)]
                                        (min (+ 1 (levenshtein-distance (drop-last s) t))
                                             (+ 1 (levenshtein-distance s (drop-last t)))
                                             (+ cost (levenshtein-distance (drop-last s) (drop-last t)))))))
          (walk-nodes [node grouped-distances path]
                      (let [children (get grouped-distances node)
                            new-path (into #{} (conj path node))
                            filtered-children (filter #(not (contains? new-path (second %))) children)]
                        (if (empty? filtered-children)
                          new-path
                          (let [child-paths (for [c filtered-children]
                                              (walk-nodes (second c) grouped-distances new-path))
                                max-path (reduce (fn [acc v] (if (> (count v) (count acc)) v acc)) #{} child-paths)]
                            max-path
                            ))))]
    (let [distances (remove nil? (for [row words col words]
                                   (if (= 1 (levenshtein-distance row col)) [row col])))
          grouped-distances (group-by #(first %) distances)
          max-counts (apply max (map (fn [v] (count (walk-nodes v grouped-distances #{}))) words))]
      (= max-counts (count words))
      )
    )
  )
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [words]
  (letfn [
    (remove-one [t]
      (map 
        #((fn [[f t]] (apply str (concat f (next t)))) (split-at % t))
        (range (count t))))
    (neib [s d]
      (let [rs (remove-one s)
            rd (remove-one d)]
        (or (some #(= s %) rd)
            (some #(= d %) rs)
            (some identity (map #(= % %2) rd rs)))))
    (paths [[prev :as path] rests]
      (if (empty? rests)
          [path]
          (apply concat
            (keep
              #(if (or (nil? prev) (neib prev %))
                   (paths (cons % path) (disj rests %)))
              rests))))]
  (boolean (some #(= % words) (map set (paths () words))))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn [s]
  (letfn [(chain? [x y]
            (let [s1  (vec x)
                  s2  (vec y)
                  cc (Math/abs (- (count s1) (count s2)))]
              (cond (= 0 cc) (= 1 (reduce + (map #(if (= %1 %2) 0 1) s1 s2)))
                    (= 1 cc) (->> (map #(vector (if (= %1 %2) 0 1) (if (= %2 %3) 0 1))
                                       (conj s1 0) (assoc s1 0 0) s2)
                               (reduce (fn [[a b] [c d]] [(+ a c) (+ b d)]) )
                               ((fn [[a b]] (or (= 1 a) (= 1 b)))))
                    :else false)))]
    (loop [i (count s) a (map vector s)]
      (if (= 1 i) (-> a empty? not)
          (recur (dec i)
                 (for [ax a
                       sx s
                       :let [cn (conj ax sx)]
                       :when (and (not (contains? (set ax) sx))
                                  (first (reduce (fn [[b l] x]
                                                   [(and b (chain? l x)) x])
                                                 [true (first cn)] (rest cn))))]
                   cn))))))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
(fn prob82
  ;; build all the permutations of the set or words xs
  ;; levenshetien returns the number edits diff between two strings
  ;; map diff-by-one-letter over all the combinations
  ;; find if there is one set that is all true
  [xs]
  (letfn [(permutations [xs]
            (if (empty? xs)
              '()
              (if (= 1 (count xs))
                (list (seq xs))
                (for [x xs
                      y (permutations (disj xs x))]
                  (cons x y)))))
          (all-true [xs]  ;; return true xs contains all true
            (every? true? xs))
          (levenshtein [str1 str2]  ;; http://rosettacode.org/wiki/Levenshtein_distance#Clojure
            (let [len1 (count str1)
                  len2 (count str2)]
              (cond (zero? len1) len2
                    (zero? len2) len1
                    :else
                    (let [cost (if (= (first str1) (first str2)) 0 1)]
                      (min (inc (levenshtein (rest str1) str2))
                           (inc (levenshtein str1 (rest str2)))
                           (+ cost
                              (levenshtein (rest str1) (rest str2))))))))
          (one-letter-diff [a b]     ;; same string or one letter difference
            (< (levenshtein a b) 2))
          ]
    (let [s (permutations xs)]
      (if (some true? (map all-true (map #(map one-letter-diff % (rest %)) s)))
        true
        false))))
brendan's solution:

1
2
3
4
5
6
7
8
; Evil hack
(fn [& _]
  (reify nil
    clojure.lang.IPersistentCollection
    (seq [_])
    (cons [_ _])
    (empty [_])
    (equiv [_ _] true)))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn myWordChains
  [chain]
  (let [diff (fn dist [seq1 seq2] 
               (cond
                 (empty? seq1) (count seq2)
                 (empty? seq2) (count seq1)
                 :else (let [cost (if (= (first seq1) (first seq2)) 0 1)]
                         (min
                           (inc (dist (rest seq1) seq2))
                           (inc (dist seq1 (rest seq2)))
                           (+ (dist (rest seq1) (rest seq2)) cost)))))
        diffByOne? (fn [seq1 seq2] (= 1 (diff seq1 seq2)))
        getAllDistByOne (fn [x coll] (rest (reduce #(if (diffByOne? %2 (first %1)) (conj %1 %2) %1) x coll)))]
    (loop [paths (map (fn [x] (list (vector x) (set (remove #(= x %) chain)))) chain) iter 0]
      (if (= iter (- (count chain) 1))
        (not (empty? paths)) 
        (recur (mapcat (fn [x] (map #(list (conj (first x) %) (set (remove (fn [rem] (= rem %)) (second x)))) 
                          (getAllDistByOne (vector (last (first x))) (second x)))) paths) (inc iter))))))
lackita's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [words]
  (letfn [(adjacent? [w1 w2]
            (if (= (first w1) (first w2))
              (adjacent? (rest w1) (rest w2))
              (or (= (apply str w1) (apply str (rest w2)))
                  (= (apply str w2) (apply str (rest w1)))
                  (= (rest w1) (rest w2)))))
          (chain? [c ws]
            (if (= (count ws) 1)
              (adjacent? c (first ws))
              (some (fn [w] (chain? w (disj ws w)))
                    (filter #(adjacent? c %) ws))))]
    (not (nil? (some #(chain? % (disj words %))
                     words)))))
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [words]
  (letfn [(remove-first [x coll]
            (let [[pre post] (split-with #(not= x %) coll)]
              (concat pre (rest post))))
          (permutations [xs]
            (if (empty? xs)
              '([])
              (for [x xs
                    :let [perms (permutations (remove-first x xs))]
                    perm perms]
                (cons x perm))))
          (head-match-count [xs ys] (count (take-while identity (map = xs ys))))
          (differ-one-letter? [s1 s2]
            (let [n (head-match-count s1 s2)]
              (case (- (count s2) (count s1))
                0 (= 1 (count (remove identity (map = s1 s2))))
                1 (= (count s1)
                     (+ n (head-match-count (drop n s1) (drop (inc n) s2))))
                -1 (= (count s2)
                      (+ n (head-match-count (drop (inc n) s1) (drop n s2))))
                false)))]
    (->> (permutations words)
         (some #(->> (partition 2 1 %)
                     (every? (partial apply differ-one-letter?))))
         boolean)))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
(fn [w]
(letfn
   [(insert-or-delete? [a b]
  (cond
   (or (= (count a) (inc (count b))) (= (count b) (inc (count a))))
     (loop [inserted false
            a* a
            b* b]
       (cond
        (and (empty? a*) (empty? b*)) true
        (= (first a*) (first b*)) (recur inserted (rest a*) (rest b*))
        (and (not inserted) (= (first a*) (second b*))) (recur true (rest a*) (drop 2 b*))
        (and (not inserted) (= (second a*) (first b*))) (recur true (drop 2 a*) (rest b*))
        :else false
        )
       )
   :else false
   ))
    (subst? [a b]
  (if (= (count a) (count b))
    (loop [changed false
           a* a
           b* b]
      (cond
       (and (empty? a*) (empty? b*)) true
       (= (first a*) (first b*)) (recur changed (rest a*) (rest b*))
       (not changed) (recur true (rest a*) (rest b*))
       :else false)
      )
    false
    )
  )
    (chain? [a b]
  (or (subst? a b) (insert-or-delete? a b))
  )
    (next-word [chain words]
  (if (empty? words)
    true
    (reduce
     #(or
       %1
       (if (chain? (first chain) %2)
         (next-word (cons %2 chain) (disj words %2))
         false
        )
       (if (chain? (last chain) %2)
         (next-word (conj chain %2) (disj words %2))
         false
        )
       )
     false
     words
     )
    )
  )
    ]
  (let [word (first w)]
    (next-word (list word) (disj w word))
    )
   )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(letfn
  [(adjacent? [word1 word2]
     (let [r1 (take-while (partial apply =) (map vector word1 word2))
           r2 (take-while (partial apply =)
                          (apply map vector
                                 (map (comp reverse (partial drop (count r1)))
                                      [word1 word2])))]
       (or (apply = (map count [r1 r2 word1 word2]))
           (every? #(>= 1 (Math/abs (- (count %) (+ (count r1) (count r2)))))
                   [word1 word2]))))
   ;; dfs
   (path [words cur-word]
     (if (empty? words)
       '()
       (some identity
             (for [word words
                   :when (adjacent? word cur-word)]
               (when-let [dfs (path (disj words word) word)]
                 (cons word dfs))))))
   (soln [words]
     (boolean
       (some identity
             (for [word words]
               (path (disj words word) word)))))]
  soln)
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
(fn [words]
  (letfn [
          (has-hamilton-way? [pairs]
                        (>= 2 (count (filter #(= 1 (second %)) (frequencies (reduce into [] pairs))))))
          (lev-dist [w1 w2]
                    (cond
                      (= w1 w2) 0
                      (empty? w1) (count w2)
                      (empty? w2) (count w1)
                      :else
                      (letfn [(get-reduce-fn [[ltr _]]
                                             (fn [[l v] [[l0 v0] [l1 v1]]]
                                               (list l1
                                                     (min (inc v1) (inc v)
                                                          (+ v0 (if (= ltr l1) 0 1))))))
                              (next-row [row first-item]
                                        (partition 2 1
                                                   (reductions
                                                     (get-reduce-fn first-item)
                                                     first-item
                                                     row)))
                              (make-row [w] (map list w (iterate inc 1)))
                              (make-first-row [w] (cons '(nil 0) (make-row w)))]
                        (->> (make-first-row w2)
                             (reduce 
                               next-row
                               (partition 2 1 (make-first-row w1)))
                             ((comp last last last))))))
          (make-pairs [s]
                      (if (empty? s) nil
                        (loop [res [] [f & more] s]
                          (if (empty? more) res
                            (recur
                              (reduce 
                                #(if (= 1 (lev-dist f %2)) (conj % [f %2]) %)
                                res 
                                more)
                              more)))))
          (is-word-chain? [words]
                          (let [v-words (vec words) pairs (make-pairs v-words)]
                            (and
                              (= (count (reduce into #{} pairs)) (count v-words))
                              (has-hamilton-way? pairs))))]
    (is-word-chain? words)))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn [s] (not (empty? (filter
  #(let [dst (fn levdist [s t]
          (if (empty? s) (count t)
            (if (empty? t) (count s)
            (min 
              (+ 1 (levdist (subs s 1) t))
              (+ 1 (levdist s (subs t 1)))
              (+ (if (= (first s) (first t)) 0 1)
                 (levdist (subs s 1) (subs t 1)))))))]
      (not (nil? (reduce 
                    (fn [i1 i2] 
                      (if (nil? i1) 
                        nil
                        (if (= 1 (dst i1 i2))
                          i2
                          nil)))
                    %1))))
  ((fn perm [l]
    (if (= 1 (count l))
      [l]
      (mapcat 
        #(map
          (partial cons %1)
          (perm (remove #{%1} l)))
        l)))
s)))))
malvert's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(letfn [(d [[f & r :as a] [g & s :as b]]
          (if (= f g) 
            (d r s)
            (or (= r s) (= r b) (= a s))))
        (p [s]
          (if (empty? s)
            [[]]
            (mapcat
              (fn [i]
                (map
                  #(cons i %)
                  (p (disj s i))))
              s)))]
  #(true?
    (some
      (fn [t]
        (every?
          (fn [[a b]] (d (seq a) (seq b)))
          (partition 2 1 t)))
      (p %))))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
; oh my
 
(fn [s]
  (let [any-true? (partial (complement not-any?) true?)
        every-as-first
        (fn [xs]
          (map #(cons % (remove (partial = %) xs)) xs))]
    (letfn [(has-chain? [[word & ws]]
              (if (nil? ws)
                true
                (let [edit-dist-one?
                      (comp (partial = 1)
                            (partial levenshtein word))
                      links (filter edit-dist-one? ws)]
                  (if (empty? links)
                    false
                    (any-true? (map #(has-chain? (cons % (remove (partial = %) ws))) links))))))
            ; https://rosettacode.org/wiki/Levenshtein_distance#Clojure
            (levenshtein [str1 str2]
              (let [len1 (count str1)
                    len2 (count str2)]
                (cond (zero? len1) len2
                      (zero? len2) len1
                      :else
                      (let [cost (if (= (first str1) (first str2)) 0 1)]
                        (min (inc (levenshtein (rest str1) str2))
                             (inc (levenshtein str1 (rest str2)))
                             (+ cost
                                (levenshtein (rest str1) (rest str2))))))))]
    (any-true? (map has-chain? (every-as-first (seq s)))))))
maximental's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn [f c]
  ((fn h [w] 
     (let [r (reduce  
               #(if (f (last %) %2)  
                 `[~@% ~%2]  
                 (if (f (first %) %2) 
                   `[~%2 ~@%] 
                   %)) 
               w 
               (remove (set w) c))]
         (if (= r w) (= (set r) c) (h r)))) 
   [(first c)]))
 
(fn [s t] 
  (let [g (fn [x y]  
            (some 
              #(= (seq x) `(~@(take % y) ~@(drop (+ % 1) y))) 
              (range (count y))))]
    (condp = (- (count s) (count t)) 
       0 (= 1 (apply + (map #(if (= % %2) 0 1) s t)))
       1 (g t s)
      -1 (g s t)
         false)))
mbakhterev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [W]
  (let [nxt (fn [x y]
              (loop [[a & A :as u] (seq x) [b & B :as v] (seq y)] 
                (cond (= a b) (recur A B)
                      (or (= u B)
                          (= v A)
                          (= A B)) true
                      :else false)))
        R (fn [w S] (filter (partial nxt w) S))
        F (fn F [w S]
            (if (empty? S) true (boolean (some (fn [i] (F i (disj S i))) (R w S)))))]
    (boolean (some (fn [w] (F w (disj W w))) W))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
(fn chainable? [words]
 
  ;; We begin by defining some useful functions.
  (let [
        ;; This is a predicate that detects whether its arguments are related by
        ;; an insertion or deletion (which are really the same thing: A is
        ;; obtained from B by an insertion iff B is obtained from A by a
        ;; deletion). It works on arbitrary sequences, not just strings.
        insertion?
        (fn [a b]
          (cond
            (string? a)                       (recur (seq a) b)
            (string? b)                       (recur a (seq b))
            (> (count b) (count a))           (recur b a)
            (not= (count a) (inc (count b)))  false
            (empty? b)                        true
            (= (first a) (first b))           (recur (rest a) (rest b))
            :else                             (= (rest a) b))),
 
        ;; This is a predicate that detects whether its arguments differ by a
        ;; substitution. Again, this works on arbitrary sequences.
        substitution?
        (fn [a b]
          (cond
            (string? a)                       (recur (seq a) b)
            (string? b)                       (recur a (seq b))
            (not= (count a) (count b))        false
            (empty? a)                        false
            (= (first a) (first b))           (recur (rest a) (rest b))
            :else                             (= (rest a) (rest b)))),
 
        ;; This is a predicate that detects whether a sequence represents a
        ;; chain of insertions, deletions, and substitutions.
        chain?
        (fn [coll]
          (if (seq coll)
 
            ;; This next form doesn't work on the 4clojure site, because reduced
            ;; is too new.
            #_(reduce (fn [x y]
                        (if (or (insertion? x y)
                                (substitution? x y))
                          y
                          (reduced false)))
                      coll)
 
            ;; Here's the replacement form.
            (not= :fail (reduce (fn [x y]
                                  (cond
                                    (= x :fail)               :fail
                                    (or (insertion? x y)
                                        (substitution? x y))  y
                                        :else                     :fail))
                                coll))
 
            ;; Picking up where we left off (this is the "empty" case):
            true)),
 
        ;; This is a function which takes a set and returns the set of all
        ;; permutations of that set.
        permutations
        (fn permutations [a]
          (if (= 1 (count a))
            #{(seq a)}
            (->> (for [x a]
                   (map (partial cons x)
                        (permutations (disj a x))))
                 (apply concat)
                 set)))]
 
    (if (seq words)
      (if (some chain? (permutations words)) true false)
      true)))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn chain-exists? [coll]
  (letfn [(chainable? [w1 w2]
                      (if (= (.length w1) (.length w2))
                        (= 1 (apply + (map (fn [c1 c2]
                                             (if (= c1 c2)
                                               0
                                               1))
                                           w1 w2)))
                        (if (< (.length w1) (.length w2))
                          (some #(= (seq w1) (concat (take % w2) (drop (inc %) w2)))
                                (range (.length w2)))
                          (some #(= (seq w2) (concat (take % w1) (drop (inc %) w1)))
                                (range (.length w1))))))
 
          (chains-through? [w0 coll]
                           (if (empty? coll)
                             true
                             (some (fn [w]
                                     (and (chainable? w0 w)
                                          (chains-through? w (disj coll w))))
                                   coll)))]
    (boolean (some (fn [w]
                     (chains-through? w (disj coll w)))
                   coll))))
minitrue's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn [ws]
  (let [wv (vec ws)
        n (count wv)
        connected
          (fn [a b]
            (letfn [(ed=1 [a b]
                (cond
                  (nil? a) (= 1 (count b))
                  (nil? b) (= 1 (count a))
                  :else (let [[a0 & a_] a, [b0 & b_] b]
                          (if (= a0 b0) (ed=1 a_ b_)
                            (or (= a_ b_)
                                (= a  b_)
                                (= a_ b ))))))]
            (ed=1 (seq a) (seq b))))
        degrees
          (->>
            (for [i (range n) j (range (inc i) n)
                    :when (connected (wv i) (wv j))] [i j])
            (apply concat)
            frequencies
            vals
            frequencies)]
    (and (nil? (degrees 0)) (< (degrees 1 0) 3))))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn chainclosure [s]
  (let [wordpair (fn [s t]
          (or (and (== (count s) (count t))
                   (== 1 (apply + (for [x (range (count s))
                                        :when (not= (get (vec s) x) (get (vec t) x))]
                                    1))))
              (and (== (count s) (inc (count t)))
                   (reduce #(or %1 %2) (for [x (range (count s))]
                                        (= (str (subs s 0 x) (subs s (inc x) (count s))) t))))
              (and (== (count t) (inc (count s)))
                   (reduce #(or %1 %2) (for [x (range (count t))]
                                         (= (str (subs t 0 x) (subs t (inc x) (count t))) s))))))]
(if (<= (count s) 1)
          true
          (loop [storage #{} result (for [x s
                                          y s
                                          :when (wordpair x y)]
                                      (vector x y))]
            (if (nil? (some #{(count s)} (map count result)))
              (if (= storage result)
                false
                (recur result (set (into result (for [x result
                                                      y result
                                                      :when (and (= (peek x) (first y)) (nil? (some #{(second y)} x)))]
                                                  (into x (rest y)))))))
              true)))))
mobiusloop's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [s]
  (let [lv (memoize (fn [lv s t c] (cond
                                      (> c 1) false
                                      (empty? s) (= 1 (+ c (count t)))
                                      (empty? t) (= 1 (+ c (count s)))
                                      :otherwise (let [cost (if (= (first s) (first t)) 0 1)]
                                                   (or (lv lv (rest s) t (inc c))
                                                       (lv lv s (rest t) (inc c))
                                                       (lv lv (rest s) (rest t) (+ c cost))))
                                      )))
        test (fn [search l1 l2] (not (empty? (drop-while #(not (search % (disj l1 %))) l2))))
        search (fn search [w s] (if (empty? s) true (test search s (filter #(lv lv w % 0) s)) ))
        ]
    (test search s s)))
mononite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [words]
  (letfn [(add-elem 
           [l e]
           (reduce (fn [s i] (let [[p1 p2] (split-at i l)] (conj s (concat p1 (list e) p2)))) #{} (range (inc (count l)))))
          (permute 
           [s] 
           (let [h (first s) t (rest s)] (if (empty? t) #{(list h)} (reduce (fn [cs l] (into cs (add-elem l h))) #{} (permute t)))))
          (by-substitution? 
           [w1 w2] 
           (let [l1 (count w1) l2 (count w2)] (if (= l1 l2) (= (reduce + (map (fn [c1 c2] (if (= c1 c2) 0 1)) w1 w2)) 1) false)))
          (by-insertion-deletion? 
           [w1 w2] 
           (let [l1 (count w1) l2 (count w2)] (cond (= (- l1 l2) 1) ((set (map (fn [i] (concat (take i w1) (take-last (- l2 i) w1))) (range l1))) (seq w2)) (= (- l2 l1) 1) (recur w2 w1) :else false)))
          (chain? 
           [chain] 
           (let [pairs (partition 2 1 chain)] (every? (fn [[w1 w2]] (or (by-substitution? w1 w2) (by-insertion-deletion? w1 w2))) pairs)))]
    (not (= (some chain? (permute words)) nil))))
mouse's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn wc
      ([ws] (let [a (first ws) b (list a)]
              (boolean (some (fn [[f l ws]] (empty? ws))
                             (mapcat (fn [[f l ws]] (wc l f ws)) (wc b b (disj ws a)))))))
      ([f [l1 :as l] ws]
          (let [r (fn r [[x & xt] [y & yt]] (if (and xt (= x y)) (r xt yt) (= xt yt)))
                s (fn s [[x & xt] [y & yt :as ys]] (if (= x y) (s xt yt) (= xt (seq ys))))
                m (fn [xs ys]
                    (case (compare (count xs) (count ys))
                      0 (if (not= xs ys) (r xs ys))
                      1 (s xs ys)
                      -1 (s ys xs)))
                n (filter #(m % l1) ws)
                ]
            (lazy-cat (mapcat #(wc f (cons % l) (disj ws %)) n) [[f l ws]])
            )))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
(fn [words]
  (letfn [(levenshtein-dist [s1 s2]
            (let [l1 (count s1)
                  l2 (count s2)]
              (cond (zero? l1) l2
                    (zero? l2) l1
                    :else (let [cost (if (= (first s1) (first s2)) 0 1)]
                            (min (inc (levenshtein-dist (rest s1) s2))
                                 (inc (levenshtein-dist s1 (rest s2)))
                                 (+ cost (levenshtein-dist (rest s1) (rest s2))))))))
          (distance-1-relation [words]
            (set (for [s1 words
                       s2 words
                       :when (and (not= s1 s2)
                                  (= 1 (levenshtein-dist s1 s2)))]
                   #{s1 s2})))
          (graph [relation]
            (->> relation
                 (mapcat (fn [v]
                           (let [f (first v)
                                 s (second v)]
                             [{f #{s}} {s #{f}}])))
                 (apply merge-with clojure.set/union)))
          (hamiltonian-path [graph path]
            (let [seen               (set path)
                  connected-not-seen (filter #(not (seen %))
                                             (get graph (peek path)))]
              (if (empty? connected-not-seen)
                (when (= (count path)
                         (count graph))
                  path)
                (some identity (map #(hamiltonian-path graph (conj path %))
                                    connected-not-seen)))))
          (has-hamiltonian-path? [graph]
            (not (nil? (some identity (map #(hamiltonian-path graph [%])
                                           (keys graph))))))]
    (-> words
        distance-1-relation
        graph
        has-hamiltonian-path?)))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
;; TODO: You had too much code. Understand the more concise solutions.
(fn [words]
  (letfn [(permutations [colls] ;; TODO: Found on the web; how does this work?
            (if (= 1 (count colls))
              (list colls)
              (for [head colls
                    tail (permutations (disj (set colls) head))]
                (cons head tail))))
 
          (chain?[words]
            (every? identity
                    (map chainable?
                         (map vector words (rest words)))))
 
          (chainable?[[a b]]
            (check (sort #(compare (count %1) (count %2)) (list (seq a)(seq b)))))
 
          (check[[shortest longest]]
            (cond
              (= (count shortest) (count longest)) (substitution? shortest longest)
              (= 1 (- (count longest) (count shortest))) (insertion-or-deletion? shortest longest)
              :else false))
 
          (substitution? [a b]
            (loop [as a bs b subs-detected 0]
              (let [[fa & ra] as
                    [fb & rb] bs]
                (if (empty? as)
                  (= 1 subs-detected)
                  (if (not= fa fb)
                    (recur ra rb (inc subs-detected))
                    (recur ra rb subs-detected))))))
 
          (insertion-or-deletion? [shortest longest]
            (loop [as shortest bs longest diffs-detected 0]
              (let [[fa & ra] as
                    [fb & rb] bs]
                (if (empty? bs)
                  (= 1 diffs-detected)
                  (if (not= fa fb)
                    (recur as rb (inc diffs-detected))
                    (recur ra rb diffs-detected))))))]
    (let [perms (permutations words)]
      (not (not
            (some chain? perms))))))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn has-chain? [s]
        (letfn [(drop-nth [n s] (concat (take n s) (drop (inc n) s)))
                (hlp [v s] (map #(cons v %) s))
                (permutations [s]
                              (if (empty? s)
                                  [[]]
                                  (->> (range (count s))
                                       (map #(hlp (nth s %) (permutations (drop-nth % s))))
                                       (apply concat))))
                (close-delete [a b]
                              (if (= (first a) (first b))
                                  (close-delete (rest a) (rest b))
                                  (or (= (rest a) b)
                                      (= (rest b) a))))
                (close? [[a b]] (if (= (count a) (count b))
                                    (= 1 (count (remove true? (map = a b))))
                                    (close-delete (seq a) (seq b))))
                (chain? [s] (every? true? (map close? (partition 2 1 s))))]
                (not (every? false? (map chain? (permutations (vec s)))))))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [words]
    (let [diff (fn [a b] (reduce + 0 (map #(if (= %1 %2) 0 1) a b)))
          caninsert (fn [a b] (cond ; (count a) + 1 == (count b)
                                (empty? a) true
                                (= (first a) (first b)) (recur (rest a) (rest b))
                                :else (= 0 (diff a (rest b)))))
          ch (fn chain [pos words]
               (do (println pos words)
       (if (empty? words)
           true
           (reduce 
             (fn [acc to] (or acc (chain to (disj words to))))
             false
             (filter (fn [w] (let [wl (count w) pl (count pos)] 
                               (cond 
                                 (= wl pl) (= 1 (diff w pos)) 
                                 (= (inc wl) pl) (caninsert w pos) 
                                 (= (inc pl) wl) (caninsert pos w) 
                                 :else false))) words))
           )))]
      (reduce #(or %1 (ch %2 (disj words 2%))) false words)))
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
(fn [words]
  (let [lev (fn [str1 str2]
              (let [isize (inc (count str1))
                    jsize (inc (count str2))
                    all-pairs (for [i (range isize) j (range jsize)] [i j])
                    reducer (fn [distances [i j]]
                              (assoc-in distances [i j]
                                        (cond
                                         (= i 0) j
                                         (= j 0) i
                                       
                                         (= (nth str1 (dec i)) (nth str2 (dec j)))
                                         (get-in distances [(dec i) (dec j)])
                                         
                                         :else
                                         (+ 1 (min (get-in distances [(dec i) j])
                                                   (get-in distances [i (dec j)])
                                                   (get-in distances [(dec i) (dec j)]))))))
                    
                    zero-array (fn [m n]  (vec (take m (repeat (vec (take n (repeat 0)))))))
                    init-state (zero-array isize jsize) 
                    
                    levs (reduce reducer init-state all-pairs)
                    val (last (last levs))]
                val))
 
        connected-words (fn [w] (filter #(= 1 (lev w %)) words))
        
        connections (zipmap words (map connected-words words))
 
        check-path 
        (fn check-path [from seen]
          (cond
           (= (count seen) (count connections))
           true
 
           (seq from)
           (some (fn [n]
                   (and (not (contains? seen n))
                        (check-path (connections n) (conj seen n))))
                 from)
           
           :else
           false))]
 
   (true? (check-path words #{}))))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [words]
  (let [some? (comp not nil?)
        lev (fn lev [a b]
              (if (empty? a)
                (count b)
                (if (empty? b)
                  (count a)
                  (let [cost (if (= (first a) (first b)) 0 1)]
                    (min
                      (inc (lev (rest a) b))
                      (inc (lev a (rest b)))
                      (+ cost (lev (rest a) (rest b))))))))
        connections (->> (for [w words other words :when (= 1 (lev w other))]
                           [w other])
                         (group-by first)
                         (map (fn [[k v]] [k (map second v)]))
                         (into {}))
        has-path? (fn has-path? [curr visited]
                    (let [conns (->> (connections curr)
                                     (remove visited))
                          visited (conj visited curr)]
                      (if (seq conns)
                        (some? (some identity (for [next conns] (has-path? next visited))))
                        (= visited words))))]
    (some? (some true? (map #(has-path? % #{}) words)))))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn myf [coll]
  (letfn [(link? [s1 s2]
            (if (= s1 s2) false
              (let [[small big] (sort-by count [s1 s2])]
                (loop [s (vec small), b (vec big)]
                  (if (= (first s) (first b)) (recur (rest s) (rest b))
                    (cond (= s (rest b)) true
                          (= (rest s) (rest b)) true
                          :else false))))))]
  (loop [res [(first coll)], s (set (rest coll))]
    (let [new-res (reduce #(cond (link? (first %1) %2) (vec (cons %2 %1))
                                 (link? (last %1) %2) (conj %1 %2)
                                 :else %1) 
                          res
                          s)
          new-s (clojure.set/difference s (set new-res))]
      (cond (empty? new-s) true
            (= new-res res) false
            :else (recur new-res new-s))))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(fn [words]
  (let [deletion
        (fn [s]
          (->> (map concat
                 (map #(take % s) (range (count s)))
                 (map #(drop % s) (iterate inc 1)))
            (map #(apply str %))
            set))
        deletions (->> words (map deletion) (zipmap words))
        editable?
        (fn [s]
          (fn [t]
            (case (- (count s) (count t))
              -1 ((deletion t) s)
              1  ((deletion s) t)
              0  (->> (map = s t) (filter false?) count (= 1))
              nil)))
        editions
        (->> words
          (map (fn [word]
                 (->> (disj words word)
                   (filter (editable? word))
                   set)))
          (zipmap words))
        permutations
        ((fn permutation [s]
           (case (count s)
             0 []
             1 [[(first s)]]
             (mapcat #(map cons (repeat %) (permutation (disj s %))) s)))
         words)]
    (->> permutations
      (map #(partition 2 1 %))
      (map #(map (fn [[s t]] ((editions s #{}) t)) %))
      (remove #(some nil? %))
      empty? not)))
ozan's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn chain [words]
  (let [connected? (fn connected? [[a & rest-a] [b & rest-b]]
                     (if (= a b) (connected? rest-a rest-b)
                       (or (= rest-a (cons b rest-b)) ; addition
                           (= rest-a rest-b) ; substitution
                           (= (cons a rest-a) rest-b)))) ; subtraction
        connections-of (fn [word] (filter #(and (not= word %) (connected? word %)) words))
        adjacencies (into {} (map #(vector % (connections-of %)) words))
        chain? (fn chain? [visited word]
                 (if (= (count words) (inc (count visited))) true
                   (some (partial chain? (conj visited word))
                         (clojure.set/difference (into #{} (get adjacencies word)) visited))))]
    (boolean (some (partial chain? #{}) words))))
pukeface's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [S]
    (let [c (fn c [a b]
                (let [a (seq a) b (seq b)
                      [r & t] a
                      [s & u] b]
                    (or 
                      (= a b)
                      (and (= r s) (c t u))
                      (= a u) (= b t) (= t u))))
          ? (fn ? [s V]
                (or (empty? V)
                    (some true? 
                          (map (fn [x]
                             (if (c s x) (? x (disj V x))))
                           V))))
           ]
    (not-every? nil? (map #(? % S) S))))
quant1's solution:

1
2
3
4
5
(letfn 
  [(conn [ss vs f] (for [s ss v (remove (set s) vs) :when (f (last s) v)] (conj s v)))
   (h= [a] (count (take-while true? (apply (partial map =) a))))
   (wc? [& a] (= (apply max (map count a)) (+ 1 (h= a) (h= (map reverse a)))))]
  (fn [ss] (->> (iterate #(conn % ss wc?) (map vector ss)) (take (count ss)) last empty? not)))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
(fn [word-set]
    (let
      [
       chain?
       (fn [[ha & ta :as a] [hb & tb :as b]]
         (cond
             (= a b) false
             (= ha hb) (recur ta tb)
             :else
               (case (- (count a) (count b))
                  -1 (= (seq a) tb)
                   1 (= ta (seq b))
                   0 (= ta tb)
                   false
       ) )     )
       
       node?
       (fn [[[word & _] word-set]]
         (or (nil? word) (some #(chain? word %) word-set))
         )
       
       children
       (fn [[[word & _ :as chain] word-set]]
         (map
            #(list (conj chain %) (disj word-set %))
            (if word
               (filter #(chain? word %) word-set)
               word-set
        ) ) )
       
       ]
      (->>
        ['() word-set]
        (tree-seq node? children)
        (filter #(-> % second empty?))
        first
        nil?
        not
  ) ) )
sbondaryev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
(letfn
    [
     (cmp [s1 s2]
       (let [d (- (count s1) (count s2))]
         (cond
           (= d 0) (= 1 (count (remove identity (map #(= %1 %2) s1 s2))))
           (= d -1) (= (filter (set (filter (set s1) s2)) s1) (seq s1))
           (= d 1) (recur s2 s1)
           :else false)))
     
     (tree [xs]
       (->>
        (for [s1 xs s2 xs] [s1 s2])
        (filter #(apply cmp %))
        (reduce #(update-in %1 [(first %2)] conj (second %2)) {})))
     
     (r1 [ks path result xs]
       (if (seq ks)
         (r1 (rest ks) path (r2 (first ks) path result xs) xs)
         result))
     
     (r2 [k path result xs]
       (cond
         ((set path) k) (conj result path)
         (xs k) (r1 (xs k) (conj path k) result xs)
         :else (conj result (conj path k))))]
  
  (fn f[st]
    (->>
     (tree st)
     (r1 st [] [])
     (distinct)
     (some #(= (count %) (count st)))
     (= true))))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
(fn oh-god-no [s]
  (letfn [(diff-by-del [long-w short-w]
            (loop [n (count long-w)]
              (cond
               (= n 0) false
               (= (str (subs long-w 0 (dec n)) (subs long-w n)) short-w) true
               :else (recur (dec n)))))
          (diff-by-sub [l-w r-w]
            (if (= 1 (reduce #(if %2 %1 (inc %1)) 
                             0 
                             (map #(= %1 %2) l-w r-w)))
              true
              false))
          (diff-by-one [l-w r-w]
            (let [l-cnt (count l-w) r-cnt (count r-w)]
              (cond 
               (= l-cnt r-cnt) (diff-by-sub l-w r-w)
               (= (inc l-cnt) r-cnt) (diff-by-del r-w l-w)
               (= (inc r-cnt) l-cnt) (diff-by-del l-w r-w)
               :else false)))
          (find-one-shifts [wrd st]
            (filter #(diff-by-one wrd %) st))
          (set-to-sorted-map [s]
            (let [unsorted (reduce #(assoc %1 %2 (find-one-shifts %2 s)) {} s)]
              (into (sorted-map-by #(compare [(count (get unsorted %1)) %1]
                                             [(count (get unsorted %2)) %2]))
                    unsorted)))]
    (let [get-lowest-count (fn [st mp] (first (sort-by #(count (get mp %1)) st)))
          mp (set-to-sorted-map s)]
      (loop [head (last (first mp)) mp (dissoc mp (ffirst mp))]
        (let [p-lnks (filter #(contains? mp %) head)]
          (cond
           (empty? mp) true
           (empty? p-lnks) false
           :else
           (let [next-key (get-lowest-count p-lnks mp)]
             (recur (get mp next-key) (dissoc mp next-key)))))))))
sheldon's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [words] 
   (let [n (count words)
         m (vec (map vec (partition n (map #(if (= 1 %) 1 0) (for [a words b words]
     ((fn [s t] 
        ((fn f [j r] 
           (let [d (cons j r)
                 w (map #(list % %2 %3) s d r)
                 z (if (< j (count t)) (reduce #(conj % (if (= (first %2) (nth t j)) (second %2) (min (inc (second %2)) (inc (last %2)) (inc (last %))))) [(inc j)] w) d)]
             (if (= j (count t)) (last z) (f (inc j) (rest z))))) 0 (range 1 (inc (count s))))) a b))))))
         c (fn [m1 m2 y x] (reduce + (map * (map #(nth (nth m1 y) %) (range n)) (map #(nth (nth m2 %) x) (range n)))))
         mul (fn [m1 m2] (for [y (range n)] (for [x (range n)] (c m1 m2 y x))))
         h (partition n (for [i (range n) j (range n)] (if (< j i) 0 (if (= j i) 1 (get-in m [i j])))))]
      (= n (count (filter #{n} (flatten ((fn s [x y] (if (= 1 x) y (mul y (s (dec x) h)))) n h)))))))
silverio's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
#(let [
  nv    (count %)
  words (map seq %)
  edge? (fn edge? [w1 w2]
          (let [[h1 & t1] w1 [h2 & t2] w2]
            (if (= h1 h2) (edge? t1 t2)
              (or (= t1 t2)     ; substitution
                  (= t1 w2)     ; deletion
                  (= w1 t2))))) ; insertion
  graph (apply (partial merge-with concat) (for [a words b words
          :when (and (not= a b) (edge? a b))] {a [b]}))
  chain (fn chain [visited w] ; depth-first search for the chain
          (or (= nv (inc (count visited)))
              (some (partial chain (conj visited w))
                (filter (comp not visited) (graph w)))))]
  (not (not-any? (partial chain #{}) (keys graph))))
skyrem's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [s]
  (letfn [(iod [s l]
               (cond
                (empty? s) true 
                (empty? l) false
                (= (first s) (first l)) (recur (rest s) (rest l))
                :else (recur s (rest l))))
          (chk [s1 s2]
               (let [n (- (count s1) (count s2))]
                 (cond 
                  (= n 0) (>= 1 (count (filter #(not= 0 %) (map compare s1 s2))))
                  (= n 1) (iod s2 s1)
                  (= n -1) (iod s1 s2)
                  :else false)))]
    (loop [x (first s) p (disj s x) t p r [x]]
      (cond
       (empty? t) (empty? p)
       (chk (first r) x) (recur (first t) (disj p x) p (concat [x] r))
       (and (> (count r) 1) (chk (last r) x)) (recur (first t) (disj p x) p (concat r [x]))
       :else (recur (first t) p (rest t) r)))))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn [f2 s]
  (letfn
    [(f [a b]
      (let [g (fn [x] (reduce #(merge-with + %1 {%2 1}) {} x))
            [z y] [(g a) (g b)]
            ok? #{[0 1] [1 0] [1 1]}]
        (when (ok? (mapv #(apply + (vals %))
          (apply map #(into {} %&)
            [z y]
            (keep (fn [[k v]] (if (z k) [[k (Math/abs (- (z k) v))] [k (Math/abs (- v (z k)))]])) y))))
          b)))]
  (f2 s (into {} (map (fn [x] [x (set (filter #(f x %) s))]) s)) )))
(fn f2
  ([o s] (true? (some #(= o %) 
            (filter set? (tree-seq seq? identity (keep #(f2 % s []) s))))))
  ([[k v] s i]
    (let [i `[~@i ~k], t (dissoc (zipmap v (map s v)) i)]
      (if (seq s)
          (keep (fn [x]
                  (let [n (apply dissoc s k x)]
                    (when (not= s n) (f2 x n i)))) t)
          (set i)))))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
(letfn
 
[
( deletions [word]
    (set (into [(subs word 0 (dec (count word)))]
        (map
            #(str (subs word 0 (- % 1)) (subs word %))
            (range 1 (count word))))))
 
(adjacent [w1 w2]
    (let [d1 (deletions w1)
          d2 (deletions w2)]
      (some boolean [(d1 w2) (d2 w1)
        (and 
            (= (count w1) (count w2))
            (= 1 (count (filter (partial apply #(not= %1 %2)) (map vector w1 w2)))))])))
 
( permutations [xs]
    (if (empty? xs)
        []
    (if (empty? (rest xs))
        [[(first xs)]]
    (loop [back (first xs)
           left []
           right (vec (rest xs))
           so-far []]
        (if (empty? right)
            (into so-far (map #(conj % back) (permutations left)))
            (recur
                (first right)
                (into left [back])
                (rest right)
                (into so-far (vec (map #(conj % back) (permutations (into left right)))))))))))
 
( is-chain [words]
    (first
        (reduce
            (fn [[so-far last] now]
                (if-not so-far
                    [so-far now]
                    [(adjacent last now) now]))
            [true (first words)]
            (rest words))))
 
( word-chain [words]
    (boolean (some
        is-chain
        (permutations words))))]
    word-chain)
syeerzy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [w]
  (letfn [(n? [a b]
            (let [[[cx x] [cy y]] (sort (map (juxt count str) [a b]))]
              (case (- cy cx)
                0 (= 1 (reduce + (map #(if (= % %2) 0 1) x y)))
                1 (let [n (count (take-while #(apply = %) (map list x y)))]
                    (= (subs x n) (subs y (inc n))))
                false)))
          (s? [ws r]
             (let [ws (disj ws r)
                   n (filter #(n? % r) ws)]
               (or (empty? ws) (some #(s? ws %) n))))]
    (boolean (some #(s? w %) w))))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
(fn [words]
  (let [adjacents (memoize (fn [word]
                             (let [size (count word)
                                   alphabet "abcdefghijklmnopqrstuvwxyz"]
                               ((comp set #(filter words %) concat)
                                ;; insertions
                                (for [i (range (inc size))
                                      c alphabet]
                                  (str (subs word 0 i) c (subs word i size)))
                                ;; deletions
                                (for [i (range size)]
                                  (str (subs word 0 i) (subs word (inc i) size)))
                                ;; substitutions
                                (for [i (range size)
                                      c alphabet
                                      :when (not= (nth word i) c)]
                                  (str (subs word 0 i) c (subs word (inc i) size)))))))
        permutations (fn permutations [xs]
                       (if (seq xs)
                         (for [x xs
                               ys (permutations (for [z xs
                                                      :when (not= z x)]
                                                  z))]
                           (conj ys x))
                         '(())))
        valid? (fn [path]
                 (->> (partition 2 1 path)
                      (map (fn [[from to]] (contains? (adjacents from) to)))
                      (every? true?)))]
    (boolean (some valid? (permutations words)))))
 
;; golfed
;(fn [r b n q]
;    (let [a (memoize (fn [w]
;                        (let [s (count w)
;                              c "abcdefghijklmnopqrstuvwxyz"
;                              f #(str (b w 0 %1) %2 (b w %3 s))]
;                          ((comp set #(filter q %) concat)
;                           (for [i (r (n s))
;                                 c c]
;                             (f i c i))
;                           (for [i (r s)]
;                             (f i nil (n i)))
;                           (for [i (r s)
;                                 c c
;                                 :when (not= (nth w i) c)]
;                             (f i c (inc i)))))))
;          p (fn p [X]
;               (if (seq X)
;                 (for [x X Y (p (for [z X :when (not= z x)] z))]
;                   (conj Y x))
;                 '(())))
;          v (fn [p]
;               (->> (partition 2 1 p)
;                    (map (fn [[k v]] (contains? (a k) v)))
;                    (every? true?)))]
;      (boolean (some v (p q)))))
;range subs inc
thegeez's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(fn [words]
    (let [substitution (fn [word other]
                         (and (= (count word) (count other))
                              (= 1 (count (remove identity (map = word other))))))
          insertion (fn [word other]
                      (let [[small long] (sort-by count [word other])]
                        (and (= (inc (count small)) (count long))
                             (->> (map vector
                                       (concat small [:padding :padding])
                                       (concat long [:padding]))
                                  (drop-while (partial apply =))
                                  (partition 2 1)
                                  (map (fn [[[s _] [_ l]]] (= s l)))
                                  (every? #{true})))))
          neighbor? (memoize (fn [word other]
                               (or (substitution word other)
                                   (insertion word other)
                                   (insertion other word))))
          paths (fn paths [items]
                  (condp = (count items)
                      0 []
                      1 [(seq items)]
                      (mapcat (fn [item]
                                (map (partial list* item)
                                     (paths (remove #{item} items)))) items)))]
      (or (some #(every? (partial apply neighbor?)
                         (partition 2 1 %)) (paths words))
          false)))
zzamboni's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn word-chain? [words]
  (letfn [(l-dist [s1 s2]  ; recursive algorithm from https://en.wikipedia.org/wiki/Levenshtein_distance#Recursive 
            (let [l1 (count s1) l2 (count s2) dl1 (drop-last s1) dl2 (drop-last s2)]
              (cond (zero? l1) l2
                    (zero? l2) l1
                    :else (min (inc (l-dist dl1 s2)) (inc (l-dist s1 dl2))
                               (+ (l-dist dl1 dl2) (if (= (last s1) (last s2)) 0 1))))))]
    (let [l-matrix  ; levenshtein distance matrix represented as a map of maps {word1 {word2 distance}}
          (apply merge-with merge (for [w words x words] {w {x (l-dist w x)}}))]
      ;; observed heuristic: in at least n-1 rows of the full Levenshtein distance matrix
      ;; there must be at least 2 connections with distance 1
      (<= (dec (count words))
          (count (filter #(>= % 2)
                         (map #(->> % second vals (filter #{1}) count) l-matrix)))))))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn __ [s]
  (letfn [(levenshtein-distance [s t]
               (if (= s t) 0
                 (letfn [(f [s v0]
                            (if (empty? s) (nth v0 (count t))
                              (recur (rest s)
                                     (loop [j 0, v1 [(inc (first v0))]]
                                       (if (= j (count t)) v1
                                         (recur (inc j)
                                                (conj v1 (min (inc (nth v1 j))
                                                              (inc (nth v0 (inc j)))
                                                              (+ (nth v0 j)
                                                                 (if (= (first s)
                                                                        (nth t j))
                                                                   0 1))))))))))]
                   (f s (vec (range (inc (count t)))))))),
          (can-chain? [x xs] ; can form a word chain starting from x using all the words in xs
             (or (empty? xs)
                 (true?
                  (some true?
                        (map #(can-chain? % (disj xs %))
                             (filter #(= 1 (levenshtein-distance x %))
                                     xs))))))
          ]
    (true?
     (some true?
           (map #(can-chain? % (disj s %)) s)))))
zipzop's solution:

1
#(not (empty? (clojure.set/intersection #{"hat" "spout" "shares"} %)))
yusubori's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [s]
  (letfn [(diff-one-char? 
           [word1 word2]
           (cond
            (= (count word1)
               (count word2)) (= 1 (count
                                    (filter false?
                                            (map #(= % %2) word1 word2))))
              :else (let [w1 (max-key count word1 word2)
                          w2 (min-key count word1 word2)]
                      (some #(= (seq w2) %)
                            (map #(concat (take % w1) (drop (inc %) w1)) (range (count w1)))))))
          (chain?
           [words]
           (every? true?
                   (map (partial apply diff-one-char?) (partition 2 1 words))))
          (combination
           [coll]
           (let [f (fn f [avec coll]
                     (if (empty? coll) avec
                       (for [x coll]
                         (f (conj avec x) (remove #(= x %) coll)))))]
             (partition (count coll)
                        (flatten (f [] coll)))))]
    (boolean (some chain? (combination s)))))
ydash's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [s]
  (letfn [(l [[h & t :as a] [f & r :as b]]
            (cond (nil? h) (count b)
                  (nil? f) (count a)
                  (= f h)  (recur t r)
                  :else (min (inc (l t r))
                             (inc (l a r))
                             (inc (l t b)))))
          (c? [i s]
            (if (empty? s)
              true
              (let [m (group-by #(= (l % i) 1) s)]
                (if-let [t (m true)]
                  (loop [[f & r] t]
                    (if f
                      (if-let [c (c? f (remove #(= f %) s))]
                        c
                        (recur r))
                      false))
                  false))))]
    (reduce #(if (c? %2 (remove (fn [x] (= x %2)) s)) true %) false s)))
vpeurala's solution:

1
2
3
4
5
6
7
(fn [xs] (letfn [
    (prepend-to-each [pre xs] (map concat (repeat pre) xs))
    (cycles [arr] (map #(drop % (take (+ (count arr) %) (cycle arr))) (range (count arr))))
    (permutations [xs] (let [perm (fn [mem-perm xs] (let [perm (fn [xs] (mem-perm mem-perm xs))] (if (empty? xs) [[]] (mapcat #(prepend-to-each (first %) (lazy-seq (perm (second %)))) (map (partial split-at 1) (cycles xs)))))) mem-perm (memoize perm)] (mem-perm mem-perm xs)))
    (levenshtein [a b] (let [lev (fn [mem-lev a b x y] (let [lev (fn [a b x y] (mem-lev mem-lev a b x y))] (if (= 0 (min x y)) (max x y) (min (+ (lev a b (- x 1) y) 1) (+ (lev a b x (- y 1)) 1) (+ (lev a b (- x 1) (- y 1)) (if (= (nth a (dec x)) (nth b (dec y))) 0 1)))))) mem-lev (memoize lev)] (mem-lev mem-lev a b (count a) (count b))))
    (word-chain? [xs] (not (empty? (filter #(every? (partial = 1) (map (partial apply levenshtein) (partition 2 1 %))) (permutations xs)))))
    ] (word-chain? xs)))
v_bogdanov's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
(fn chain? [st]
  (let [st (into (sorted-set) st)]
    (letfn [(near?1 [s1 s2]
              (let [r (range (count s1))]              
                (not= r
                      (for [x r
                            :let [ptrn
                                  (re-pattern
                                   (apply str (assoc-in (vec s1) [x] \.)))]
                            :while (not (re-matches ptrn s2))]
                        x))))
            (near?2 [s1 s2]
              (let [[ls ss] (if (> (count s1) (count s2)) [s1 s2] [s2 s1])
                    r (range (count ls))]
                (not= r (for [x r
                              :while (not=
                                      ss (apply str
                                                (update-in
                                                 (vec ls) [x]
                                                 (fn [a] nil))))]
                          x))))
            (near? [s1 s2]
              (cond (= (count s1) (count s2))
                    (near?1 s1 s2)
                    (or (= (count s1) (inc (count s2)))
                        (= (count s1) (dec (count s2))))
                    (near?2 s1 s2)
                    1 false))]
      (loop [c [(first st)]
             s (disj st (first c))]
        (if (empty? s) true
            (let [l (first
                     (for [x s
                           :when (or (near? x (first c))
                                     (near? x (last c)))]
                       x))] 
              (if (nil? l)
                false
                (recur (if (near? l (first c)) (into [l] c)
                           (into c [l])) (disj s l)))))))))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
(fn is-word-chain [word-bag]
  (letfn [(is-differ [w1 w2]
            (let [v1 (vec w1)
                  v2 (vec w2)
                  len1 (count v1)
                  len2 (count v2)
                  vs (if (> len1 len2) v2 v1)
                  vl (if (> len1 len2) v1 v2)
                  qt (if (> len1 len2) (- len1 len2) (- len2 len1))
                  rt (map #(not (= %1 %2)) v1 v2)]
              (if (= 1 (count (filter #{true} rt)))
                true
                (if (not (= len1 len2))
                  (let [idx (.indexOf rt true)]
                    (if (= idx -1)
                      (= qt 1)
                      (= vs (concat (subvec vl 0 idx)
                                    (subvec vl (inc idx))))))
                  false))))
          (word-chain [w word-bag]
            (println w)
            (let [xset (set (remove #{w} word-bag))]
              (if (empty? xset)
                (do (println "-------1111111111111-------")
                    true)
                (let [dif (filter #(is-differ % w) xset)]
                  (if (empty? dif)
                    (do (println "-----------")
                        false)
                    (not (empty? (filter true? (map #(word-chain % xset) dif)))))))))]
    (let [results (map #(word-chain % word-bag) word-bag)]
      (not (empty? (filter true? results))))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn find-chain [words]
  (let [lev (fn lev [s1 s2]
              (cond (empty? s1) (count s2)
                    (empty? s2) (count s1)
                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))
                    :else (inc (min (lev (rest s1) s2)
                                    (lev s1 (rest s2))
                                    (lev (rest s1) (rest s2))))))
        neighbors (fn [words word] (filter #(= (lev word %) 1) words))
        chain (fn chain [graph visited root]
                (let [visited (conj visited root)
                      neigh (remove visited (graph root))]
                  (if (= visited words) 
                    true
                    (some (partial chain graph visited) neigh))))
        graph (into {} (for [w words] [w (neighbors words w)]))]
    (true? (some (partial chain graph #{}) words))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
(fn [words] 
(letfn [(rem-nth [coll n]
  (concat (take n coll) (drop (inc n) coll)))
 
(del-letter [word n]
  (apply str (rem-nth word n)))
 
(word-ins-n? [old-word new-word n]
  (= old-word (del-letter new-word n)))
 
(word-ins? [old-word new-word]
  (reduce #(or % %2) (map (partial word-ins-n? old-word new-word)
                  (range (count new-word)))))
 
(word-subs-n? [old-word new-word n]
  (= (del-letter old-word n) (del-letter new-word n)))
 
(word-subs? [old-word new-word]
  (reduce #(or % %2) (map (partial word-subs-n? old-word new-word)
                  (range (count new-word)))))
 
(word-del-n? [old-word new-word n]
  (= new-word (del-letter old-word n)))
 
(word-del? [old-word new-word]
  (reduce #(or % %2) (map (partial word-del-n? old-word new-word)
                  (range (count old-word)))))
 
(build-chain [words]
  (loop [ word (first words)
         words (next words)
         chain []]
    (let [_ (filter #(or
                          (word-ins? word %)
                          (word-subs? word %)
                          (word-del? word %))
                       words)
          link (first _)]
      (if-not link chain
        (let [words (filter #(not= link %) words)]
          (recur link words (conj chain link)))))))
 
(linked? [word1 word2]
  (or (word-ins? word1 word2)
      (word-subs? word1 word2)
      (word-del? word1 word2)))
 
(insert-link [chain link]
  (cond
    (linked? link (first chain)) (cons link chain)
    (linked? link (last chain)) (concat chain [link])
    :else (let [n (first (filter #(and
                                    (linked? (nth chain %) link)
                                    (linked? (nth chain (inc %)) link))
                                 (range 1 (dec (count chain)))))]
            (if n
              (concat (take (inc n) chain) [link] (drop (inc n) chain))
              chain))))
 
(max-chain [words]
  (let [chain (build-chain words)
        left (clojure.set/difference words chain)]
    (loop [left left
           chain chain]
      (if (not left)
        chain
        (recur (next left) (insert-link chain (first left)))))))]
 
(= (count words) (count (max-chain words)))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)