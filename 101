;; 101 Levenshtein Distance [h]

Calculates minimum number of edits (insert/delete/replace)
needed to transform x into y.

(= (__ "kitten" "sitting") 3)
(= (__ "closure" "clojure") (__ "clojure" "closure") 1)
(= (__ "xyx" "xyyyx") 2)
(= (__ [1 2 3 4] [0 2 3 4 5]) 2)
(= (__ '(:a :b :c :d) '(:a :d)) 2)
(= (__ "ttttattttctg" "tcaaccctaccat") 10)
(= (__ "gaattctaatctc" "caaacaaaaaattt") 9)

(memoize 
  (fn lev [s1 s2]
    (cond
      (zero? (count s1)) (count s2)
      (zero? (count s2)) (count s1)
      (= (first s1) (first s2)) (lev (rest s1) (rest s2))
      :else (inc (min (lev (rest s1) s2)
                      (lev s1 (rest s2))
                      (lev (rest s1) (rest s2)))))))

(fn [a b]
  (letfn [(lcs [[x-h & x-t :as x] [y-h & y-t :as y]]
            (cond
              (empty? x) (count y)
              (empty? y) (count x)
              (= x-h y-h) (lcs x-t y-t)
              :else (+ 1 (min (lcs x y-t) (lcs x-t y) (lcs x-t y-t)))))]
    (lcs a b)))

(fn levenshtein [w1 w2]
  (letfn [(cell-value [same-char? prev-row cur-row col-idx]
            (min (inc (nth prev-row col-idx))
                 (inc (last cur-row))
                 (+ (nth prev-row (dec col-idx)) (if same-char?
                                                   0
                                                   1))))]
    (loop [row-idx  1
           max-rows (inc (count w2))
           prev-row (range (inc (count w1)))]
      (if (= row-idx max-rows)
        (last prev-row)
        (let [ch2           (nth w2 (dec row-idx))
              next-prev-row (reduce (fn [cur-row i]
                                      (let [same-char? (= (nth w1 (dec i)) ch2)]
                                        (conj cur-row (cell-value same-char?
                                                                  prev-row
                                                                  cur-row
                                                                  i))))
                                    [row-idx] (range 1 (count prev-row)))]
          (recur (inc row-idx) max-rows next-prev-row))))))

(fn [s1 s2]
  (let[s1Len (count s1) s2Len (count s2)
       memory (atom {})];explicitly using a memory here
    (letfn[(distance [ind1 ind2];why 4clojure doesn't support def [f (fn [])] or explicitly using memoize in def?
                     (if-let [found (@memory [ind1 ind2])] found ;check memory first (note the key ranges from 0 to seq length with both ends inclusive
                       (let [dist (cond
                                   (= ind1 s1Len) (count (drop ind2 s2));reach one end, then the distance is length of the other one
                                   (= ind2 s2Len) (count (drop ind1 s1))
                                   (= (get s1 ind1) (get s2 ind2)) (distance (inc ind1) (inc ind2));if two chars are identical move both cursors
                                   :else (let [len1 (inc (distance (inc ind1) ind2));move one cursor, add one to the distance
                                               len2 (inc (distance ind1 (inc ind2)))
                                               len12 (inc (distance (inc ind1) (inc ind2)))];move both cursors (note: the distance should be considered as plus one, like xy->zy) 
                                      (min len1 len2 len12)))];get the minimal among all possible changes
                         (do
                           (swap! memory assoc [ind1 ind2] dist) dist))))];updates memory and returns the result
   (distance 0 0))))

(fn [w1 w2]
  (letfn [
    (dist [d w1 w2]
      (cond
        (empty? w1) (count w2)
        (empty? w2) (count w1)
        :else
          (min
            (inc (d d (rest w1) w2))
            (inc (d d w1 (rest w2)))
            (+ (if (= (first w1) (first w2)) 0 1)
              (d d (rest w1) (rest w2))))))]
  (dist (memoize dist) w1 w2)))
aceeca1's solution:

1
2
3
4
5
6
7
8
9
10
(letfn [
    (dis [dis-memoized x1 x2] (cond 
        (= 0 (count x1)) (count x2)
        (= 0 (count x2)) (count x1)
        true (apply min (remove nil? [
            (inc (dis-memoized dis-memoized (rest x1) (rest x2)))
            (inc (dis-memoized dis-memoized x1 (rest x2)))
            (inc (dis-memoized dis-memoized (rest x1) x2))
            (when (= (first x1) (first x2)) (dis-memoized dis-memoized (rest x1) (rest x2)))]))))]
    (partial dis (memoize dis)))
adereth's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [a b]
  ((reduce (fn [acc [i j]]
                      (assoc acc [i j]
                             (if (zero? (min i j))
                               (max i j)
                               (min (inc (acc [(dec i) j]))
                                    (inc (acc [i (dec j)]))
                                    (+ (acc [(dec i) (dec j)])
                                       (if (= (nth a (dec i))
                                              (nth b (dec j)))
                                         0 1))))))
                    {} (sort-by #(apply + %)
                       (for [i (range (inc (count a)))
                             j (range (inc (count b)))]
                         [i j])))
   [(count a)
          (count b)])
)
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
(fn levehnsteinX[a b]
    (letfn [
        (costAdd[cost a b]
            (if (= a b)
                cost
                (inc cost)
            )
        )
        (levRec[a b mem]
            (let [existing (get mem [a b])]
                (if (not (nil? existing))
                    { :val existing :mem mem} 
                    (let [res 
                        (cond 
                            (empty? a) {:val (count b) :mem mem}
                            (empty? b) {:val (count a) :mem mem}
                            :else (let [ 
                                    res1 (levRec (rest a) b mem)
                                    res2 (levRec  a (rest b) (get res1 :mem))
                                    res3 (levRec  (rest a) (rest b) (get res2 :mem))
                                ]
                                {
                                    :val (min 
                                        (inc (get res1 :val))
                                        (inc (get res2 :val))
                                        (costAdd (get res3 :val) (first a) (first b))
                                    )
                                    :mem (get res3 :mem)
                                }
                            )
                        )
                        ]
                        { :val (get res :val) :mem (assoc (get res :mem) [a b] (get res :val))}
                    )
                )
            )
        )
 
        ]
        (get (levRec (reverse a) (reverse b) {}):val)
    )
)
aguirre's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn levenshtein-distance 
  ([a b] (levenshtein-distance a b 0 (+ (count a) (count b))))
  ([a b mod-count best-so-far]
    (let
      [a-count (count a)
       b-count (count b)
       modf (fn [a b new-mod-count] (fn [new-best] (levenshtein-distance a b new-mod-count new-best)))
       mod-del-a (modf (rest a) b (inc mod-count))
       mod-del-b (modf a (rest b) (inc mod-count))
       mod-del-a-b (modf (rest a) (rest b) (inc mod-count))
       unmod-del-a-b (modf (rest a) (rest b) mod-count)
       mod-only [mod-del-a mod-del-b mod-del-a-b]
       mod-unmod [unmod-del-a-b mod-del-a mod-del-b]
       search (fn search ([mods] (search mods best-so-far))
                ([mods best] (if (empty? mods) best
                               (let [new-best (min ((first mods) best) best)]
                                 (min new-best (search (rest mods) new-best))))))]
      (cond (>= mod-count best-so-far) best-so-far
            (= a-count b-count 0) mod-count
            (= a-count 0) (mod-del-b best-so-far)
            (= b-count 0) (mod-del-a best-so-far)
            (= a b) mod-count
            (= (first a) (first b)) (search mod-unmod)
            :else (search mod-only)))))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [w1 w2]
  (if (or (zero? (count w1)) (zero? (count w2)))
    (+' (count w1) (count w2))
    (let [fr (range (inc' (count w1)))
          upper1 (count w1)
          upper2 (inc' (count w2))
          diff (fn [wr1 wr2 ln1 ln2] (if (= (nth wr1 ln1) (nth wr2 ln2)) 0 1))
          edd (fn [wr1 wr2 ln1 ln2 prevr currr] (min (inc' (nth prevr ln1))
                                                    (inc' (last currr))
                                                    (+' (nth prevr (dec' ln1)) (diff wr1 wr2 ln1 ln2))))
          pw1 (concat [[]] w1)
          pw2 (concat [[]] w2)]
      (loop [n1 1 n2 1 pr fr cr [1]]
        (cond
         (= n2 upper2) (last pr)
         (< n1 upper1) (recur (inc' n1) n2 pr (concat cr [(edd pw1 pw2 n1 n2 pr cr)]))
         (= n1 upper1) (recur 1 (inc' n2) (concat cr [(edd pw1 pw2 n1 n2 pr cr)]) [(inc' n2)]))))))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
(fn leven [w1 w2]
  (letfn [(count-diff [w1 w2]
            (let [[sm lg] (sort (map count [w1 w2]))]
              (- lg sm)))
          (max-leven [w1 w2]
            (+ (apply + (map #(if (= %1 %2) 0 1) w1 w2))
               (count-diff w1 w2)))]
    (let [bound (max-leven w1 w2)]
      (letfn [(leven' [diffs w1 w2]
                (let [[wc1 & wr1] w1
                      [wc2 & wr2] w2]
                  #_(println bound diffs w1 w2)
                  (cond
                    (= diffs bound) diffs
                    (and wc1 wc2) (if (= wc1 wc2)
                                    (leven' diffs wr1 wr2)
                                    (min
                                     ;; insert wc2 to w1
                                     (leven' (inc diffs) (cons wc2 wr1) w2)
                                     ;; insert wc1 to w2
                                     (leven' (inc diffs) w1 (cons wc1 wr2))
                                     ;; delete w1
                                     (leven' (inc diffs) wr1 w2)
                                     ;; delete w2
                                     (leven' (inc diffs) w1 wr2)
                                     ;; replace
                                     (leven' (inc diffs) wr1 wr2)))
                    (and (not wc1) (not wc2))   diffs
                    wc2                         (+ diffs (- (count w2) (count w1)))
                    wc1                         (+ diffs (- (count w1) (count w2)))
                    )))]
        (leven' 0 w1 w2)))))
andthorn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn [s t]
  (if (= s t)
    0
    (if (zero? (count s))
      (count t)
      (if (zero? (count t))
        (count s)
        (loop [i 0 v0 (apply vector (range 0 (inc(count t))))]
          (if (= i (count s))
            (last v0)               
             (recur
              (inc i)
              (loop [j 0 v1 (apply vector (inc i) (repeat (count t) 0))]
                (if (= j (count t))
                   v1
                   (recur
                    (inc j)
                    (update-in v1 [(inc j)]
                               (fn [_](min
                                 (inc(nth v1 j))
                                 (inc(nth v0 (inc j)))
                                 (+ (nth v0 j) (if (= (nth s i) (nth t j)) 0 1))  )))))))))))))
anjensan's solution:

1
2
3
4
5
6
7
(let [f (fn [f [af & ar :as a] [bf & br :as b]]
            (if (and (seq a) (seq b))
              (if (= af bf)
                (f f ar br)
                (inc (min (f f a br) (f f ar b) (f f ar br))))
              (+ (count a) (count b))))]
    (fn [a b] (f (memoize f) a b)))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn
  [s1 s2]
  (let [lev (memoize
              (fn [y i j]
                (if (= 0 (min i j))
                  (max i j)
                  (let [cost (if (= (get s1 (dec i))
                                    (get s2 (dec j)))
                               0
                               1)]
                    (min (inc (y y (dec i) j))
                         (inc (y y i (dec j)))
                         (+ cost (y y (dec i) (dec j))))))))]
    (lev lev (count s1) (count s2))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [a b]
  (loop [scores [[a b 0]]]
    (let [finished (filter (fn [[a b _]] (and (empty? a) (empty? b))) scores)]
      (if (seq finished)
        (apply min (map last finished))
        (recur (mapcat (fn [[a b score]]
          (if (= (first a) (first b))
            [[(rest a) (rest b) score]]
            (concat
              (if (empty? a) [] [[(rest a) b (inc score)]])
              (if (empty? b) [] [[a (rest b) (inc score)]])
              (if (or (empty? a) (empty? b)) [] [[(rest a) (rest b) (inc score)]]))))
          scores))))))
awebb's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn lev [s t] 
  (let [lev* 
         (memoize (fn [lev* s t]
           (cond (zero? (count s)) (count t)
                 (zero? (count t)) (count s)
                 :else (min
                         (inc (lev* lev* (rest s) t))
                         (inc (lev* lev* s (rest t)))
                         (+ (lev* lev* (rest s) (rest t))
                            (if (= (first s) (first t)) 0 1))))))]
  (lev* lev* s t)))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn levin [q r]
  ((fn lev [[q-head & q-tail :as q] [r-head & r-tail :as r] verboten]
    (cond
      (and (nil? q-head) (nil? r-head)) 0
      (or  (nil? q-head) (nil? r-head)) (max (count q) (count r))
      (= q-head r-head) (levin q-tail r-tail)
      :else
        (inc 
          (cond
            (= verboten :none)   (min (lev q-tail r-tail :none) (lev q r-tail :delete) (lev q-tail r :insert))
            (= verboten :delete) (min (lev q-tail r-tail :none) (lev q r-tail :delete))
            (= verboten :insert) (min (lev q-tail r-tail :none) (lev q-tail r :insert))))))
  q r :none))
benhammond's solution:

1
2
3
4
5
6
7
8
(fn dis
    ([xxs yys] (dis 0 xxs yys))
    ([c [x & xs :as xxs] [y & ys :as yys]]
     (cond (and (nil? x) (nil? y)) c
           (= x y) (dis c xs ys)
           (> (count xxs) (count yys)) (min (dis (inc c) xs ys) (dis (inc c) xs yys))
           (< (count xxs) (count yys)) (min (dis (inc c) xs ys) (dis (inc c) xxs ys))
           :else (dis (inc c) xs ys))))
benizi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
(fn lev [s t]
  (let [[ls lt] (map count [s t])]
    (if (< lt ls)
      (lev t s)
      (last
       (reduce
        (fn [sofar i]
          (loop [nextrow [(inc i)]
                 j 1]
            (if (= (count sofar) (count nextrow))
              (do (prn nextrow) nextrow)
              (let [sl (nth s i :nil-s)
                    tl (nth t (dec j) :nil-t)
                    replace (if (= sl tl) 0 1)
                    diag (+ replace (get sofar (dec j)))
                    above (inc (get sofar j))
                    left (inc (last nextrow))]
                (recur (conj nextrow (min diag above left))
                       (inc j))))))
        (let [start (vec (range (inc lt)))]
          (do (prn start) start))
        (range ls))))))
bobuhiro11's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn q [str1 str2]
  (let [p (atom false)]
    (reset! p (memoize (fn [i1 i2 len1 len2]
                         (cond (= len1 i1) (- len2 i2)
                               (= len2 i2) (- len1 i1)
                               :else
                               (min (inc (@p (inc i1) i2 len1 len2))
                                    (inc (@p i1 (inc i2) len1 len2))
                                    (+ (if (= (nth str1 i1) (nth str2 i2)) 0 1)
                                       (@p (inc i1) (inc i2) len1 len2)))))))
    (@p 0 0 (count str1) (count str2))))
burner's solution:

1
2
3
4
5
6
7
8
9
10
(letfn [(lev [lf s1 s2]
                (cond (empty? s1) (count s2)
                      (empty? s2) (count s1)
                      :otherwise (min (inc (lf lf (rest s1) s2))
                                      (inc (lf lf s1 (rest s2)))
                                      (+ (lf lf (rest s1) (rest s2)) (if (= (first s1) (first s2))
                                                                     0
                                                                     1)))))]
        (let [mem (memoize lev)]
          (partial mem mem)))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(let [mem (atom {})];an explicit memory is used here
  (fn distance [s1 s2]  
    (if (contains? @mem [s1 s2]) (@mem [s1 s2])
      (cond
       (= (seq s1) (seq s2) nil) (do (swap! mem assoc [s1 s2] 0) 0)
       (and (seq s1) (seq s2)) (let[subS1subS2 (distance (rest s1) (rest s2))
                                    subS1S2 (distance (rest s1) s2)
                                    s1subS2 (distance s1 (rest s2))]
                                 (if (= (first s1) (first s2))
                                   (let[dist (min subS1subS2 (inc subS1S2) (inc s1subS2))]
                                     (do (swap! mem assoc [s1 s2] dist) dist))
                                   (let[dist (min (inc subS1subS2) (inc subS1S2) (inc s1subS2))]
                                     (do (swap! mem assoc [s1 s2] dist) dist))))
       (seq s1) (let [dist (count s1)] (do (swap! mem assoc [s1 s2] dist) dist))
       :else (let [dist (count s2)] (do (swap! mem assoc [s1 s2] dist) dist))))))
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn [xs ys]
   ((fn calc-next [xs ys rs]
      (let [y (first ys)]
        (if (nil? y)
          (last rs)
          (calc-next xs (rest ys)
                     ;; loop to get next rs
                     (loop [xs xs
                            rs rs
                            nrs [(inc (first rs))]]
                       (if (empty? xs) nrs
                           (recur (rest xs)
                                  (rest rs)
                                  (conj nrs (min (inc (last nrs))
                                                 (inc (second rs))
                                                 (+ (first rs)
                                                    (if (= (first xs) y) 0 1)))))
                           )
                       ))
          )
 
        )
      ) xs ys (range (inc (count xs)))))
chunchangshao's solution:

1
2
3
4
5
6
7
8
9
#(if (= % %2)
   0
   (case %
     "kitten" 3
     ("clojure" "closure") 1
     "" (count %2)
     "ttttattttctg" 10
     "gaattctaatctc" 9
     2))
ctzsm's solution:

1
2
3
4
5
(fn edit-dist [a b]
  (cond (not b) (count a) (not a) (count b) 
        :else (let [ra (next a) rb (next b)]
(if (= (first a) (first b)) (edit-dist ra rb) 
  (+ 1 (min (edit-dist ra rb) (edit-dist ra b) (edit-dist a rb)))))))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(letfn [(distance [step xs ys]
          (cond
           (empty? xs)
           (count ys)
           
           (empty? ys)
           (count xs)
           
           :else
           (let [[x & sub-xs] xs
                 [y & sub-ys] ys
                 cost (if (= x y) 0 1)]
             (min (inc (step step sub-xs ys))
                  (inc (step step xs sub-ys))
                  (+ cost (step step
                                sub-xs
                                sub-ys))))))]
  
  (let [step (memoize distance)]
    (fn levenshtein [xs ys]
      (step step xs ys))))
daniels's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn levendist [a b]
  (let [lendiff (- (count a) (count b))
        value (fn [target current] (reduce + (map #(if (= % %2) 0 1) current target)))
        drop-nth (fn drop-nth [n s] (concat (take n s) (drop (inc n) s)))
        shorten-single (fn [s] (map #(drop-nth % s) (range (count s)) ))
        shortened-set (fn [start steps]
                        (loop [c (conj #{} start) s steps]
                          (if (= 0 s)
                            c
                            (recur (into #{} (apply concat (map shorten-single c))) (dec s)))))
        find-best-value (fn [s target]
                          (apply min-key last
                                 (map (juxt identity (partial value target)) s)))
        ]
    (if (< lendiff 0)
      (levendist b a)
      (+ lendiff (last (find-best-value (shortened-set a lendiff) b))))))
 
; removes elements from the longer sequence until equal length - finds the best match from all possibilities
; the levenshtein distance is then the number of not yet matching elements plus the number of elements that needed removing
daowen's solution:

1
2
3
4
5
6
7
8
9
(fn levenshtein [s1 s2]
  (let [f (fn [rec a b]
            (let [[ca cb] (map count [a b])]
              (if (some zero? [ca cb]) (max ca cb)
                (min (inc (rec rec (pop a) b))
                     (inc (rec rec a (pop b)))
                     (+ (rec rec (pop a) (pop b))
                        (if (= (peek a) (peek b)) 0 1))))))]
    (f (memoize f) (vec s1) (vec s2))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(fn [s t] 
 (let [temp s
       s (if (< (count s) (count t)) t s)
       t (if (= s t) temp t)
       len_s (count s) len_t (count t) 
       v0 (atom (apply hash-map (apply concat (for [i (range (inc len_s))] [i 0]))))
       v1 (atom (apply hash-map (apply concat (for [i (range (inc len_t))] [i 0]))))]
    (doseq [i (range (inc len_s))]
         (swap! v0 assoc i i)
    )
    (doseq [i (range len_s)]
      (swap! v1 assoc 0 (inc i))
      (doseq [j (range len_t)]
        (let [cost (if (= (nth s i) (nth t j)) 0 1)]
          (swap! v1 assoc (inc j) (min
             (inc (@v1 j))
             (inc (@v0 (inc j)))
             (+ cost (@v0 j))
           )
          )
        )
      )
      (doseq [j (range (inc len_s))]
         (swap! v0 assoc j (@v1 j))
      )
    )
     (@v1 len_t)
 )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn [hs vs]
  (let [lh (inc (count hs))
        lv (inc (count vs))
        top-row (range lh)]
    (letfn [(splice-row [last-row row-no] 
                        (loop [grow [row-no]]
                            (if (= (count grow) lh) grow
                              (let [i (count grow) 
                                    cand1-root (nth last-row (dec i))
                                    cand1 (if (= (nth hs (dec i)) 
                                                 (nth vs (dec row-no)))
                                            cand1-root (inc cand1-root))
                                    cand2 (inc (nth last-row i))
                                    cand3 (inc (last grow))
                                    newp (min cand1 cand2 cand3)]
                                  (recur (conj grow newp))
                                  ))))
            (do-table [top-row]
                      (loop [last-row top-row
                             row-no 1]
                        (if (= row-no lv) last-row
                          (recur (splice-row last-row row-no) (inc row-no))
                          )))]
      (let [bottom-row (do-table top-row)]
        (last bottom-row)
        ))))
devm33's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [a b]
  (last
    (reduce
      (fn [prevrow j]
        (reductions
          (fn [prev i]
            (min (inc prev) (inc (nth prevrow i))
                 (+ (nth prevrow (dec i)) 
                    (if (= (nth a (dec i)) (nth b (dec j))) 0 1))))
          j (range 1 (inc (count a)))))
      (range (inc (count a))) (range 1 (inc (count b))))))
dwelte's solution:

1
2
3
4
5
6
(memoize (fn lev [xs ys]
  (cond
    (= (count xs) 0) (count ys)
    (= (count ys) 0) (count xs)
    (= (first xs) (first ys)) (lev (rest xs) (rest ys))
    :else (+ 1 (min (lev (rest xs) (rest ys)) (lev xs (rest ys)) (lev (rest xs) ys))))))
dzholev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn [s1 s2]
  (letfn [(calc-v [v0 c i]
              (loop [t s2
                     v1 [(inc i)]
                     v v0]
                (if (empty? t)
                  v1
                  (recur
                    (rest t)
                    (conj v1 (min (inc (last v1)) (inc (second v)) (+ (first v) (if (= c (first t)) 0 1))))
                    (rest v)))))]
    (cond
      (= s1 s2) 0
      (= s1 "") (count s2)
      (= s2 "") (count s1)
      :else (loop [v0 (range (inc (count s2)))
                   s s1
                   i 0]
              (if (empty? s)
                (last v0)
                (recur
                  (calc-v v0 (first s) i)
                  (rest s)
                  (inc i)))))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
(fn [s1 s2]
 (let [ cm (apply max (map count [s1 s2]))
  start-set (conj #{} (vec (sort-by str [s1 s2])))
  s-map (sorted-map 0 start-set) 
  rec-levenshtein ( fn [ [ws dm cm]] 
    (let [ [d s] (first dm)
            rdm (dissoc dm d)
            str-rest (fn[s] (->> s rest ))
            str-assoc (fn[m k [w1 w2]]
                (let [w1w2s (vec (sort-by str [w1 w2]))] 
                    ;(println m k w1 w2)
                    ;(println w1w2s)
                    (if (contains? ws w1w2s) 
                        m
                        (assoc m k (set (conj (m k) w1w2s))))))
            d1-vecs (fn [w1 w2] [[(str-rest w1) w2] [(str-rest w1) (str-rest w2)]
                        [w1 (str-rest w2)]])
            do-one ( fn[[wsi dmi cmi] [w1 w2]]
                (let [ wsr (conj wsi [w1 w2])]
                    (cond
                        (= w1 w2)   [wsr dmi (min cmi d)]
                        (empty? w1) [wsr dmi (min cmi (+ d (count w2)))]
                        (empty? w2) [wsr dmi (min cmi (+ d (count w1)))]
                        (= (first w1) (first w2))
                            [wsr (str-assoc dmi d (map str-rest [w1 w2])) cmi]
                        :else
                            [wsr (reduce #(str-assoc %1 (inc d) %2) dmi (d1-vecs w1 w2)) cmi]) 
                ))]
       ; (println "ws =" ws)
       ; (println "dm =" dm)
       ; (println "cm =" cm)
       ; (println "---- >>")
        (cond
            (empty? dm) cm
            (= 0 cm) 0
            (>= d cm) cm
            :else (recur (reduce do-one [ws rdm cm] s))
            )))
  ]
  (rec-levenshtein [#{} s-map cm])))
ericw's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn levenshtein-distance [s1 s2]                                                                                                                        
    (->> (for [l1 s1 l2 s2] [l1 l2])                                                                                            
         (partition (count s2))                                                                                                                         
         (reduce                                                                                                                
            (fn [prev row]                                                                                                                              
                ; build the next row of distances                                                                                                       
                (reduce                                                                                                         
                    (fn [cur [a b]]                                                                                                                     
                        (let [i (count cur)]                                                                                    
                            (conj cur                                                                                           
                                (if (= a b) (get prev (dec i))                                                                                          
                                            (+ (min (get prev i) (last cur) (get prev (dec i))) 1)))))                          
                    [(inc (first prev))]                                                                                                                
                    row))                                                                                                       
            (vec (range (inc (count s2)))))                                                                                                             
         (last)))
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn levenshtein-distance [s1 s2]
  (letfn [(cost [s1 s2 i j] (if (= (get s1 i) (get s2 j)) 0 1))
          (fill-vec [s1 s2 i v1 v2]
            (reduce (fn [acc j]
                      (assoc acc
                             (inc j)
                             (min (inc (get acc j))
                                  (inc (get v1 (inc j)))
                                  (+ (get v1 j) (cost s1 s2 i j)))))
                    (assoc v2 0 (inc i))
                    (range (dec (count v2)))))]
    (let [len1 (count s1), len2 (count s2)]
      (cond
        (= s1 s2) 0
        (= 0 len1) len2
        (= 0 len2) len1
        :else
        (let [fill-v (partial fill-vec s1 s2)]
          (loop [idxs (range len1)
                 v1 (vec (range (inc len2)))
                 v2 (vec (take (inc len2) (repeat 0)))]
            (let [[i & i-rest] idxs]
              (if-not (nil? i)
                (let [v (fill-v i v1 v2)]
                  (recur i-rest v v))
                (last v2)))))))))
finsternis's solution:

1
2
3
4
5
6
7
(fn [seq1 seq2]
  (letfn [(update-cell [s2 acc [[i1 s1] [sub del]]]
              (conj acc (min (+ sub (if (= s1 s2) 0 1)) (inc del) (inc (last acc)))))
          (ziprow [s r] (map list (map-indexed vector s) (partition 2 1 r)))
          (update-row [prev [i2 s2]]
            (reduce (partial update-cell s2) [(inc i2)] (ziprow seq1 prev)))]
    (last (reduce update-row (-> seq1 count inc range) (map-indexed vector seq2)))))
flububb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn lev [a b]
  (letfn [(lev-line [lastr ch s]
            (loop [ [a b & r] lastr
                    result     [(inc (first lastr))]
                    [s0 & sr]  s]
              (if s0
                (recur
                  (conj r b)
                  (conj result (apply min [(inc b) (inc (last result)) (if (= s0 ch) a (inc a))]))
                  sr)
                result)))]
    (if (= a b)
      0
      (last (reduce
        (fn [r ch] (lev-line r ch a))
        (range (+ 2 (count a)))
        b)))))
garyxia's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn [a b]
  (letfn [(step [calculated-result coordinate]
            (let [x (first coordinate)
                  y (last coordinate)]
              (assoc calculated-result
                coordinate
                (if (zero? (min x y))
                  (max x y)
                  (min
                    (inc (calculated-result [(dec x) y]))
                    (inc (calculated-result [x (dec y)]))
                    (+
                      (calculated-result [(dec x) (dec y)])
                      (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))]
    ((reduce step {} (apply concat (map #(map (fn [i] [% i]) (range 0 (inc (count b)))) (range 0 (inc (count a)))))) [(count a) (count b)])))
geekerzp's solution:

1
2
3
4
5
6
7
(fn lev [[h & t :as a] [f & r :as b]]
    (cond (nil? h) (count b)
          (nil? f) (count a)
          (= f h) (recur t r)
          :else (min (inc (lev t r))
                     (inc (lev a r))
                     (inc (lev t b)))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn edit-distance [source target]
    (let [source (vec source)
          target (vec target)
          targlen (count target)
          rowlen (inc targlen)
          ; For empty source, cost is insertion of each target item
          initrow (vec (map #(- targlen %) (range rowlen)))]
        (loop [i (dec (count source)), prevrow initrow]
            (if (neg? i)
                (prevrow 0)
                (let [sitem (source i)
                      build-row
                        (fn [ti row]
                            (cond
                                (neg? ti) 
                                    row
                                (= (target ti) sitem) 
                                    (recur (dec ti) (conj row (prevrow (inc ti))))
                                :else
                                    (let [rep (inc (prevrow (inc ti)))
                                          ins (inc (first row))
                                          del (inc (prevrow ti))]
                                        (recur (dec ti) (conj row (min rep ins del)))
                                    )))
                    ]
                    (recur (dec i) (vec (build-row (dec targlen) (list (inc (prevrow targlen))))))
                )))))
goaranger's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(fn __ [src tar]
 (let [s (if (string? src) (clojure.string/split src #"") src)
       t (if (string? tar) (clojure.string/split tar #"") tar)
       n (count s) m (count t)
       matm (fn [ma i j nv]
             (let [prei (subvec (nth ma j) 0 i)
               posi (subvec (nth ma j) (inc i))
           nr (if (empty? prei) 
                      (into [nv] posi)
                  (into (conj prei nv) posi))]
            (if (= j 0)
            (into [nr] (subvec ma (inc j)))
        (if (= j (count ma))
            (conj (subvec ma 0 j) nr)
                    (into (conj (subvec ma 0 j) nr) (subvec ma (inc j)))))))
       tc (fn [ma ci xx yy]
              (let [sa (nth xx (dec ci))]
               (loop [oma (rest ma) nma ma j 1]
             (if (empty? oma)
                 nma
                 (let [tstv (if (= (nth yy (dec j)) sa) 0 1)
                   nnv   (min (+ 1 (nth (nth nma (dec j)) ci))
                             (+ 1 (nth (nth nma j) (dec ci)))
                         (+ tstv (nth (nth nma (dec j)) (dec ci))))]
 
              (recur (rest oma)
                 (matm nma ci j nnv)
                (inc j)))))))]
       (if (= n 0) m
           (if (= m 0) n
           (if (= s t) 0
        (loop [mat (vec (cons (vec (range (inc n))) (mapv #(into [] (cons % (repeat n nil))) (into [] (range 1 (inc m))))))
              i 1]
              (if (> i n)
                  (last (last mat))
                  (recur (tc mat i s t) (inc i)))))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn levdist [s1-in s2-in]
  (let [cache (atom {})]
    (letfn [(f [s1 s2]
              (let [c1 (count s1) c2 (count s2)
                    key [c1 c2]
                    cached-cost (@cache key)
                    cost
                    (cond cached-cost
                          cached-cost
 
                          (or (empty? s1) (empty? s2))
                          (max c1 c2)
 
                          :else
                          (min (inc (f s1 (rest s2)))
                               (inc (f (rest s1) s2))
                               (+ (if (= (first s1) (first s2))
                                    0 1)
                                  (f (rest s1) (rest s2)))))]
                (println s1 s2 cost (if cached-cost "cached" ""))
                (if (nil? cached-cost)
                  (swap! cache assoc key cost))
                cost))]
      (f s1-in s2-in))))
happycrisis's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn [start end]
  (letfn [(max-changes-needed [w target]
            (+ (Math/abs (- (count w) (count target)))
               (count (filter identity (map not= w target)))))] 
    (let [start (vec (seq start)) end (vec (seq end))
          alphabet (distinct end)
          mx (max-changes-needed start end)]
      (loop [q [[start 0]]] 
        (let [[[w n]] q]
          (if (= w end)
            n
            (let [len (count w)
                  inserts (for [c alphabet i (range (inc len))]
                            (vec (concat (subvec w 0 i) [c] (subvec w i))))
                  deletes (for [i (range len)]
                            (vec (concat (subvec w 0 i) (subvec w (inc i)))))
                  substs (for [c alphabet i (range len)]
                           (vec (concat (subvec w 0 i) [c] (subvec w (inc i)))))
                  all (filter (fn [nw]
                                (when (< (max-changes-needed end nw) (max-changes-needed end w))
                                  nw))
                              (concat inserts deletes substs))]
              (recur (vec
                      (sort-by (fn [[w n]] (max-changes-needed end w))
                               <
                               (concat (subvec q 1) (map #(vector % (inc n)) all))))))))))))
hisba's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn levd [s t]
   (let [cs (count s) ct (count t)
         sr (range (inc cs)) tr (range (inc ct))
         si (zipmap (map (fn [x] [x 0]) sr) sr)
         ti (zipmap (map (fn [y] [0 y]) tr) tr)
         dm (into si ti)]
     (loop [m dm i 1 j 1]
       (if (m [cs ct]) (m [cs ct])
         (recur (conj 
                 {[i j]
                  (if (= (nth s (dec i)) (nth t (dec j))) (m [(dec i) (dec j)])
                    (inc (min (m [(dec i) j])
                              (m [i (dec j)])
                              (m [(dec i) (dec j)])
                              )))
                  } m)
                (if (= i cs) 1 (inc i))
                (if (= i cs) (inc j) j))))))
icamts's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [s1 s2]
  (let [cost (fn [c1 c2] (if (= c1 c2) 0 1))
        lev-it (fn [d cs i]
                 (reductions 
                   (fn [pc [[pd cd] c]] 
                     (if (zero? c) pd 
                       (+ c (min pc pd cd)))) 
                   i (map list (partition 2 1 d) cs)))]
    (last (reduce (fn [d c] 
                    (lev-it d (map (partial cost c) s1) 
                            (inc (first d)))) 
                  (range (inc (count s1))) s2))))
immo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [& i]
  (let [c count
        [x y] (sort #(< (c %1) (c %2)) i)]
    (loop [s x l y n (c y)]
      (if s
        (let [a (first s)
              f ((set l) a)]
            (recur
                (next s)
                (if f (rest (drop-while #(not= a %) l)) l)
                (if f (dec n) n)))
        n))))
jarlax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [s t]
  (let [dist
        (fn [s t mdist]
          (let [sl (count s)
                tl (count t)]
            (cond
             (zero? sl) tl
             (zero? tl) sl
             :else (let [si (dec sl)
                         ti (dec tl)
                         cost (if (= (last s) (last t)) 0 1)
                         s1 (take si s)
                         t1 (take ti t)]
                     (min
                      (inc (mdist s1 t mdist))
                      (inc (mdist s t1 mdist))
                      (+ (mdist s1 t1 mdist) cost))))))]
    (dist s t (memoize dist))))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn leven [x y] 
  (let [l (memoize (fn [f x y]
    (cond (empty? x) (count y)
          (empty? y) (count x)
           :else (min (+ (f f (rest x) y) 1)
                      (+ (f f x (rest y)) 1)
                      (+ (f f (rest x) (rest y)) (if (= (first x) (first y)) 0 1))
                  )
    )
    ))
    magic (partial l l)]
    (magic x y)
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn [x y]
  (let [memo (atom {})]
    (letfn [(lev* [i j]
              (if (contains? @memo [i j])
                (get @memo [i j])
                (let [ret (if (= 0 (min i j))
                            (max i j)
                            (min
                              (inc (lev* (dec i) j))
                              (inc (lev* i (dec j)))
                              (+ (lev* (dec i) (dec j))
                                 (if (= (nth x (dec i)) (nth y (dec j)))
                                   0
                                   1))))]
                  (swap! memo assoc [i j] ret)
                  ret)))]
      (lev* (count x) (count y)))))
johncowie's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn f [s t]
  (cond (= s t) 0
        (empty? s) (count t)
        (empty? t) (count s)
        :else
        (loop [i 0 v (range 0 (inc (count t)))]
          (if (= i (count s))
            (last v)
            (recur (inc i)
                   (loop [j 0 v1 [(inc i)]]
                     (if (= j (count t))
                       v1
                       (let [cost (if (= (nth s i) (nth t j)) 0 1)]
                         (recur (inc j) (concat v1 [(min (inc (last v1)) (inc (nth v (inc j))) (+ (nth v j) cost))]))))))))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn distance [a b]
  (letfn [(walk
           [f a b]
           (cond
             (or (nil? a) (nil? b))
             (+ (count a) (count b))
             
             (= (first a) (first b))
             (f f (next a) (next b))
            
             :else
             (inc (min (f f (next a) (next b))
                       (f f (next a) b)
                       (f f a (next b))))))]
    (walk (memoize walk) a b)))
jorendorff's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [a b]
    (let [f (fn [g i j] (cond
                         (= 0 i) j
                         (= 0 j) i
                         :else (min (inc (g g (dec i) j))
                                    (inc (g g i (dec j)))
                                    (+ (g g (dec i) (dec j))
                                       (if (= (nth a (dec i)) (nth b (dec j)))
                                         0
                                         1)))))
          g (memoize f)]
      (g g (count a) (count b))))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
(fn levenshtein-distance [s t]
  (cond (= s t) 0
        (= 0 (count s)) (count t)
        (= 0 (count t)) (count s)
        :otherwise
        (loop [v0 (vec (take (inc (count t)) (range))) i 0 v1 [0]]
          (if (= i (count s))
            (last v1)
            (let [next-v1  (loop [v1 v1 j 0]
                             (if (= j (count t))
                               v1
                               (let [v1p (update-in v1 [0] (fn [_] (inc i)))
                                     cost (if (= (get-in s [i]) (get-in t [j])) 0 1)
                                     v1v (min
                                           (+ (get-in v1p [j]) 1)
                                           (+ (get-in v0 [(+ j 1)]) 1)
                                           (+ (get-in v0 [j]) cost))]
                                 (recur (update-in v1p [(inc j)] (fn [_] v1v)) (inc j))
                                 )
                               )
                             )]
              (recur next-v1 (inc i) next-v1)
              )))))
kohyama's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [s d]
  (loop [a [[0 s d]]]
    (let [m (keep (fn [[l x y]] (if (= x y) l)) a)]
      (if (not (empty? m))
          (apply min m)
          (recur
            (mapcat
              (fn [[l [sf & sr :as s] [df & dr :as d]]]
                (if (= sf df)
                    (vector [l sr dr])
                    (vector [(inc l) s dr] [(inc l) sr d] [(inc l) sr dr])))
              a))))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
(fn [s t]
  (let [s (vec s)
        t (vec t)
        m (count s)
        n (count t)
        d (reduce #(conj %1 (reduce conj [%2] (repeat m 0)))
                  [(-> m inc range)] (range 1 (inc n)))]
    (letfn [(gt [d i j] (-> d (nth j) (nth i)))
            (pt [d i j v] (assoc-in d [j i] v))]
      (-> (loop [j 1, d d]
            (if (> j n) d
                (recur (inc j)
                       (loop [i 1, d d]
                         (if (> i m) d
                             (recur (inc i)
                                    (let [i- (dec i) j- (dec j)]
                                      (if (= (s i-) (t j-))
                                        (pt d i j (gt d i- j-))
                                        (pt d i j
                                            (->> [(gt d i- j )
                                                  (gt d i  j-)
                                                  (gt d i- j-)]
                                              (map inc)
                                            (apply min)))))))))))
        last last))))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn prob101
  [a b]
  (let [levenshtein (fn [fnc str1 str2]
                     (let [len1 (count str1)
                           len2 (count str2)]
                       (cond (zero? len1) len2
                             (zero? len2) len1
                             :else
                             (let [cost (if (= (first str1) (first str2)) 0 1)]
                               (min (inc (fnc fnc (rest str1) str2))
                                    (inc (fnc fnc  str1 (rest str2)))
                                    (+ cost
                                       (fnc fnc (rest str1) (rest str2))))))))]
    (levenshtein (memoize levenshtein) a b)))
brendan's solution:

1
2
3
4
5
6
7
8
9
10
(fn levenstein [a b]
  (let [lev (fn lev [a b]
            (cond (= a b) 0
                  (= a []) (count b)
                  (= b []) (count a)
                  :else (min (if (< (count a) (count b)) (inc (lev a (rest b)))
                                (inc (lev (rest a) b)))
                             (+ (lev (rest a) (rest b)) (if (= (first a) (first b)) 0 1)))))
        mem-lev (memoize lev)]
    (mem-lev a b)))
kuze's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn my-levenshtein-distance
  [str1 str2]
  (cond
    (= str1 str2) 0
    (= 0 (count str1)) (count str2)
    (= 0 (count str2)) (count str1)
    :else
    (let [v0 (into [] (take (inc (count str2)) (range)))
          calculate-cost (fn [x y] (if (= (get str1 x) (get str2 y)) 0 1))]
      (loop [rowOld v0 i 0 ]
        (if (= i (count str1))
          (last rowOld)
          (recur (loop [rowNew (vector (inc i)) j 1]
                   (if (= j (inc (count str2)))
                     rowNew
                     (recur (conj rowNew (min
                                           (inc (get rowNew (dec j)))
                                           (inc (get rowOld j))
                                           (+ (calculate-cost i (dec j)) (get rowOld (dec j))))) (inc j)))) (inc i)))))))
lackita's solution:

1
2
3
4
5
6
7
8
9
10
(fn levenshtein [a b]
  (cond (empty? a) (count b)
        (empty? b) (count a)
        (= (first a) (first b)) (levenshtein (rest a) (rest b))
        (= (rest a) (rest b)) 1
        (= (seq a) (rest b)) 1
        (= (rest a) (seq b)) 1
        :else (inc (min (levenshtein (rest a) (rest b))
                        (levenshtein (seq a) (rest b))
                        (levenshtein (rest a) (seq b))))))
lambda4fun's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn [xs ys]
  (let [num-rows (inc (count xs))
        num-cols (inc (count ys))
        dist (atom (->> (range num-rows)
                        (map (fn [_] (vec (repeat num-cols 0))))
                        vec))]
    (doseq [i (range num-rows)]
      (swap! dist assoc-in [i 0] i))
    (doseq [j (range num-cols)]
      (swap! dist assoc-in [0 j] j))
    (doseq [j (range 1 num-cols)
            i (range 1 num-rows)
            :let [replace-cost ({true 0 false 1} (= (get xs (dec i))
                                                    (get ys (dec j))))]]
      (swap! dist assoc-in [i j]
             (min (inc (get-in @dist [(dec i) j]))
                  (inc (get-in @dist [i (dec j)]))
                  (+ replace-cost (get-in @dist [(dec i) (dec j)])))))
    (get-in @dist [(dec num-rows) (dec num-cols)])))
lasthemy's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
; This would've been much simpler if I could actually use memoize.
(fn lev [s t]
  (cond
   (= s t) 0
   (empty? s) (count t)
   (empty? t) (count s)
   :else
   (loop [v0 (range (inc (count t)))
          i 0]
     (if (= i (count s))
       (last v0)
       (recur
        (loop [v1 [(inc i)]
               j 0]
          (if (= j (count t))
            v1
            (recur
             (conj v1
                   (min (inc (last v1))
                        (inc (nth v0 (inc j)))
                        (+ (nth v0 j) (if (= (nth s i) (nth t j)) 0 1))))
             (inc j)
             )
            )
          )
        (inc i)
        )
       )
     )
   )
  )
lbarrett's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(letfn [(implicit-dp [rec sa sb]
          (cond (empty? sa) (count sb)
                (empty? sb) (count sa)
                :else (min
                        (+ (if (= (first sa) (first sb))
                             0
                             1)
                           (rec rec (rest sa) (rest sb)))
                        (+ 1 (rec rec sa (rest sb)))
                        (+ 1 (rec rec (rest sa) sb)))))
        (leven-dp [sa sb]
          (let [dp (memoize implicit-dp)]
            (dp dp sa sb)))]
  leven-dp)
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn [w1 w2]
  (cond
    (= w1 w2) 0
    (empty? w1) (count w2)
    (empty? w2) (count w1)
    :else
      (letfn [(get-reduce-fn [[ltr _]]
                             (fn [[l v] [[l0 v0] [l1 v1]]]
                               (list l1
                                 (min (inc v1) (inc v)
                                   (+ v0 (if (= ltr l1) 0 1))))))
              (next-row [row first-item]
                        (partition 2 1
                                   (reductions
                                     (get-reduce-fn first-item)
                                     first-item
                                     row)))
              (make-row [w] (map list w (iterate inc 1)))
              (make-first-row [w] (cons '(nil 0) (make-row w)))]
        (->> (make-first-row w2)
             (reduce 
               next-row
               (partition 2 1 (make-first-row w1)))
             ((comp last last last))))))
littlejp2046's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [s1 s2]
  (let [d (memoize (fn [i j dst]
    (cond
      (= 0 i) j
      (= 0 j) i
      :else (if (= (get s1 (- i 1)) (get s2 (- j 1)))
        (dst (- i 1) (- j 1) dst)
        (+ 1 (reduce min 
          [(dst (- i 1) j dst)
           (dst i (- j 1) dst)
           (dst (- i 1) (- j 1) dst)]))))))]
    (d (count s1) (count s2) d)))
malvert's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(fn [s t]
  ((fn [[c d]]
  ((reduce
    (fn [u j]
      (reduce
        (fn [v i]
          (assoc v [(+ i 1) (+ j 1)]
            (if (= (nth s i) (nth t j))
              (v [i j])
              (+ 1 
                (min 
                  (v [i (+ 1 j)])
                  (v [(+ i 1) j])
                  (v [i j]))))))
        u
        (range c)))
    (into {} (concat (map (fn [i] [[i 0] i]) (range (+ 1 c)))
                     (map (fn [j] [[0 j] j]) (range (+ 1 d)))))
    (range d))
    [c d]))
    (map count [s t])))
matiasl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(fn [seq-a seq-b]
  (let [a (inc (count seq-a))
        b (inc (count seq-b))
        vec-a (vec seq-a)
        vec-b (vec seq-b)]
    (cond
      (zero? (dec a)) (dec b)
      (zero? (dec b)) (dec a)
      :else
      (letfn [(initialize [a b]
                (vec (for [i (range a)]
                    (vec (for [j (range b)]
                        (cond
                          (zero? i) j
                          (zero? j) i
                          :else 0))))))
              (cost [d i j]
                (min (+ 1 (get-in d [(dec i) j]))
                     (+ 1 (get-in d [i (dec j)]))
                     (+ (if (= (get vec-a (dec i))
                               (get vec-b (dec j)))
                          0
                          1) (get-in d [(dec i) (dec j)]))))
              (process [table m n]
                (loop [x 0
                       y 1
                       d table]
                  (let [[i j] (if (= x (dec m))
                                [1 (inc y)]
                                [(inc x) y])]
                    (if (= j n)
                      d
                      (recur i j (assoc-in d [i j] (cost d i j)))))))]
        (let [d (initialize a b)
              d (process d a b)]
          (get-in d [(dec a) (dec b)]))))))
maximental's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [C s t]
  ((fn f [i j]
     (cond 
       (= i 0) j
       (= j 0) i
       (= (nth s (- i 1)) (nth t (- j 1))) (f (- i 1) (- j 1))
       :else   (+ 1 
                  (min (f (- i 1) j)
                       (f i       (- j 1))
                       (f (- i 1) (- j 1))))))
   (C s) (C t))) count
mbakhterev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn [x y]
  (let [u (vec x)
        v (vec y)
        M (count u)
        N (count v)
        R (fn [P m]
            (loop [D [m] n 1]
              (if (< N n)
                D
                (let [dm (dec m)
                      dn (dec n)
                      c (if (= (u dm) (v dn)) 0 1)
                      v (min (inc (P n))
                             (inc (last D))
                             (+ (P dn) c))]
                  (recur (conj D v) (inc n))))))]
    (loop [D (vec (range (inc N))) m 1]
      (if (< M m) (last D) (recur (R D m) (inc m))))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn lev-dist--compat [x y]
  (let [lev-dist--memo
        (fn [a b f]
          (cond
            (empty? a)     (count b)
            (empty? b)     (count a)
            (= (first a)
               (first b))  (f (rest a) (rest b) f)
            :else          (inc (min (f a (rest b) f)
                                     (f (rest a) b f)
                                     (f (rest a) (rest b) f)))))]
    (lev-dist--memo x y (memoize lev-dist--memo))))
mfikes's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn levenshtein-distance [s t]
  (let [f (fn [f s t]
            (cond
              (empty? s) (count t)
              (empty? t) (count s)
              :else (let [cost (if (= (first s) (first t)) 0 1)]
                      (min (inc (f f (rest s) t))
                           (inc (f f s (rest t)))
                           (+ cost (f f (rest s) (rest t)))))))
        g (memoize f)]
    (g g s t)))
minitrue's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(let [ed
      (fn [f a b]
        (let [[a0 & a_] a
              [b0 & b_] b]
          (if (or (nil? a) (nil? b))
            (+ (count a) (count b))
            (if (= a0 b0)
              (f f a_ b_)
              (inc (min (f f a b_)
                        (f f a_ b)
                        (f f a_ b_)))))))
      ed-mem (memoize ed)]
  (partial ed-mem ed-mem))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn levenshtein [s t]
           (loop [counteri 1 counterj 1 matrix (vec (map #(vec (range % (+ 1 (count t) %)))
                                                         (range 0 (inc (count s)))))]
             (if (> counteri (count s))
               (peek (peek matrix))
               (if (> counterj (count t))
                 (recur (inc counteri) 1 matrix)
                 (recur counteri (inc counterj) (assoc-in matrix [counteri counterj]
                                                          (if (= (get s (dec counteri)) (get t (dec counterj)))
                                                            (get-in matrix [(dec counteri) (dec counterj)])
                                                            (min (inc (get-in matrix [(dec counteri) counterj]))
                                                                 (inc (get-in matrix [counteri (dec counterj)]))
                                                                 (inc (get-in matrix [(dec counteri) (dec counterj)]))))))))))
mobiusloop's solution:

1
2
3
4
5
6
7
8
9
(fn [s t]
  (let [lv (memoize (fn [lv s t] (cond
    (empty? s) (count t)
    (empty? t) (count s)
    :otherwise (let [cost (if (= (first s) (first t)) 0 1)]
                 (min (inc (lv lv (rest s) t)) (inc (lv lv s (rest t))) (+ cost (lv lv (rest s) (rest t)))))
    )))]
    (lv lv s t)
  ))
mononite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s t]
  (let [smax (inc (count s)) 
        tmax (inc (count t) )
        d (to-array-2d (repeat smax (repeat tmax nil)))]
    (doseq [i (range 0 smax) j (range 0 tmax)]
      (cond (= i 0) (aset d i j j)
            (= j 0) (aset d i j i)
            :default (let [v1 (inc (aget d (dec i) j))
                           v2 (inc (aget d i (dec j)))
                           v3 (+ (aget d (dec i) (dec j)) 
                                 (if (= (nth s (dec i)) (nth t (dec j))) 0 1))]
                       (aset d i j (min v1 v2 v3)))))
    (aget d (dec smax) (dec tmax))))
mouse's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn l
    ([w o]
       (let [wc (count w)
             oc (count o)]
         (cond
          (zero? oc) wc
          (zero? wc) oc
          :else
          (l 0 {-1 0} (vec w) (vec o)) )))
    ([n p w [c & r]] (pr n p)
       (if c
         (l (+ 1 n)
            (reduce #(conj % (min
                              (+   ({c 0} (get w %2 %2) 1)
                                   (get p (- %2 1) (max n %2)))
                              (+ 1 (get % (- %2 1) n))
                              (+ 1 (get p %2 %2))  ))
                    [] (range (count w))) w r)
         (last p))))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
;; Wagner–Fischer algorithm
(fn levenshtein-dist [s1 s2]
  (let [width  (inc (count s1))
        height (inc (count s2))
        matrix (vec (repeat height (vec (repeat width 0))))
        matrix (assoc matrix 0 (vec (range 0 width)))
        matrix (reduce #(assoc-in %1 [%2 0] %2) matrix (range 0 height))]
    (peek
     (peek
      (reduce (fn [matrix [y x]]
                (if (= (get s1 (dec x)) (get s2 (dec y)))
                  (assoc-in matrix [y x] (get-in matrix [(dec y) (dec x)]))
                  (assoc-in matrix [y x] (min (inc (get-in matrix [     y  (dec x)]))
                                              (inc (get-in matrix [(dec y)      x]))
                                              (inc (get-in matrix [(dec y) (dec x)]))))))
              matrix
              (for [y (range 1 height)
                    x (range 1 width)] [y x]))))))
nagi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
;; https://en.wikipedia.org/wiki/Wagner-Fischer_algorithm
(fn levenshtiein[s t]
  (let [m (count s)
        n (count t)
        matrix (mapv #(vec (range % (+ m % 1))) (range (inc n)))
        coords (for [x (range 1 (inc n))
                     y (range 1 (inc m))] [x y])
        distance (fn [[x y] m]
                   (if (= (get t (dec x)) (get s (dec y)))
                     (get-in m [(dec x) (dec y)])
                     (apply min
                       (map inc
                        [(get-in m [(dec x) y])
                         (get-in m [x (dec y)])
                         (get-in m [(dec x) (dec y)])])
                       )))
        invariant (loop [m matrix [c & cs] coords]
                    (if (nil? c)
                      m
                      (recur (update-in m c (fn [d] (distance c m))) cs)))]
    (get-in invariant [n m])))
nikelandjelo's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn levenstein [a b]
            (let [n (count a)
                  m (count b)
                  calc (fn [d [y x]]
                           (assoc-in d [y x]
                                     (if (= (nth a y)
                                            (nth b x))
                                         (get-in d [(dec y) (dec x)] (max x y))
                                         (->> [[-1 0] [-1 -1] [0 -1]]
                                              (map #(get-in d (vec (map + % [y x])) (max x y)))
                                              (apply min)
                                              (inc)))))]
                                              (if (or (empty? a) (empty? b))
                                                  (max (count a) (count b))
                                                  (->> (for [y (range n) x (range m)] [y x])
                                                       (reduce calc {})
                                                       (#(get-in % [(dec n) (dec m)] ))))))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
10
(fn df [a b]
    (let [alen (count a) blen (count b)]
      (cond (= alen blen) (count (filter true? (map not= a b)))
            (> alen blen) (df b a)
            ; from here alen < blen
            (= blen 0) 0
            :else (min 
                    (+ 1 (df a (rest b))) 
                    (+ (if (= (first a) (first b)) 0 1) (df (rest a) (rest b)))))
      ))
norman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(fn [str1 str2]
  (let [isize (inc (count str1))
        jsize (inc (count str2))
        all-pairs (for [i (range isize) j (range jsize)] [i j])
        reducer (fn [distances [i j]]
                  (assoc-in distances [i j]
                            (cond
                             (= i 0) j
                             (= j 0) i
 
                             (= (nth str1 (dec i)) (nth str2 (dec j)))
                             (get-in distances [(dec i) (dec j)])
 
                             :else
                             (+ 1 (min (get-in distances [(dec i) j])
                                       (get-in distances [i (dec j)])
                                       (get-in distances [(dec i) (dec j)]))))))
 
        zero-array (fn [m n]  (vec (take m (repeat (vec (take n (repeat 0)))))))
        init-state (zero-array isize jsize)
 
        levs (reduce reducer init-state all-pairs)
        val (last (last levs))]
    val))
nothsaevets's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn [s t]
    (let [s-size (count s)
          t-size (count t)
          max-count (* (inc s-size) (inc t-size))]
      (loop [grid {}]
        (if (= max-count (count grid))
          (get grid [s-size t-size])
          ;;grid
          (let [i (count grid)
                r (int (/ i (inc t-size)))
                c (mod i (inc t-size))]
            (cond
             (zero? r) 
             (recur (assoc grid [r c] c))
 
             (zero? c) 
             (recur (assoc grid [r c] r))
 
             (= (get s (dec r)) (get t (dec c)))
             (recur (assoc grid [r c] (get grid [(dec r) (dec c)])))
 
             :else 
             (let [left (get grid [r (dec c)])
                   up (get grid [(dec r) c])
                   up-left (get grid [(dec r) (dec c)])
                   cost (inc (min up up-left left))]
               (recur (assoc grid [r c] cost)))))))))
owk4057's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn myf [s1 s2]
  (letfn [(board-coor [board x y]
            (nth (nth board y) x))
          (change-board [board x y new-var]
            (assoc board y (assoc (nth board y) x new-var)))]
    (let [height (count s1)
          width (count s2)
          board (vec (map vec (for [x (range (inc height))] (for [y (range (inc width))] (+ x y)))))]
      (if (zero? height) width
      (loop [board board, x 1, y 1]
        (let [change (if (= (nth s1 (dec y)) (nth s2 (dec x))) 0 1)
              new-board (change-board board x y (min (inc (board-coor board (dec x) y)) (inc (board-coor board x (dec y))) (+ (board-coor board (dec x) (dec y)) change)))]
          (cond (and (= x width) (= y height)) (nth (nth new-board y) x)
                (= x width) (recur new-board 1 (inc y))
                :else (recur new-board (inc x) y))))))))
ownwaterloo's solution:

1
2
3
4
5
6
7
8
9
10
(fn distance [xs ys]
  (cond
    (empty? xs) (count ys)
    (empty? ys) (count xs)
    true
    (let [[x & xs'] xs
          [y & ys'] ys]
      (if (= x y)
        (distance xs' ys')
        (inc (min (distance xs' ys') (distance xs' ys) (distance xs ys')))))))
ozan's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s t]
  (let [distance
        (memoize (fn [f s t]
                   (if (empty? s) (count t)
                     (if (empty? t) (count s)
                       (min (inc (f f s (butlast t)))
                            (inc (f f t (butlast s)))
                            (+ (if (= (last s) (last t)) 0 1)
                               (f f (butlast s) (butlast t))))))))]
    (distance distance s t)))
pukeface's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [s t]
    (let [z count ! nth
          - dec
          d (memoize (fn [d i j]
                       (if (= i 0) j
                         (if (= j 0) i
                           (let [a (- i) b (- j) c (d d a b)]
                             (if (= (! s a) (! t b))
                               c
                               (+ 1 (min c
                                         (d d i b)
                                         (d d a j)))))))))
    ]
  (d d (z s) (z t))))
quant1's solution:

1
2
3
4
5
6
7
8
(fn levd [a b]
  (let [a1 (first a) b1 (first b)]
  (cond
    (nil? a1) (count b)
    (nil? b1) (count a)
    (= a1 b1) (levd (rest a) (rest b))
  :else
    (inc (min (levd (rest a) (rest b)) (levd a (rest b)) (levd (rest a) b))))))
rodmax's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
(fn [s t]
  (let [sn (count s) tn (count t)]
    (cond
      (= s t) 0
      (zero? sn) tn
      (zero? tn) sn
      :else
        (->>
          (reduce
            (fn [[i v0] s-item]
              [
                (inc i)
                (reductions 
                  #(min (inc %) %2)
                  (inc i)
                  (map min (map inc (drop 1 v0))
                    (map + v0 (map #(if (= s-item %) 0 1) t))
                  )
                )
              ]
            )
            [0 (range (inc tn))]
            s
          )
          second
          last
) ) )   )
sbondaryev's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
(fn [x y]
  (letfn
      [(levenshtein [mem s1 s2]
         (let [l1 (count s1)
               l2 (count s2)]
           (cond (zero? l1) l2
                 (zero? l2) l1
                 :else
                 (let [cost (if (= (first s1) (first s2)) 0 1)]
                   (min (inc (mem mem (rest s1) s2))
                        (inc (mem mem s1 (rest s2)))
                        (+ cost
                           (mem mem (rest s1) (rest s2))))))))]
    (levenshtein (memoize levenshtein) x y)))
shiro's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(fn l-d [left right]
  (let [cache (atom {})]
    (letfn [(lev-dist [left right]
              (let [cost (if (= (last left) (last right)) 0 1)
                    key [(count left) (count right)]]
                (cond 
                  (= 0 (count left)) 
                      (do (swap! cache assoc key (count right)) (count right))
                  (= 0 (count right)) 
                      (do (swap! cache assoc key (count left)) (count left))
                  (contains? @cache key) (get @cache key)
                  :else 
                  (let [val 
                          (min 
                            (inc (get @cache key (lev-dist (butlast left) right)))
                            (inc (get @cache key (lev-dist left (butlast right))))
                            (+ cost (get @cache key (lev-dist (butlast left) (butlast right)))))]
                    (do (swap! cache assoc key val) val)))))]
      (lev-dist left right))))
sheldon's solution:

1
2
3
4
5
6
(fn [s t] 
   ((fn f [j r] 
     (let [d (cons j r) 
           w (map #(list % %2 %3) s d r)
           z (if (< j (count t)) (reduce #(conj % (if (= (first %2) (nth t j)) (second %2) (min (inc (second %2)) (inc (last %2)) (inc (last %))))) [(inc j)] w) d)] 
       (if (= j (count t)) (last z) (f (inc j) (rest z))))) 0 (range 1 (inc (count s)))))
silverio's solution:

1
2
3
4
5
6
7
8
9
#(last (reduce (fn [r j]
  (reductions
    (fn [acc i]
      (if (= (nth %2 j) (nth % i)) (nth r i)
        (inc (min acc (nth r (inc i)) (nth r i)))))
    (inc j)
    (range (count %))))
  (range (inc (count %)))
  (range (count %2))))
skyrem's solution:

1
2
3
4
5
6
7
8
9
(fn [x y]
  (cond
   (= x y) 0
   (> (count x) (count y)) (recur y x)
   (= 0 (compare (first x) (first y))) (recur (rest x) (rest y))
   (= 0 (compare (last x) (last y))) (recur (butlast x) (butlast y))
   :else (count (filter false?
                        (map = (concat x (repeat (- (count y) (count x)) \*)) y)))
   ))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
10
(fn [s t]
  (let [[sc tc] (map count [s t])]
    (or ({s 0} t)
        ({sc tc} 0 ({tc sc} 0))
        (#(get (reduce % `[~@(range (inc tc))] (range sc)) tc)
         #(reduce (fn [x y] (conj x
             (min (inc (get x y))
                  (inc (get %1 (inc y)))
                  (+ (get %1 y) ({(get s %2) 0} (get t y) 1))) ))
           [(inc %2)] (range tc))) )))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
(letfn
[
(ff [xs] (first (first xs)))
(sf [xs] (second (first xs)))
(fs [xs] (first (second xs)))
(ss [xs] (second (second xs)))
(get-next [s]
  (set
    (mapcat
      (fn [[p [l r]]]
          (if (empty? l)
            [[(+ p (count r)) [nil nil]]]
          (if (empty? r)
            [[(+ p (count l)) [nil nil]]]
            [
              [(inc p) [(rest l) r]]
              [(inc p) [l (rest r)]]
              [(if (= (first l) (first r)) p (inc p)) [(rest l) (rest r)]]
            ])))
      s)))
(lev [s1 s2]
  (loop [now #{[0 [s1 s2]]}]
    (let [solutions (filter #(apply = ((juxt fs ss) %)) now)]
      (if (empty? solutions)
        (recur (get-next now))
        ; we're depending on the fact that the best solution will show up
        ; in the first generation that has any solutions
        (first (apply min-key first solutions))))))
]
lev)
syeerzy's solution:

1
2
3
4
5
6
7
(fn f [a b]                    
  (cond (empty? a) (count b)
        (empty? b) (count a)
        (= (first a) (first b)) (recur (rest a) (rest b))
        :else (inc (min (f (rest a) b) 
                        (f a (rest b)) 
                        (f (rest a) (rest b))))))
tclamb's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn [s t]
  (let [f (fn [f s t]
            (let [sc (count s)
                  tc (count t)]
              (cond
                (= sc 0) tc
                (= tc 0) sc
                :else (let [cost (if (= (last s) (last t)) 0 1)]
                        (min (inc (f f (butlast s) t))
                             (inc (f f s (butlast t)))
                             (+ (f f (butlast s) (butlast t)) cost))))))
        mf (memoize f)]
    (mf mf s t)))
thegeez's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [left right]
    ((fn lv [[l & ls :as left] [r & rs :as right] acc cutoff]
       (cond
        (> acc cutoff) acc
        (nil? l) (count right)
        (nil? r) (count left)
        (= l r) (lv ls rs acc cutoff)
        :else (min (inc (lv ls rs (inc acc) cutoff))
                   (inc (lv ls right (inc acc) cutoff))
                   (inc (lv left rs (inc acc) cutoff)))))
     left right 0 (max (count left) (count right))))
zzamboni's solution:

1
2
3
4
5
6
7
8
9
10
(fn foo [& args]
  (let [l-dist (memoize
                (fn [memf s1 s2]  ; recursive algorithm from https://en.wikipedia.org/wiki/Levenshtein_distance#Recursive
                  ;; Same as from #82 but takes as first argument a memoized version of itself, which is used in the recursive calls
                  (let [l1 (count s1) l2 (count s2) dl1 (drop-last s1) dl2 (drop-last s2) l-dist (partial memf memf)]
                    (cond (zero? l1) l2
                          (zero? l2) l1
                          :else (min (inc (l-dist dl1 s2)) (inc (l-dist s1 dl2))
                                     (+ (l-dist dl1 dl2) (if (= (last s1) (last s2)) 0 1)))))))]
    (apply l-dist l-dist args)))
zoltanjarai's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(fn __ [s t]
  (if (= s t) 0
    (letfn
      [(f [s v0]
          (if (empty? s)
            (nth v0 (count t))
            (recur (rest s)
                   (loop [j 0
                          v1 (vec (list (inc (first v0))))]
                     (if (= j (count t))
                       v1
                       (recur (inc j)
                              (conj v1 (min (inc (nth v1 j))
                                            (inc (nth v0 (inc j)))
                                            (+ (nth v0 j)
                                               (if (= (first s) (nth t j))
                                                 0 1))))))))))]
      (f s (vec (range (inc (count t))))))))
zipzop's solution:

1
2
3
4
5
6
7
8
9
(memoize 
  (fn ml [p q]
    (let [lp (count p) lq (count q)]
    (if (or (= 0 lp) (= 0 lq))
      (max lp lq)
      (let [rp (rest p) rq (rest q)]
        (if (= (first p) (first q))
          (ml rp rq)
          (inc (min (ml rp q) (ml p rq) (ml rp rq)))))))))
yusubori's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn levenshtein-distance [w1 w2]
  (let [f (fn [acc [i j]]
            (conj acc 
                  [[i j] 
                   (if (zero? (min i j)) 
                     (max i j)
                     (min (inc (acc [(dec i) j]))
                          (inc (acc [i (dec j)]))
                          (+ (acc [(dec i) (dec j)])
                             (if (= (nth w1 (dec i))
                                    (nth w2 (dec j))) 0 1))))]))]
    (get (reduce f
                 {}
                 (for [x (range (inc (count w1)))
                       y (range (inc (count w2)))]
                   [x y]))
         [(count w1) (count w2)])))
ydash's solution:

1
2
3
4
5
6
7
8
(fn lev [[h & t :as a] [f & r :as b]]
  (cond (nil? h) (count b)
        (nil? f) (count a)
        (= f h)  (recur t r)
        :else (min (inc (lev t r))
                   (inc (lev a r))
                   (inc (lev t b)))
        ))
vpeurala's solution:

1
(fn levenshtein [a b] (let [lev (fn [mem-lev a b x y] (let [lev (fn [a b x y] (mem-lev mem-lev a b x y))] (if (= 0 (min x y)) (max x y) (min (+ (lev a b (- x 1) y) 1) (+ (lev a b x (- y 1)) 1) (+ (lev a b (- x 1) (- y 1)) (if (= (nth a (dec x)) (nth b (dec y))) 0 1)))))) mem-lev (memoize lev)] (mem-lev mem-lev a b (count a) (count b))))
v_bogdanov's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(let [[c b l] [count butlast last]
      lev
      (fn [mem-lev s1 s2]
        (let [lev (fn [s1 s2] (mem-lev mem-lev s1 s2))]
          (cond (= s1 s2) 0
                (= (c s1) 0) (c s2)
                (= (c s2) 0) (c s1)
                true (min (+ (lev (b s1) s2) 1)
                          (+ (lev s1 (b s2)) 1)
                          (+ (if (= (l s1) (l s2)) 0 1) (lev (b s1) (b s2)))))))
      mem-lev (memoize lev)]
  #(mem-lev mem-lev % %2))
unionx's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
(fn levenshtein-distance-better [s1 s2]
  (let [len1 (inc (count s1))
        len2 (inc (count s2))
        total-steps (dec (* len1 len2))
        max-num 999999999999999]
    (if (= 0 total-steps)
      0
      (letfn [(calc-fn [result-map step-count]
                (if (= 0 step-count)
                  (calc-fn {[0 0] 0} 1)
                  (let [j (quot step-count len1)
                        i (rem step-count len1)
                        v1 (if (nil? (result-map [(dec i) j]))
                             max-num
                             (inc (result-map [(dec i) j])))
                        v2 (if (nil? (result-map [i (dec j)]))
                             max-num
                             (inc (result-map [i (dec j)])))
                        v3 (if (or (= 0 i)
                                   (= 0 j))
                             max-num
                             (if (= (nth s1 (dec i))
                                    (nth s2 (dec j)))
                               (result-map [(dec i) (dec j)])
                               (inc (result-map [(dec i) (dec j)]))))
                        min-v
                        (do
                          (min v1 v2 v3))]
                    (if (= total-steps step-count)
                      min-v
                      (recur (assoc result-map [i j] min-v) (inc step-count))))))]
        (calc-fn nil 0)))))
trxeste's solution:

1
2
3
4
5
6
7
8
9
(memoize 
  (fn lev [s1 s2]
    (cond
      (zero? (count s1)) (count s2)
      (zero? (count s2)) (count s1)
      (= (first s1) (first s2)) (lev (rest s1) (rest s2))
      :else (inc (min (lev (rest s1) s2)
                      (lev s1 (rest s2))
                      (lev (rest s1) (rest s2)))))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
(fn [s t]
  (let [sl (count s)
        tl (count t)]
    (cond
     (= s t) 0
     (empty? s) tl
     (empty? t) sl
     :else
     (last
      (loop [i 0
             v (-> tl inc range vec)]
        (if (= i sl) v
            (recur (inc i)
                   (loop [v-new [(inc i)]]
                     (if (= tl (-> v-new count dec)) v-new
                         (let [j (-> v-new count dec)
                               cost (if (= (nth s i) (nth t j)) 0 1)
                               v0_j (nth v j)
                               v0_jp1 (nth v (inc j))
                               v1_j (last v-new)]
                           (recur
                            (conj v-new
                                  (min
                                   (inc v1_j)
                                   (inc v0_jp1)
                                   (+ v0_j cost))))))))))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)