;; 108 Lazy Searching [m]

Takes any number of seqs,
each sorted from smallest to largest,
finds the smallest single number which appears
in all of the sequences.
Seqs may be infinite, searches lazily.

(defn lazy-search [& colls]
  (if (= 1 (count colls))
    (first (first colls)) 
    (let [heads (map first colls) largest (apply max heads)]
      (if (apply = heads)
        largest
        (recur (map (fn [c] (drop-while #(< % largest) c)) 
                 colls))))))
#'user/lazy-search
user> (lazy-search [3 4 5])
3
user> (lazy-search [1 2 3 4 5 6 7] [0.5 3/2 4 19])
4
user> (lazy-search (range) (range 0 100 7/6) [2 3 5 7 11 13])
7
user> (lazy-search (map #(* % % %) (range))   (filter #(zero? (bit-and % (dec %))) (range))
          (iterate inc 20))
64

(= 64 (__ (map #(* % % %) (range)) ;; perfect cubes
          (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2
          (iterate inc 20))) ;; at least as large as 20

(fn lazy-search [& colls]
  (if (= 1 (count colls))
    (first (first colls)) 
    (let [heads (map first colls) largest (apply max heads)]
oo      (if (apply = heads)
        largest
        (recur (map (fn [c] (drop-while #(< % largest) c)) 
                 colls))))))

(fn [& xxs]
  (let [[v-min v-max] (first (apply map (juxt min max) xxs))]
    (if (= v-min v-max)
      v-min
      (recur (map (fn [xs]
                    (drop-while #(< % v-max) xs)) xxs)))))

(fn [s & ss]
  (let [x (apply = (map (comp first #(drop-while (fn [x] (< x (first s))) %)) (into ss [s])))]
    (if x
    (first s)
    (recur (rest s) ss))))

(fn [s & ss]
  (let [x (apply = (map (comp first #(drop-while (fn [x] (< x (first s))) %)) (into ss [s])))]
    (if x
    (first s)
    (recur (rest s) ss))))

(fn [& colls]
  (let [firstVals (map first colls) ;get the min for each coll
        minVal (apply min firstVals)] ;get the min among the mins
    (if (every? #(= minVal %) firstVals) minVal ;return the global min
      (recur (for [coll colls] ;for shall generate the list
               (if (= (first coll) minVal) ;if the local min is not found in other colls
                 (rest coll);then adjust the cursor
                 coll))))));else don't change

(fn [& xss]
  (cond
    (= 1 (count xss)) (ffirst xss)
    (apply = (map first xss)) (ffirst xss)
    (< (ffirst xss) (ffirst (rest xss))) (recur (concat (rest xss) [(rest (first xss))]))
    true (recur (concat (rest xss) [(first xss)]))))

aceeca1's solution:

1
2
3
4
(letfn [
    (match? [x s] (or (= x (first s)) (and (> x (first s)) (recur x (rest s)))))
    (first-common [s1 & sn] (first (drop-while #(not-every? (partial match? %) sn) s1)))]
    first-common)
adereth's solution:

1
2
3
4
5
6
(fn [& s]
  (loop [s s]
    (if (every? #(= (first %) (ffirst s)) s) 
      (ffirst s)
      (let [t (sort-by first s)]
            (recur (cons (rest (first t)) (rest t)))))))
aferrandi's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn lazysearch[& xs] ((fn lazysearchRec[xs]
    (if((fn someEmpty[xs] (some empty? xs))  xs) nil
        (let [
            firsts (map first xs)
            maxFirst ((fn maxOfMany[x] (reduce max x)) firsts)
            allMax? ((fn allEqualTo[x n] (every? #(= n %) x)) firsts maxFirst)
            ]
                (if allMax? 
                    maxFirst
                    (lazysearchRec ((fn dropWhileLessThanAll[xs n] (map (fn [x] ((fn dropWhileLessThan[x n] (drop-while #(< % n) x))
 x n)) xs)) xs maxFirst))
                )
        )
    ))
 (vec xs)))
aguirre's solution:

1
2
3
4
(fn lce [& xss]
     (if (apply = (map first xss)) (first (first xss))
       (let [sorted-xss (sort #(compare (first %1) (first %2)) xss)]
         (apply lce (conj (rest sorted-xss) (rest (first sorted-xss)))))))
alanforr's solution:

1
2
3
4
5
6
7
8
9
10
(fn ([coll] (first coll))
  ([coll & c]
    (letfn [(all-less [a b] (last (take-while #(<= % a) b)))
            (incolls? [a c]
                      (let [li (concat [a] (map #(all-less a %)  c))]
                        (apply = li)))]
           (loop [n 0]
                 (if (incolls? (nth coll n) c)
                     (nth coll n)
                     (recur (inc n)))))))
allenl's solution:

1
2
3
4
5
6
7
8
9
10
(fn smallest-common
  [& seqs]
  (if (some empty? seqs) nil
      (let [heads (map first seqs)
            smallest (apply min heads)
            is-smallest (not-any? #(> % smallest) heads)]
        (if is-smallest
          smallest
          (->> (map #(if (= (first %) smallest) (rest %) %) seqs)
               (apply smallest-common))))))
andthorn's solution:

1
2
3
4
5
6
(fn [& l]
  (let [l (sort-by first l)
        m (first (first l))]
    (if (every? #(= m %) (map first l))
      m
      (recur (cons (next (first l)) (next l))))))
anjensan's solution:

1
2
3
4
5
6
(fn [& s]
  (let [f (map first s)]
    (if (apply = f)
      (first f)
      (let [m (reduce max f)]
        (recur (map (fn [x] (drop-while #(< % m) x)) s))))))
astangl's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn
  [& colls]
  (letfn [(intersect-sorted-list [a b]
            (lazy-seq
              (if (and (seq a) (seq b))
                (let [fa (first a)
                      fb (first b)]
                  (cond
                    (< fa fb) (intersect-sorted-list (rest a) b)
                    (> fa fb) (intersect-sorted-list a (rest b))
                    :else (cons fa (intersect-sorted-list
                                     (rest a) (rest b))))))))]
    (first (reduce intersect-sorted-list colls))))
austintaylor's solution:

1
2
3
4
5
6
7
8
9
(fn [& seqs]
  (loop [seqs seqs]
    (let [heads (map first seqs)]
      (if (apply = heads)
        (first heads)
        (let [sorted (sort-by first seqs)]
          (recur
            (cons (rest (first sorted))
              (rest sorted))))))))
awebb's solution:

1
2
3
4
5
6
7
8
9
10
(fn f
  ([[a & ar]] a)
  ([a b & args]
    (letfn [(li [[x & xr :as xs] [y & yr :as ys]]  
      (cond
        (> x y) (recur xs yr)
        (< x y) (recur xr ys)
        :else (cons x (lazy-seq (li xr yr))) ))]
      (first (reduce li a (cons b args)))
        )))
bendykst's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn lsearch [& seqs]
  (if 
    (apply = (map first seqs))
    (ffirst seqs)
    (let 
      [min-head (apply min (map first seqs))]
      (apply lsearch 
        (map 
          (fn [[head & tail :as coll]] 
            (if (= min-head head) tail coll))
          seqs)))))
benhammond's solution:

1
2
3
4
5
(fn [& sqs]
    (let [fsq (map first sqs)
          mfs (apply min fsq)]
      (if (apply = fsq) mfs
          (recur (map (fn [sq] (drop-while #(= mfs %) sq)) sqs)))))
benizi's solution:

1
2
3
4
5
6
7
8
(fn [& seqs]
  (loop [seqs seqs]
    (let [firsts (map first seqs)]
      (if (apply = firsts)
        (first firsts)
        (let [sorted (sort-by first seqs)
              [fs & rs] sorted]
          (recur (cons (next fs) rs)))))))
bobuhiro11's solution:

1
2
3
4
5
6
(fn lazy-search [& colls]
  (let [first-eles (map first colls)]
    (if (every? #(= (first first-eles) %) first-eles)
      (first first-eles)
      (let [sorted-colls (sort-by first colls)]
        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))
burner's solution:

1
2
3
4
5
6
7
8
9
10
(letfn [(update [seqs] 
                (let [seqs (sort #(< (first %1) (first %2)) seqs)]
                  (if (every? #(= (first %) (first (first seqs))) seqs)
                    (first (first seqs))
                    (cons (rest (first seqs)) (rest seqs)))))
              (update-n [seqs]
                (if (seq? (update seqs))
                  (recur (update seqs))
                  (update seqs)))]
        (fn [& seqs] (update-n seqs)))
caterpillar's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn [l & ls]
  (letfn[(findVal[sv v]
                  (loop[i 0]
                    (let[cv (nth sv i)]
                      (cond
                       (= cv v) true
                       (> cv v) false
                       :else (recur (inc i))
                       ))))]
    (if (seq ls) (loop [i 0]
                   (let [lv (nth l i)]
                     (if (reduce #(and %1 %2) (map #(findVal % lv) ls)) lv
                       (recur (inc i))
                       )
                     )
                   )
      (first l)
      )
    )
  )
cc787's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn lazysearch [& ls]
  (let [firsts (map first ls)
        maxfirst (apply max firsts)]
    (if (apply = firsts)
      (first firsts)
      (recur
       (reduce (fn [acc l] (conj acc (if (< (first l) maxfirst)
                                       (rest l)
                                       l)))
               []
               ls)))
    )
  )
chunchangshao's solution:

1
2
3
4
#(case (count %&)
   1 3
   2 4
   ((fn [x] (if (= (nth (first x) 3) 27) 64 7)) %&))
ctzsm's solution:

1
2
3
4
5
(fn [& colls]
  (inc (last (for [ans (range) :while (not 
                                  (every? identity (for [c colls] (last
                                                     (for [x c :while (<= x ans)] (= x ans))))))] ans
          ))))
dan7es's solution:

1
2
3
4
5
6
7
8
9
10
(fn lazy-search [& seqs]
  (loop [xs (mapv first seqs)
         seqs (vec seqs)]
    (if (apply = xs)
      (first xs)
      (let [idx (->> (map-indexed vector xs)
                     (apply min-key second)
                     first)]
        (recur (assoc xs idx (second (seqs idx)))
               (update-in seqs [idx] rest))))))
daniels's solution:

1
2
3
4
5
6
7
(fn r [& s] 
  (let [f (map first s)] 
    (if (apply == f) 
      (first f) 
      (recur 
       (map #(if (< (first %) (apply max f)) (rest %) %) 
            s) ))))
daowen's solution:

1
2
3
4
5
6
(fn low [& ss]
  (let [heads (map first ss)
        hi (apply max heads)
        adv #(map (fn [[h & t :as v]] (if (> hi h) t v)) %)]
    (if (apply = hi heads) hi
      (apply low (adv ss)))))
del680202's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn [& seqs]
  (let [_sort #(> (first %2) (first %1))
       _getF (comp first first)
       _getL (comp first last)
       _shift (fn [large ms] (for [m ms] (let [[v ind seq] m] (if (> large v)[(nth seq (inc ind)) (inc ind) seq] m))))]
  (loop [m (sort _sort (for [ seq seqs] [(first seq) 0 seq]))]
    (if (= (_getF m) (_getL m))(_getF m)
       (recur (sort _sort (_shift (_getL m) m)))
    )     
  )
  )
)
deping's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn ! [x & xs]
  (letfn [
          (rslt [ss] 
                 (let [sls (map first ss)
                       sms (reduce min sls)
                       rmsms (map #(if (= (first %) sms) (drop 1 %) %) ss)]
                   rmsms))
          (ok? [ss] 
               (= 1 (count (distinct (map first ss)))))
          (dothework [ss]
            (if (ok? ss) (-> ss first first)
              (dothework (rslt ss))))
          ]
    (dothework (cons x (vec xs)))
    ) )
devm33's solution:

1
2
3
4
5
6
(fn __ [& colls]
  (let [firsts (map first colls)]
    (if (apply = firsts)
      (ffirst colls)
      (let [m (apply min firsts)]
        (apply __ (map #(if (= m (first %)) (next %) %) colls))))))
dwelte's solution:

1
2
3
4
(fn [& xs]
  (if (apply = (map first xs))
    (first (first xs))
    (recur (map #(if (= (first %) (apply min (map first xs))) (rest %) %) xs))))
dzholev's solution:

1
2
3
4
5
6
7
(fn
  ([[f & _]] f)
  ([f & n] (let [h (first f)
                ls (map (fn [s] (drop-while #(< % h) s)) n)]
                  (if (every? #(= h (first %)) ls)
                    h
                    (recur (rest f) ls)))))
echevarria's solution:

1
2
3
4
5
6
7
8
9
(fn rec-lazy-search [ & xs ]
    (let [ 
            first-guys (map #(first %) xs)
            equality?  (apply = first-guys) 
            max-n      (apply max first-guys)
            ]
        (if equality?
            max-n
            (recur (map (fn[s] (drop-while #(< % max-n) s)) xs)))))
ericw's solution:

1
2
3
4
5
6
(fn [& seqs]                                                                                                                    
    (loop [is (take (count seqs) (repeat 0))]                                                                                                           
        (let [vs (map #(nth %1 %2) seqs is)]                                                                                    
            (if (apply = vs) (first vs)                                                                                                                 
                (let [max-v (apply max  vs)]                                                                                    
                    (recur (map #(if (< %2 max-v) (inc %1) %1) is vs)))))))
featalion's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn lazy-search [& colls]
  (letfn [(seqs-max [cs] (apply max (map first cs)))
          (drop-in-seqs-while
           [cs pred]
           (map (fn [c] (drop-while pred c)) cs))
          (all-first-eq?
           [to cs]
           (reduce #(and %1 (= to (first %2))) true cs))]
    (let [max-elem (seqs-max colls)
          colls (drop-in-seqs-while colls #(> max-elem %))]
      (if (all-first-eq? max-elem colls)
        max-elem
        (apply lazy-search colls)))))
finsternis's solution:

1
2
3
4
5
(fn [& ss]
  (let [vs (map first ss) mn (apply min vs)]
    (if (apply = vs)
      (first vs)
      (recur (map #(if (= (first %) mn) (rest %) %) ss)))))
flububb's solution:

1
2
3
4
5
6
7
(fn lazy-search
  [& args]
    (loop [c args]
      (if (apply = (map first c))
        (first (first c))
        (let [[a & r] (sort-by first c)]
          (recur (conj r (next a)))))))
garyxia's solution:

1
2
3
4
5
6
(fn lazy-search [& colls]
  (let [first-eles (map first colls)]
    (if (every? #(= (first first-eles) %) first-eles)
      (first first-eles)
      (let [sorted-colls (sort-by first colls)]
        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))
geekerzp's solution:

1
2
3
4
5
(fn [& xs]
    (if (apply = (map first xs))
      (ffirst xs)
      (let [smallest (apply min (map first xs))]
        (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))
glchapman's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn lazy-search [& sqs]
    (letfn [(intersect [s1 s2] (lazy-seq
                (when (and (seq s1) (seq s2))
                    (let [h1 (first s1)
                          h2 (first s2)]
                        (cond
                            (= h1 h2) (cons h1 (intersect (rest s1) (rest s2)))
                            (< h1 h2) (intersect (rest s1) s2)
                            :else (intersect s1 (rest s2))
                        )))))
        ]
        (first (reduce intersect sqs))
    ))
goaranger's solution:

1
2
3
4
5
6
7
(fn [a & b]
  (let [pvec (fn pv [v bg] (map #(if-not (= bg (first %)) (rest %) %) v))]
  (loop [vecs (into (vector a) b)
         biggest (apply max (map #(first %) vecs))]
    (if (apply = (map #(first %) vecs))
      (first (first vecs))
        (recur (pvec vecs biggest) (apply max (map #(first %) (pvec vecs biggest))))))))
gpittarelli's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [& seqs]
  (loop [state (map #(vector (first %1) (drop 1 %1)) seqs)]
    (let [cur-max (apply max (map first state))]
      (if (apply = (map first state))
        (ffirst state)
        (recur
         (map (fn [[cur s]]
                (if (= cur cur-max)
                  (vector cur s)
                  (vector (first s) (drop 1 s))))
              state))))))
happycrisis's solution:

1
2
3
4
5
(fn [& ss] 
    (let [hs (map first ss)  m (apply min hs) ]
             (if (apply = hs)
               m
               (recur (map #(if (= (first %) m) (rest %) %) ss)))))
hisba's solution:

1
2
3
4
5
6
(fn lsn [& allseqs]
  (loop [s allseqs]
    (let [maf (apply max (map first s))
          n_s (map (fn [v] (drop-while #(< % maf) v)) s)]
      (if (apply = (map first n_s)) (first (first n_s))
        (recur n_s)))))
icamts's solution:

1
2
3
4
5
(fn [& seqs]
  (let [heads (map first seqs)] 
    (if (apply = heads) (first heads)
      (let [next (apply max heads)]
        (recur (map #(drop-while (partial > next) %) seqs))))))
immo's solution:

1
2
3
4
5
6
7
8
(fn [& a]
  (let [f (map first a)]
    (if (apply = f)
      (first f)
      (recur
        (map
          #(if (= (apply min f) (first %)) (rest %) %)
          a)))))
jarlax's solution:

1
2
3
4
5
6
7
8
(fn [& colls]
  (loop [colls colls]
    (let [fs (map first colls)
          cand (apply max fs)
          found? (every? #(= cand %) fs)
          move #(if (> cand (first %)) (rest %) %)
          next (map move colls)]
      (if found? cand (recur next)))))
jedo's solution:

1
2
3
4
5
6
7
8
9
10
(fn lazysearch [& lazyseqs]
  (loop [lazyseqs lazyseqs]
        (let [starts (into [] (map first lazyseqs))
              smallestn (.indexOf starts (apply min starts))]
            (if (apply = starts) (first starts)
                (recur (map #(if (= smallestn %1) (rest %2) %2) (iterate inc 0) lazyseqs))
            )
        )
    )
)
jeff_terrell's solution:

1
2
3
4
5
6
7
8
(fn [& ss]
  ((fn f [ss]
     (let [fs (mapv first ss)
           m (apply min fs)]
       (if (apply = fs)
         (first fs)
         (recur (map #(if (= m (first %)) (rest %) %) ss)))))
   ss))
johncowie's solution:

1
2
3
4
5
(fn ls [& a]
  (if (apply = (map first a))
    (first (first a))
    (let [s (sort-by first a)]
      (apply ls (cons (rest (first s)) (rest s))))))
jomicoll's solution:

1
2
3
4
5
6
7
8
9
10
(fn lazy-search [& colls]
  (let [firsts  (map first colls)
        largest (apply max firsts)
        smallest (apply min firsts)]
    (if (= largest smallest)
      smallest
      (let [not-largest (group-by #(< (first %) largest) colls)
            incremented (map rest (not-largest true))
            unchanged (not-largest false)]
        (apply lazy-search (concat incremented unchanged))))))
jorendorff's solution:

1
2
3
4
5
6
7
8
9
(comp first #(reduce
              (fn intersect-sorted [[x & xs :as xxs] [y & ys :as yys]]
                (lazy-seq
                 (cond
                  (not (and (seq xxs) (seq yys))) '()
                  (= x y) (cons x (intersect-sorted xs ys))
                  (< x y) (intersect-sorted xs yys)
                  :else   (intersect-sorted xxs ys))))
              %&))
jslavin's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(fn lazysearch [s & args]
  (letfn [(search [s]
                  (let [sfor (first s)]
                    (if (every? #(= sfor %) (reduce (partial searchseq sfor) [] args))
                      sfor
                      (search (rest s))
                      ))
                  )
          (searchseq [sfor acc arg]
                     (loop [x arg]
                       (let [agval (first x)]
                         (cond (= agval sfor) (conj acc agval)
                               (> agval sfor) (conj acc false)
                               :otherswise (recur (rest x))
                               )
                         )
                       ))]
    (search s)
    )
  )
kohyama's solution:

1
2
3
4
5
6
(fn [xs & yss]
  (letfn [(d [m ss] (map (partial drop-while #(< % m)) ss))]
    (loop [[h & r] xs ss (d h yss)]
      (if (apply = h (map first ss))
          h
          (recur r (d (first r) ss))))))
kopychenko's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(fn lazy-searching [& args]
  (let [a (map #(vector %,#{(first %)}) args)]
    (loop [a a, lastmax 0]
      (let [a2 (map 
                (fn [[ax,sx]] 
                  (if (< (last sx) lastmax) 
                    [(rest ax), #{(first ax)} ] [ax sx])) 
                a)
            ss (map last a2)
            ssm (apply max (map #(last %) ss))
            iss (apply clojure.set/intersection ss)]
        
        (if (empty? iss) 
          (recur a2 ssm) 
          (first iss))))))
blucas's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(fn prob108
  [& colls]
  (letfn [(max-first-value
            [colls]
            (apply max (map first colls)))
          (all-first-same
            [cols]
            (apply = (map first cols)))
          (drop-leading-smaller
            [val colls]
            (map (partial drop-while #(< % val)) colls)
            )]
  (let [max-first-value (max-first-value colls)]
    (if (all-first-same colls)
      max-first-value
      (recur (drop-leading-smaller max-first-value colls))))
))
brendan's solution:

1
2
3
4
(fn [& seqs]
  (if (apply = (map first seqs)) 
    (first (first seqs))
    (recur (map #(drop-while (partial > (second (first seqs))) %) seqs))))
kuze's solution:

1
2
3
4
5
6
7
8
9
(fn my-lazy-searching
  [& colls]
  (letfn [(lazy-contains? [val coll] (if (= val (first (drop-while #(< % val) coll)))
                                       true
                                       false))]
    (loop [toFind (first (first colls)) i 1]
      (if (not-any? false? (map #(lazy-contains? toFind %) colls))
        toFind
        (recur (first (drop i (first colls))) (inc i))))))
lackita's solution:

1
2
3
4
5
6
7
8
9
(fn search [& sequences]
  (let [smallest-values (map first sequences)]
    (if (apply = smallest-values)
      (first smallest-values)
      (apply search (map #(if (= (apply min smallest-values)
                                 (first %))
                            (rest %)
                            %)
                         sequences)))))
lambda4fun's solution:

1
2
3
4
5
6
7
8
(fn [& xss]
  (loop [xss xss]
    (if (not-any? empty? xss)
      (if (apply = (map first xss))
        (ffirst xss)
        (let [a (apply max (map first xss))]
          (recur (for [xs xss]
                   (drop-while #(< % a) xs))))))))
lasthemy's solution:

1
2
3
4
5
6
7
8
(fn lazy-search [& colls]
  (if (apply = (map first colls))
    (first (first colls))
    (let [smallest (apply min (map first colls))]
      (recur (map #(drop-while (partial = smallest) %) colls))
      )
   )
  )
lbarrett's solution:

1
2
3
4
5
(fn f [& seqs]
  (if (apply = (map first seqs))
    (ffirst seqs)
    (let [m (apply max (map first seqs))]
      (apply f (map (partial drop-while (partial > m)) seqs)))))
leetwinski's solution:

1
2
3
4
5
6
7
8
9
10
11
12
(fn f
  ([c] (first c))
  ([c & colls]
    (if (some empty? (cons c colls)) 
      nil
      (let [f-c (first c) 
            s-c (map (fn [c] (split-with #(<= % f-c) c)) colls)
            firsts (map first s-c)
            lasts (map last s-c)]
        (if (every? #(and (not (empty? %)) (= (last %) f-c)) firsts)
          f-c
          (apply f (cons (rest c) lasts)))))))
littlejp2046's solution:

1
2
3
4
5
6
(fn mini [ & l] 
  (let [firstlist (map first l)
        currentmini (apply min firstlist)]
        (if (apply = firstlist)
          currentmini
          (apply mini (map #(drop-while (partial = currentmini) %) l)))))
malvert's solution:

1
2
3
4
5
6
7
(fn [seq & seqs]
  (first
    (filter (fn [e] 
      (every? (fn [s] (= e 
        (last (take-while #(<= % e) s)))) 
        seqs)) 
    seq)))
matiasl's solution:

1
2
3
4
5
6
7
(fn [& seqs]
  (loop [ss seqs]
    (let [firsts (map first ss)]
      (if (apply = firsts)
        (first firsts)
        (let [[ls & gs] (sort-by first ss)]
          (recur (cons (rest ls) gs)))))))
maximental's solution:

1
2
3
4
5
6
(fn f [& s] 
  (let [h (map first s)
        m (apply max h)]
    (if (apply = h)
      m 
      (apply f (map (fn [z] (drop-while #(< % m) z)) s)))))
mbakhterev's solution:

1
#(loop [S %&] (let [H (map first S) m (apply min H)] (if (apply = H) m (recur (map (fn [[q & Q :as s]] (if (= m q) Q s)) S)))))
meerwolf's solution:

1
2
3
4
5
6
7
8
9
(fn least-common-element
  [& colls]
  (cond
    (empty? colls)               nil
    (some empty? colls)          nil
    (apply = (map first colls))  (ffirst colls)
    :else (let [sorted-colls (sort-by first colls)]
            (recur (cons (rest (first sorted-colls))
                         (rest sorted-colls))))))
mfikes's solution:

1
2
3
4
5
6
(fn [& xs]
  (loop [seqs xs]
    (if (apply = (map first seqs))
      (ffirst seqs)
      (let [max-first (apply max (map first seqs))]
        (recur (map #(if (< (first %) max-first) (rest %) %) seqs))))))
minitrue's solution:

1
2
3
4
5
6
(fn [& xss]
  (let [heads (map first xss)
        maxv (apply max heads)]
    (if (apply = heads)
      maxv
      (recur (map #(if (= maxv %1) %2 (rest %2)) heads xss)))))
mkahn's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
(fn lazysearch [& x]
              (if (empty? (rest x))
                (first (first x))
                (loop [q (first (first x)) w (rest (first x)) counter0 (rest x) counter1 (first (rest x)) counter2 (first (first (rest x)))]
                  (if (empty? counter0)
                    q
                    (if (== q counter2)
                      (if (empty? (rest counter0))
                        q
                        (recur q w (rest counter0) (first (rest counter0)) (first (first (rest counter0)))))
                      (if (> q counter2)
                        (recur q w counter0 (rest counter1) (first (rest counter1)))
                        (recur (first w) (rest w) (rest x) (first (rest x)) (first (first (rest x))))))))))
mobiusloop's solution:

1
2
3
4
5
(fn [& x]
  ((comp first first first)
(drop-while #(apply not= (map first %1))
(iterate (fn [m] (let [h (apply max (map first m))] (map (fn [a] (drop-while #(< %1 h) a)) m))) x)
)))
mononite's solution:

1
2
3
4
5
6
7
(fn [& xs]
  (loop [xs xs]
    (when-let [no-empty (every? (complement empty?) xs)]
      (let [first-vals (map first xs) min-val (apply min first-vals)]
        (if (every? #(= min-val %) first-vals)
          min-val
          (recur (map #(if (= min-val (first %)) (rest %) %) xs)))))))
mouse's solution:

1
2
3
4
(fn m [& s]
    (let [[l h] (apply (juxt min max) (map first s))]
      (if (= h l) l
          (apply m (map (partial drop-while #(< % h)) s) ))))
mwaldowski's solution:

1
2
3
4
5
6
7
8
9
(fn [& colls]
  (let [head (map first colls)]
    (if (apply = head)
      (first head)
      (if (some nil? head)
        nil
        (let [min-val (apply min head)]
          (recur (map #(if (= (first %) min-val) (rest %) %)
                      colls)))))))
nagi's solution:

1
2
3
4
5
6
7
8
(fn ls [& seqs]
  (let [sorted-seqs (sort #(compare (first %1) (first %2)) seqs)
        lowest-seq (first sorted-seqs)
        found? (apply = (map first sorted-seqs))]
 
    (if found?
      (first lowest-seq)
      (recur (into [] (conj (rest sorted-seqs) (rest lowest-seq)))))))
nikelandjelo's solution:

1
2
3
4
5
6
(fn lazy-search [& seqs]
  (let [[base & rst] seqs
        has-not? (fn [s el] (not= el (first (drop-while #(< % el) s))))]
  (if (nil? rst)
    (first base)
    (first (drop-while (fn [el] (some #(has-not? % el) rst)) base)))))
noiseehc's solution:

1
2
3
4
5
6
7
8
9
(fn [& args] 
  (if (some empty? args)
    nil ; no value
    (let [vals (map first args)] 
      (if (apply = vals)
        (first vals) ; smallest value
        (let [minval (apply min vals)]
          (recur (map #(if (= (first %) minval) (rest %) %) args))
          )))))
norman's solution:

1
2
3
4
5
6
7
8
(fn lsearch [& inseqs]
  (loop [seqs inseqs]
    (when (every? not-empty seqs)
      (let [firstvals (map first seqs)
            smallest (apply min firstvals)]
        (if (every? #(= smallest %) firstvals)
          smallest
          (recur (map #(if (= (first %) smallest) (rest %) %) seqs)))))))
nothsaevets's solution:

1
2
3
4
5
6
7
(fn [& seqs]
  (loop [seqs seqs]
    (let [heads (map first seqs)
          largest (apply max heads)]
      (if (apply = heads)
        (ffirst seqs)
        (recur (map #(drop-while (partial > largest) %) seqs))))))
owk4057's solution:

1
2
3
4
5
(fn [& colls]
  (loop [colls colls]
    (let [colls (sort-by first colls)]
        (if (apply = (map first colls)) (first (map first colls))
          (recur (cons (rest (first colls)) (rest colls)))))))
ownwaterloo's solution:

1
2
3
4
5
6
7
(fn [& xss]
  (->> xss
    (iterate
     (fn [[[h :as hs] & tss]]
       (conj (mapv (partial drop-while (partial > h)) tss) hs)))
    (drop-while #(not (apply = (map first %))))
    first first first))
ozan's solution:

1
2
3
4
5
6
7
(fn lazy-search [& seqs]
  (let [smallest (first (first seqs))
        dropped (map (fn [xs] (drop-while #(< % smallest) xs)) seqs)
        firsts (map first dropped)]
    (if (apply = firsts)
      smallest
      (apply lazy-search (cons (rest (first dropped)) (rest dropped))))))
pukeface's solution:

1
2
3
4
5
6
(fn q [& S]
    (let [f (vec (map first S))]
    (if (apply = f) (first f)
        (let [l (apply min-key f (range 0 (count S)))]
             (recur (map-indexed #(if (= %1 l) (rest %2) %2) S))
    ))))
quant1's solution:

1
2
3
4
5
(fn [& x]
  (let [m (apply max (map first x))
        y (map (partial drop-while #(< % m)) x)
        v1 (map first y)]
    (if (apply = v1) (first v1) (recur y))))
rodmax's solution:

1
2
3
4
5
#(let [a (apply (juxt = max) (map first %&))]
  (if
   (a 0) (ffirst %&)
   (recur (map (partial drop-while (partial > (a 1))) %&))
  ))
sbondaryev's solution:

1
2
3
4
5
(fn f [& args]
  (let [mx (apply max (map first args))]
    (if (apply = (map first args))
      mx
      (apply f (map #(if (< (first %) mx) (rest %) %) args)))))
shiro's solution:

1
2
3
4
5
6
7
(fn lazy-search [& seqs]
  (if (= 1 (count seqs)) (ffirst seqs)
    (loop [seqs seqs]
      (let [firstvals (map first seqs)
            low-val (apply min firstvals)]
        (if (apply = firstvals) low-val
          (recur (map #(if (= low-val (first %)) (rest %) %) seqs)))))))
sheldon's solution:

1
2
3
4
5
(fn f ([& x] 
  (let [y (zipmap (map first x) (range)) 
        m (first (apply min-key key y))] 
(if (= 1 (count y)) m 
(apply f (map #(if (= m (first %)) (rest %) %) x))))))
silverio's solution:

1
2
3
4
5
#(let [h (map first %&)
       m (apply min h)
       p (partial = m)]
  (if (every? p h) m
    (recur (map (partial drop-while p) %&))))
skyrem's solution:

1
2
3
4
5
(fn [& args]
  (loop [start 0 news args]
    (if (apply = (map first news)) (ffirst news)
      (recur (apply max (map first news))
             (map (fn [x] (drop-while #(> start %) x)) news)))))
soul_awaker's solution:

1
2
3
4
5
6
7
8
9
10
(fn [& s]
  ((fn [i n]
    (let [x (filter integer? (apply clojure.set/intersection i))]
      (if (and (seq x) (apply min x))
          (apply min x)
          (let [e (apply max (map first n))
                a (map #(take-while (partial >= e) %) n)
                b (map #(drop-while (partial >= e) %) n)]
            (recur (map into i a) b)))))
    (repeat (count s) #{}) s))
staafl2's solution:

1
2
3
4
5
6
7
8
9
10
11
(fn [& xss]
  (loop [xss xss]
    (let [xs (map first xss)
          min-ix (first (apply min-key second (map-indexed vector xs)))]
      (if
        (= 1 (count (distinct xs)))
        (first xs)
        (recur
          (map-indexed
            (fn [i xs] (if (= i min-ix) (rest xs) xs))
            xss))))))
syeerzy's solution:

1
2
3
4
5
(fn [& a]
  (let [f (map first a)]
    (if (apply = f)
      (first f)
      (recur (map #(if (= (apply min f) (first %)) (rest %) %) a)))))
tclamb's solution:

1
2
3
4
5
6
7
8
(fn [& seqs]
  (let [firsts (map first seqs)
        min (apply min firsts)
        max (apply max firsts)]
    (if (= min max)
      min
      (recur (map #(if (= max (first %)) % (rest %))
                  seqs)))))
thegeez's solution:

1
2
3
4
5
6
(fn [& cs]
    (let [fs (map first cs)]
      (if (apply = fs)
        (first fs)
        (let [line (apply max fs)]
          (recur (map (partial drop-while (partial > line)) cs))))))
zzamboni's solution:

1
2
3
4
(fn lazy-search [& s]
  (loop [s s] (if (apply = (map first s)) (ffirst s)
                  (let [[fs & rs] (sort-by first s)]
                    (recur (cons (rest fs) rs))))))
zoltanjarai's solution:

1
2
3
4
5
6
(fn __ [& ls]
  (if (some empty? ls) nil
    (let [fs (map first ls)
          m (apply max fs)]
      (if (apply = fs) m
        (recur (map (fn [xs] (drop-while #(< % m) xs)) ls))))))
zipzop's solution:

1
2
3
4
5
(fn [& args]
  (let [m (map first args) s (apply max m)]
    (if (apply = m)
      s
     (recur (map (partial drop-while #(< % s)) args)))))
yusubori's solution:

1
2
3
4
5
6
(fn [a & as]
  (if (nil? as) (first a)
    (let [f (fn [v] (fn [coll] (first (filter #(= v %) (take-while #(>= v %) coll)))))]
      (ffirst
       (filter #(every? (complement nil?) %)
               (for [x a :let [fx (f x)]] (map fx as)))))))
ydash's solution:

1
2
3
4
5
6
(fn [l & ls]
  (loop [l l]
    (if (apply (partial = (first l))
               (map (comp last (partial take-while #(<= % (first l)))) ls))
      (first l)
      (recur (rest l)))))
vpeurala's solution:

1
2
3
4
5
6
7
8
9
(fn [& colls] (letfn [
(gt [n] #(> % n))
(lt [n] #(< % n))
(first-numbers-equal? [colls] (apply = (map first colls)))
(max-first-number [colls] (apply max (map first colls)))
(fast-forward [colls] (map #(drop-while (lt (max-first-number colls)) %) colls))
(fast-lazy-search [colls] (if (first-numbers-equal? colls) (max-first-number colls) (fast-lazy-search (fast-forward colls))))
(lazy-searching [& colls] (fast-lazy-search colls))
] (fast-lazy-search colls)))
v_bogdanov's solution:

1
2
3
4
5
(fn f [& s]
    (if (= 1 (count (distinct (map first s)))) (first (first s))
        (let [m (apply max (map first s))
              new-s (map #(if (< (first %) m) (rest %) %) s)]
        (apply f new-s))))
unionx's solution:

1
2
3
4
5
6
7
8
9
(fn lazy-search [& args]
  (let [all-h (map first args)
        least-h (reduce #(if (< %1 %2) %1 %2) all-h)]
    (if (apply = all-h)
      least-h
      (apply lazy-search (map #(if (= least-h (first %))
                                 (drop 1 %)
                                 %)
                              args)))))
trxeste's solution:

1
2
3
4
5
6
7
(fn lazy-search [& colls]
  (if (= 1 (count colls))
    (first (first colls))
    (let [heads (map first colls) largest (apply max heads)]
      (if (apply = heads)
        largest
        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))
transfinite's solution:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(fn scour [& vs]
  (if (reduce #(or % %2) (map #(empty? %) vs)) nil
      (let [  mins (map first vs)
            in-all (for [min mins]
                     (reduce #(and % %2)
                             (for [v vs]
                               (= min (last (take-while #(>= min %) v))))))
            ans (->> in-all
                     (interleave mins)
                     (partition 2)
                     (filter second)
                     (map first)
                     sort
                     first)]
        (if ans ans
            (apply scour (map next vs))))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us (team@4clojure.com)